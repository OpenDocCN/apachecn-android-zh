# 第九章。将现有库移植到安卓系统

> *人们对安卓 NDK 感兴趣有两个主要原因:第一，性能，第二，便携性。在前面的章节中，我们看到了为了提高效率，如何从原生代码中访问主要的原生 Android APIs。在这一章中，我们将把整个 C/C++ 生态系统带到安卓，嗯，至少发现了路径，因为几十年的 C/C++ 开发无论如何都很难适应移动设备的有限内存！事实上，C 和 C++ 仍然是当今使用最广泛的编程语言。*
> 
> *在之前的 NDK 版本中，由于部分支持 C++，可移植性受到限制，尤其是 **异常**和**运行时类型**信息( **RTTI** ，一种在运行时获取数据类型的基本 C++ 反射机制，如 Java 中的`instanceof`)。任何需要它们的库都不能被移植，除非修改它们的代码或者安装一个定制的 NDK(社区从官方来源重建的**水晶 NDK** ，在[http://www.crystax.net/](http://www.crystax.net/)可以得到)。希望从那以后，这些限制已经被取消了(除了广泛的字符支持)。*

虽然不一定很难，但是移植现有的库并不是一个简单的过程。可能会遗漏一些 API(尽管有很好的 POSIX 支持)，一些`#define`指令需要调整，一些依赖项需要移植，以及依赖项的依赖项。一些库很容易移植，而另一些库需要更多的努力。

在本章中，为了将现有代码移植到 Android，我们将学习如何执行以下代码:

*   激活**标准模板库** ( **STL** )
*   打开**箱 2D** 物理引擎
*   预构建并使用**增强**框架
*   深入了解如何编写 NDK 模块 **Makefiles**

到本章结束时，您应该了解本机构建过程，并知道如何适当地使用 Makefiles。

# 激活标准模板库

标准模板库是容器、迭代器、算法和助手类的规范化库，用于简化大多数常见的编程操作，如动态数组、关联数组、字符串、排序等。这个库多年来获得了开发人员的认可，并被广泛传播。在没有 STL 的情况下用 C++ 开发就像背着一只手编码一样！

在第一部分中，让我们将 GNU STL 嵌入 DroidBlaster 中，以简化集合管理。

### 注

产生的项目以`DroidBlaster_Part16`的名称提供本书。

# 行动时间-激活 DroidBlaster 中的 GNU STL

让我们激活并利用 DroidBlaster 中的 STL。编辑`jni/Android.mk`旁边的`jni/Application.mk`文件，写下以下内容。就这样！您的应用程序现在启用了 STL，这要感谢这一行:

```cpp
APP_ABI := armeabi armeabi-v7a x86
APP_STL := gnustl_static
```

## *刚刚发生了什么？*

仅用一行代码，我们就激活了`Application.mk`文件中的 GNU STL！通过`APP_STL`变量选择的这个 STL 实现取代了默认的 NDK C/C++ 运行时。目前支持以下三种 STL 实现:

*   **GNU STL** (更常见的是**libstdc++**)，官方 GCC STL:在 NDK 项目上使用 STL 时，这通常是首选。支持例外和 RTTI。
*   **STLport** (一个多平台 STL):这个实现没有被主动维护，缺少的一些特性。选择它作为最后的手段。支持例外和 RTTI。
*   **Libc++** :这是LLVM(Clang 编译器背后的技术)的一部分，旨在提供一个功能性的 C++ 11 运行时。请注意，这个库现在正在成为 OS-X 上的默认 STL，将来可能会越来越受欢迎。支持例外和 RTTI。Libc++ 支持仍然是不完整的和实验性的。Libc++ 经常与 Clang 编译器结合使用(请在*控制模块 Makefiles* 部分阅读更多相关内容)。

安卓还提供了另外两种 C++ 运行时:

*   **系统**:这是默认的 NDK 运行时，没有 STL 实现被激活。它的代号是**仿生**，它提供了一组极简的头文件(`cstdint`、`cstdio`、`cstring`等等)。仿生不提供 STL 特性，以及异常和**运行时类型信息** ( **RTTI** )。关于其局限性的更多细节，请看`$ANDROID_NDK/docs/system/libc/OVERVIEW.html`。
*   **Gabi** :这类似于系统运行时，只是它支持异常和 RTTI。

我们将在本章专门介绍 **Boost** 的部分看到如何在编译期间启用异常和 RTTI。

每个运行时都是可静态或动态链接的(默认系统 C/C++ 运行时除外)。动态加载的运行时是用`_shared`固定的，静态加载的运行时是用`_static`固定的。您可以传递给`APP_STL`的运行时标识符的完整列表如下:

*   `system`
*   `gabi++ _static`和`gabi++ _shared`
*   `stlport_static`和`stlport_shared`
*   `gnustl_static`和`gnustl_shared`
*   `c++ _static`和`c++ _shared`

请记住，共享库需要在运行时手动加载。如果忘记加载共享库，一旦加载了相关库模块，就会在运行时引发错误。由于编译器无法提前预测将调用哪些函数，所以库被完全加载到内存中，即使它们的大部分内容仍未使用。

另一方面，静态库实际上加载了依赖库。事实上，静态库在运行时并不真正存在。当它们被链接时，它们的内容在编译时被复制到相关的库中。由于链接器准确地知道从嵌入模块中调用了库的哪一部分，所以它可以剥离代码，只保留需要的部分。

### 类型

**剥离**是从二进制文件中丢弃不必要符号的过程。这有助于减少(潜在的很多！)链接后的二进制大小。这在某种程度上可以与 Java 中的 Proguard 收缩后处理相比。

但是，如果一个静态库被包含多次，链接会导致二进制代码重复。这种情况可能会导致内存浪费，或者更令人担忧的是，与全局变量重复等相关的问题。但是，共享库中的静态 C++ 构造函数只被调用一次。

### 类型

请记住，除非您知道自己在做什么，否则您应该避免使用在项目中不止一次出现的静态库。

需要考虑的另一点是，Java 应用程序只能加载共享库，共享库本身可以链接到共享库或静态库。例如，`NativeActivity`的主库是一个共享库，通过`android.app.lib_name`清单属性指定。之前必须手动加载从另一个库引用的共享库。NDK 自己不会这么做。

共享库可以在 JNI 应用程序中使用`System.loadLibrary()`轻松加载，但 `NativeActivity`是“透明”的活动。因此，如果您决定使用共享库，唯一的解决方案是编写您自己的 Java 活动，从`NativeActivity`继承并调用适当的`loadLibrary()`指令。例如，如果我们使用`gnustl_shared`来代替，下面是 DroidBlaster 活动的样子:

```cpp
package com.packtpub.DroidBlaster

import android.app.NativeActivity

public class MyNativeActivity extends NativeActivity {
     static {
         System.loadLibrary("gnustl_shared");
         System.loadLibrary("DroidBlaster");
     }
}
```

### 类型

如果您更喜欢直接从本机代码加载您的本机库，您可以使用系统调用`dlopen()`，这也是由 NDK 提供的。

既然 STL 已经启用，让我们在 DroidBlaster 中使用它。

# 动作时间-读取带 STL 流的文件

让我们使用 STL从 SD 卡中读取资源，而不是应用程序资产目录中的，如以下步骤所示:

1.  Obviously, enabling the STL is useless if we do not actively use it in our code. Let's take advantage of this opportunity to switch from asset files to external files (on a `sdcard` or internal memory).

    打开现有文件，`jni/Resource.hpp`，并执行以下操作:

    *   包括`fstream`和`string` STL 标题。
    *   文件名使用`std::string`对象，用`std::ifstream`对象(即输入文件流)替换资产管理成员。
    *   更改`getPath()`方法，从新的`string`成员返回一个 C 字符串。
    *   删除`descriptor()`方法和`ResourceDescriptor`类(描述符仅适用于资产应用编程接口)，如下所示:

        ```cpp
        #ifndef _PACKT_RESOURCE_HPP_
        #define _PACKT_RESOURCE_HPP_

        #include "Types.hpp"

        #include <android_native_app_glue.h>
        #include <fstream>
        #include <string>

        ...
        class Resource {
        public:
            Resource(android_app* pApplication, const char* pPath);

            const char* getPath() { return mPath.c_str(); };

            status open();
            void close();
            status read(void* pBuffer, size_t pCount);

            off_t getLength();

            bool operator==(const Resource& pOther);

        private:
            std::string mPath;
            std::ifstream mInputStream;
        };
        #endif
        ```

2.  打开相应的实现文件`jni/Resource.cpp`。用 STL 流和字符串替换以前的实现，基于资产管理应用编程接口。文件将以二进制模式打开，如下所示:

    ```cpp
    #include "Resource.hpp"

    #include <sys/stat.h>

    Resource::Resource(android_app* pApplication, const char* pPath):
        mPath(std::string("/sdcard/") + pPath),
        mInputStream(){
    }

    status Resource::open() {
        mInputStream.open(mPath.c_str(), std::ios::in | std::ios::binary);
     return mInputStream ? STATUS_OK : STATUS_KO;
    }

    void Resource::close() {
        mInputStream.close();
    }

    status Resource::read(void* pBuffer, size_t pCount) {
        mInputStream.read((char*)pBuffer, pCount);
        return (!mInputStream.fail()) ? STATUS_OK : STATUS_KO;
    }
    ...
    ```

3.  要读取文件长度，我们可以使用`sys/stat.h`头中的`stat()` POSIX 原语:

    ```cpp
    ...
    off_t Resource::getLength() {
        struct stat filestatus;
        if (stat(mPath.c_str(), &filestatus) >= 0) {
            return filestatus.st_size;
        } else {
            return -1;
        }
    }
    ...
    ```

4.  最后，我们可以使用 STL 字符串比较运算符来比较两个`Resource`对象:

    ```cpp
    ...
    bool Resource::operator==(const Resource& pOther) {
        return mPath == pOther.mPath;
    }
    ```

5.  These changes to the reading system should be almost transparent, except for the BGM, whose content was played through an asset file descriptor.

    现在，我们需要提供一个真实的文件。因此，在`jni/SoundService.cpp`中，通过将`SLDataLocator_AndroidFD`结构替换为`SLDataLocation_URI`来更改数据源，如下图所示:

    ```cpp
    #include "Log.hpp"
    #include "Resource.hpp"
    #include "SoundService.hpp"

    #include <string>
    ...
    status SoundManager::playBGM(Resource& pResource) {
        SLresult result;
        Log::info("Opening BGM %s", pResource.getPath());

        // Set-up BGM audio source.
        SLDataLocator_URI dataLocatorIn;
        std::string path = pResource.getPath();
        dataLocatorIn.locatorType = SL_DATALOCATOR_URI;
        dataLocatorIn.URI = (SLchar*) path.c_str();

        SLDataFormat_MIME dataFormat;
        dataFormat.formatType    = SL_DATAFORMAT_MIME;
        ...
    }
    ...
    ```

6.  在`AndroidManifest.xml`文件中，添加读取 SD 卡文件的权限如下:

    ```cpp
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.packtpub.droidblaster2d" android:versionCode="1"
        android:versionName="1.0">

        <uses-permission
            android:name="android.permission.READ_EXTERNAL_STORAGE" />

        ...
    </manifest>
    ```

在`/sdcard/droidblaster`中，将所有资产资源从资产目录复制到您的设备 SD 卡(或内存，取决于您的设备)。

## *刚刚发生了什么？*

我们已经看到了如何使用 STL 流访问位于 SD 卡上的二进制文件。我们还将 OpenSL ES 播放器从文件描述符切换为文件名定位器。文件名本身是从一个 STL 字符串创建的。STL 字符串是一个真正的好处，因为它们允许我们摆脱复杂的 C 字符串操作原语。

### 类型

几乎所有安卓设备都可以将文件存储在安装在目录`/sdcard`中的附加存储位置。“差不多”是这里的重要词。自从第一个安卓 G1 以来，“sd 卡”的意思就变了。一些最近的设备有一个实际上是内部的外部存储器(例如，一些平板电脑上的闪存)，而另一些设备有第二个存储位置供其使用(尽管在大多数情况下，第二个存储器安装在`/sdcard`内部)。此外，`/sdcard`路径本身并没有刻在大理石上。所以，要想安全地探测到额外的存储位置，唯一的解决办法就是依靠 JNI 呼叫`android.os.Environment.getExternalStorageDirectory()`。您也可以通过`getExternalStorageState()`检查储物空间是否可用。请注意，API 方法名称中的“外部”一词仅出于历史原因。此外，还需要清单中的许可`WRITE_EXTERNAL_STORAGE`。

STL 提供了比文件和字符串更多的特性。其中最受欢迎的可能是 STL 容器。让我们看看 DroidBlaster 中的一些用法示例。

# 行动时间-使用 STL 容器

现在让我们按照以下步骤用标准 STL 容器替换原始数组:

1.  Open the `jni/GraphicsManager.hpp` header and include the headers:
    *   `Vector`，它定义了一个封装 C 数组的 STL 容器(带有一些更有趣的特性，比如动态调整大小)
    *   `Map`，它封装了一个 Java HashMap 的等价物(也就是一个关联数组)

    然后，拆除`TextureProperties`结构中的`textureResource`构件。使用`map` 容器代替`mTextures`的原始数组(以`std`命名空间为前缀)。第一个参数是键类型，第二个是值类型。

    最后，用一个`vector`替换其他所有的原始数组，如下图所示:

    ```cpp
    ...
    #include <android_native_app_glue.h>
    #include <GLES2/gl2.h>
    #include <EGL/egl.h>

    #include <map>
    #include <vector>
    ...
    struct TextureProperties {
        GLuint texture;
        int32_t width;
        int32_t height;
    };

    class GraphicsManager {
        ...
        // Graphics resources.
        std::map<Resource*, TextureProperties> mTextures;
        std::vector<GLuint> mShaders;
        std::vector<GLuint> mVertexBuffers;

        std::vector<GraphicsComponent*> mComponents;

        // Rendering resources.
        ...
    };
    #endif
    ```

2.  编辑`jni/GraphicsManager.cpp`并在构造器初始化列表中初始化新的 STL 容器，如下所示:

    ```cpp
    #include "GraphicsManager.hpp"
    #include "Log.hpp"

    #include <png.h>

    GraphicsManager::GraphicsManager(android_app* pApplication) :
        ...
        mProjectionMatrix(),
        mTextures(), mShaders(), mVertexBuffers(), mComponents(),
        mScreenFrameBuffer(0),
        mRenderFrameBuffer(0), mRenderVertexBuffer(0),
        ... {
        Log::info("Creating GraphicsManager.");
    }
    ...
    ```

3.  注册时使用`vector::push_back()`方法将组件插入`mComponents`列表，如下图:

    ```cpp
    ...
    void GraphicsManager::registerComponent(GraphicsComponent* pComponent)
    {
        mComponents.push_back(pComponent);
    }
    ...
    ```

4.  在`start()`中，我们可以使用迭代器迭代向量来初始化每个注册的组件，如下图所示:

    ```cpp
    ...
    status GraphicsManager::start() {
        ...
        mProjectionMatrix[3][3] =  1.0f;

        // Loads graphics components.
        for (std::vector<GraphicsComponent*>::iterator
                componentIt = mComponents.begin();
                componentIt < mComponents.end(); ++ componentIt) {
            if ((*componentIt)->load() != STATUS_OK) return STATUS_KO;
        }
        return STATUS_OK;
        ...
    }
    ...
    ```

5.  在`stop()`中，我们可以迭代地图(第二个代表条目的值)和向量集合来释放这次分配的每个 OpenGL 资源，如下图所示:

    ```cpp
    ...
    void GraphicsManager::stop() {
        Log::info("Stopping GraphicsManager.");
        // Releases textures.
        std::map<Resource*, TextureProperties>::iterator textureIt;
        for (textureIt = mTextures.begin(); textureIt != mTextures.end();
                ++ textureIt) {
            glDeleteTextures(1, &textureIt->second.texture);
        }

        // Releases shaders.
        std::vector<GLuint>::iterator shaderIt;
        for (shaderIt = mShaders.begin(); shaderIt < mShaders.end();
                ++ shaderIt) {
            glDeleteProgram(*shaderIt);
        }
        mShaders.clear();

        // Releases vertex buffers.
        std::vector<GLuint>::iterator vertexBufferIt;
        for (vertexBufferIt = mVertexBuffers.begin();
                vertexBufferIt < mVertexBuffers.end(); ++ vertexBufferIt) {
            glDeleteBuffers(1, &(*vertexBufferIt));
        }
        mVertexBuffers.clear();

        ...
    }
    ...
    ```

6.  同样迭代存储的组件以在`update()`中渲染它们，如下图所示:

    ```cpp
    ...
    status GraphicsManager::update() {
        // Uses the offscreen FBO for scene rendering.
        glBindFramebuffer(GL_FRAMEBUFFER, mRenderFrameBuffer);
        glViewport(0, 0, mRenderWidth, mRenderHeight);
        glClear(GL_COLOR_BUFFER_BIT);

        // Render graphic components.
        std::vector<GraphicsComponent*>::iterator componentIt;
        for (componentIt = mComponents.begin();
                componentIt < mComponents.end(); ++ componentIt) {
            (*componentIt)->draw();
        }

        // The FBO is rendered and scaled into the screen.
        glBindFramebuffer(GL_FRAMEBUFFER, mScreenFrameBuffer);
        ...
    }
    ...
    ```

7.  由于纹理是昂贵的资源，在加载和缓存新实例之前，使用`map`检查纹理是否已经被加载，如下所示:

    ```cpp
    ...
    TextureProperties* GraphicsManager::loadTexture(Resource& pResource) {
        // Looks for the texture in cache first.
        std::map<Resource*, TextureProperties>::iterator textureIt =
                                               mTextures.find(&pResource);
        if (textureIt != mTextures.end()) {
            return &textureIt->second;
        }

        Log::info("Loading texture %s", pResource.getPath());
        ...
        Log::info("Texture size: %d x %d", width, height);

        // Caches the loaded texture.
        textureProperties = &mTextures[&pResource];
        textureProperties->texture = texture;
        textureProperties->width = width;
        textureProperties->height = height;
        return textureProperties;
        ...
    }
    ...
    ```

8.  使用定义的`vector`对象保存着色器和顶点缓冲区。再次使用`push_back()`给向量添加一个元素，如下图所示:

    ```cpp
    ...
    GLuint GraphicsManager::loadShader(const char* pVertexShader,
            const char* pFragmentShader) {
       ...
        if (result == GL_FALSE) {
            glGetProgramInfoLog(shaderProgram, sizeof(log), 0, log);
            Log::error("Shader program error: %s", log);
            goto ERROR;
        }

        mShaders.push_back(shaderProgram);
        return shaderProgram;

        ...
    }

    GLuint GraphicsManager::loadVertexBuffer(const void* pVertexBuffer,
            int32_t pVertexBufferSize) {
        ...
        if (glGetError() != GL_NO_ERROR) goto ERROR;

        mVertexBuffers.push_back(vertexBuffer);
        return vertexBuffer;
        ...
    }
    ```

9.  Now, open `jni/SpriteBatch.hpp`.

    这里再次包括并使用`vector`对象代替原始数组:

    ```cpp
    ...
    #ifndef _PACKT_GRAPHICSSPRITEBATCH_HPP_
    #define _PACKT_GRAPHICSSPRITEBATCH_HPP_

    #include "GraphicsManager.hpp"
    #include "Sprite.hpp"
    #include "TimeManager.hpp"
    #include "Types.hpp"

    #include <GLES2/gl2.h>
    #include <vector>

    class SpriteBatch : public GraphicsComponent {
        ...
        TimeManager& mTimeManager;
        GraphicsManager& mGraphicsManager;

        std::vector<Sprite*> mSprites;
        std::vector<Sprite::Vertex> mVertices;
        std::vector<GLushort> mIndexes;
        GLuint mShaderProgram;
        GLuint aPosition; GLuint aTexture;
        GLuint uProjection; GLuint uTexture;
    };
    #endif
    ```

10.  在`jni/SpriteBatch.cpp`中，用向量代替原始数组的用法，如下图所示:

    ```cpp
    ...
    SpriteBatch::SpriteBatch(TimeManager& pTimeManager,
            GraphicsManager& pGraphicsManager) :
        mTimeManager(pTimeManager),
        mGraphicsManager(pGraphicsManager),
        mSprites(), mVertices(), mIndexes(),
        mShaderProgram(0),
        aPosition(-1), aTexture(-1), uProjection(-1), uTexture(-1)
    {
        mGraphicsManager.registerComponent(this);
    }

    SpriteBatch::~SpriteBatch() {
        std::vector<Sprite*>::iterator spriteIt;
        for (spriteIt = mSprites.begin(); spriteIt < mSprites.end();
                ++ spriteIt) {
            delete (*spriteIt);
        }
    }

    Sprite* SpriteBatch::registerSprite(Resource& pTextureResource,
            int32_t pHeight, int32_t pWidth) {
        int32_t spriteCount = mSprites.size();
        int32_t index = spriteCount * 4; // Points to 1st vertex.

        // Precomputes the index buffer.
        mIndexes.push_back(index+0); mIndexes.push_back(index+1);
        mIndexes.push_back(index+2); mIndexes.push_back(index+2);
        mIndexes.push_back(index+1); mIndexes.push_back(index+3);
        for (int i = 0; i < 4; ++ i) {
            mVertices.push_back(Sprite::Vertex());
        }

        // Appends a new sprite to the sprite array.
        mSprites.push_back(new Sprite(mGraphicsManager,
                pTextureResource, pHeight, pWidth));
        return mSprites.back();
    }
    ...
    ```

11.  在加载和绘制过程中，在`vector`上循环。您可以使用`iterator`(在`load()`这里)，如下所示:

    ```cpp
    ...
    status SpriteBatch::load() {
        ...
        uTexture = glGetUniformLocation(mShaderProgram, "u_texture");

        // Loads sprites.
        std::vector<Sprite*>::iterator spriteIt;
        for (spriteIt = mSprites.begin(); spriteIt < mSprites.end();
                ++ spriteIt) {
            if ((*spriteIt)->load(mGraphicsManager)
                    != STATUS_OK) goto ERROR;
        }
        return STATUS_OK;

    ERROR:
        Log::error("Error loading sprite batch");
        return STATUS_KO;
    }

    void SpriteBatch::draw() {
        ...
        // Renders all sprites in batch.
        const int32_t vertexPerSprite = 4;
        const int32_t indexPerSprite = 6;
        float timeStep = mTimeManager.elapsed();
        int32_t spriteCount = mSprites.size();
        int32_t currentSprite = 0, firstSprite = 0;
        while (bool canDraw = (currentSprite < spriteCount)) {
            Sprite* sprite = mSprites[currentSprite];
            ...
        }
        ...
    }
    ```

12.  最后，在`jni/Asteroid.hpp`中声明 a `std::vector`如下:

    ```cpp
    #ifndef _PACKT_ASTEROID_HPP_
    #define _PACKT_ASTEROID_HPP_

    #include "GraphicsManager.hpp"
    #include "PhysicsManager.hpp"
    #include "TimeManager.hpp"
    #include "Types.hpp"

    #include <vector>

    class Asteroid {
    public:
        ...
        PhysicsManager& mPhysicsManager;

        std::vector<PhysicsBody*> mBodies;
        float mMinBound;
        float mUpperBound; float mLowerBound;
        float mLeftBound; float mRightBound;
    };
    #endif
    ```

13.  使用向量在`jni/Asteroid.cpp`中插入并迭代身体，如下面的代码所示:

    ```cpp
    #include "Asteroid.hpp"
    #include "Log.hpp"

    static const float BOUNDS_MARGIN = 128;
    static const float MIN_VELOCITY = 150.0f, VELOCITY_RANGE = 600.0f;

    Asteroid::Asteroid(android_app* pApplication,
            TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,
            PhysicsManager& pPhysicsManager) :
        mTimeManager(pTimeManager),
        mGraphicsManager(pGraphicsManager),
        mPhysicsManager(pPhysicsManager),
        mBodies(),
        mMinBound(0.0f),
        mUpperBound(0.0f), mLowerBound(0.0f),
        mLeftBound(0.0f), mRightBound(0.0f) {
    }

    void Asteroid::registerAsteroid(Location& pLocation,
            int32_t pSizeX, int32_t pSizeY) {
        mBodies.push_back(mPhysicsManager.loadBody(pLocation,
                pSizeX, pSizeY));
    }

    void Asteroid::initialize() {
        mMinBound = mGraphicsManager.getRenderHeight();
        mUpperBound = mMinBound * 2;
        mLowerBound = -BOUNDS_MARGIN;
        mLeftBound = -BOUNDS_MARGIN;
        mRightBound = (mGraphicsManager.getRenderWidth() + BOUNDS_MARGIN);

        std::vector<PhysicsBody*>::iterator bodyIt;
        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++ bodyIt) {
            spawn(*bodyIt);
        }
    }

    void Asteroid::update() {
        std::vector<PhysicsBody*>::iterator bodyIt;
        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++ bodyIt) {
            PhysicsBody* body = *bodyIt;
            if ((body->location->x < mLeftBound)
             || (body->location->x > mRightBound)
             || (body->location->y < mLowerBound)
             || (body->location->y > mUpperBound)) {
                spawn(body);
            }
        }
    }
    ...
    ```

## *刚刚发生了什么？*

在整个应用程序中一直使用 STL 容器来替换原始的 C 数组。例如，我们在一个 STL 容器向量中管理了一组`Asteroid`游戏对象，而不是一个原始的 C 数组。我们还用一个 STL 贴图容器替换了纹理缓存。STL 容器有很多优点，比如自动处理内存管理(数组大小调整操作等等)，来减轻我们的负担。

STL 绝对是一个巨大的改进，避免了重复和容易出错的代码。许多开源库都需要它，现在可以毫无困难地移植它。关于它的更多文档可以在 http://www.cplusplus.com/reference/stl 和 http://www.sgi.com/tech/stl 的 SGI 网站上找到。

当为了性能而开发时，标准的 STL 容器并不总是最好的选择，尤其是在内存管理和分配方面。事实上，STL 是一个通用的库，是为常见情况编写的。对于性能关键的代码，可以考虑替代库。以下是几个例子:

*   **EASTL** :这是一个由电子艺界开发的 STL 替代品，考虑到了游戏。一个摘录可以在[https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL)的存储库中找到。详细介绍 EASTL 技术细节的必读论文可在开放标准网站[http://www . Open-STD . org/JT C1/sc22/wg21/docs/papers/2007/n 2271 . html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html)上找到。
*   **Bitsquid 基础库**:这个是另一款 STL 替代瞄准游戏，可以在[https://bitbucket.org/bitsquid/foundation/](https://bitbucket.org/bitsquid/foundation/)找到。
*   **RDESTL** :这是STL 的开源子集，基于 EASTL 技术论文，在 EASTL 代码发布前几年发布。代码库可以在[http://code.google.com/p/rdestl/](http://code.google.com/p/rdestl/)找到。
*   **Google SparseHash** :这是针对高性能关联数组库的(注意 RDESTL 在这方面也相当擅长)。

这远非详尽无遗。只要明确你的确切需求，做出最合适的选择。

### 注

STL 仍然是大多数应用程序或库的最佳选择。在离开它之前，剖析你的源代码，并确保它确实是必要的。

# 将 Box2D 移植到安卓

有了篮子里的 STL，我们准备好将几乎任何库移植到安卓。事实上，许多第三方库已经被移植，更多的库即将到来。然而，当什么都没有的时候，你必须依靠我们自己的技能。

为了了解如何处理这种情况，我们现在要去 NDK 港 Box2D。Box2D 是由 Erin Catto 在 2006 年发起的一个非常受欢迎的物理模拟引擎。许多 2D 游戏，无论是业余的还是专业的，比如愤怒的小鸟，都嵌入了这个强大的开源库。它有几种语言版本，包括 Java，尽管它的主要语言是 C++。

Box2D 是对复杂课题的回答，也就是物理模拟。数学、数值积分、软件优化等是用于模拟 2D 环境中刚体运动和碰撞的多种技术中的一些。身体是 Box2D 的基本元素，其特征如下:

*   几何形状**(多边形、圆形等)**
***   物理属性(如**密度**、**摩擦**、**恢复原状**等)*   运动**约束**和**关节**(将身体连接在一起并限制它们的运动)**

 **所有这些身体都被安排在一个根据时间进行模拟的*世界*中。

现在，您已经了解了 Box2D 的基础知识，让我们将其移植并集成到 DroidBlaster 中，以模拟碰撞。

### 注

产生的项目为名下的本书。

# 行动时间——在安卓上编译 Box2D

首先，让我们按照以下步骤在安卓 NDK 上移植 Box2D:

Box2D 2.3.1 档案在目录`Libraries/box2d`中提供了这本书。

1.  Unzip Box2D source archive (2.3.1 in this book) into `${ANDROID_NDK}/sources/` (beware directory must be named `box2d`).

    在`box2d`目录的根目录下创建并打开一个`Android.mk`文件。

    首先，将当前目录保存在`LOCAL_PATH`变量中。这一步总是必要的，因为 NDK 构建系统在编译期间随时可能切换到另一个目录。

2.  之后，列出所有要编译的 Box2D 源文件，如下图所示。我们只对源文件名感兴趣，可以在`${ANDROID_NDK}/sources/box2d/Box2D/Box2D`找到。使用`LS_CPP`助手功能避免复制每个文件名。

    ```cpp
    LOCAL_PATH:= $(call my-dir)

    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/$(2)/*.cpp))

    BOX2D_CPP:= $(call LS_CPP,$(LOCAL_PATH),Box2D/Collision) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Collision/Shapes) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Common) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics/Contacts) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics/Joints) \
                $(call LS_CPP,$(LOCAL_PATH),Box2D/Rope)
    ...
    ```

3.  Then, write the Box2D module definition for a static library. First, call the `$(CLEAR_VARS)` script. This script has to be included before any module definition to remove any potential change made by other modules, and to avoid any unwanted side effects. Then, define the following settings:
    *   `LOCAL_MODULE`中的模块名称:模块名称以 _static 为后缀，以避免与我们后面要定义的共享版本发生名称冲突。
    *   `LOCAL_SRC_FILES`中的模块源文件(使用之前定义的`BOX2D_CPP`)。
    *   在`LOCAL_EXPORT_C_INCLUDES`中导出到客户端模块的头文件目录。
    *   头文件内部用于`LOCAL_C_INCLUDES`中的模块编译。这里，用于 Box2D 编译的头和客户端模块所需的头是相同的(并且在其他库中通常也是相同的)。所以，重复使用`LOCAL_EXPORT_C_INCLUDES`，如前所述，按照以下方式:

        ```cpp
        ...
        include $(CLEAR_VARS)

        LOCAL_MODULE:= box2d_static
        LOCAL_SRC_FILES:= $(BOX2D_CPP)
        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)
        LOCAL_C_INCLUDES := $(LOCAL_EXPORT_C_INCLUDES)
        ...
        Finally, request Box2D module compilation as a static library as follows:
        ...
        include $(BUILD_STATIC_LIBRARY)
        ...
        Optionally, the same process can be repeated to build a shared version of the same library by selecting a different module name and invoking $(BUILD_SHARED_LIBRARY) instead, as shown in the following:
        ...
        include $(CLEAR_VARS)

        LOCAL_MODULE:= box2d_shared
        LOCAL_SRC_FILES:= $(BOX2D_CPP)
        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)
        LOCAL_C_INCLUDES := $(LOCAL_EXPORT_C_INCLUDES)

        include $(BUILD_SHARED_LIBRARY)

        ```

    ### 注

    `Libraries/box2d`目录中提供了`Android.mk` 档案。

4.  打开 DroidBlaster `Android.mk`并通过将其附加到`LOCAL_STATIC_LIBRARIES`来链接到`box2d_static`。指出哪个`Android.mk`模块文件包含在`import-module`指令中。请记住，模块是通过`NDK_MODULE_PATH`变量找到的，该变量默认指向`${ANDROID_NDK}/sources`，如下图所示:

    ```cpp
    LOCAL_PATH := $(call my-dir)

    include $(CLEAR_VARS)

    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))
    LOCAL_MODULE    := droidblaster
    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))
    LOCAL_LDLIBS    := -landroid -llog -lEGL -lGLESv1_CM -lOpenSLES

    LOCAL_STATIC_LIBRARIES:=android_native_app_glue png \
                            box2d_static

    include $(BUILD_SHARED_LIBRARY)

    $(call import-module,android/native_app_glue)
    $(call import-module,libpng)
    $(call import-module,box2d)
    ```

或者，如果您看到关于 Box2D 包含文件的警告，请在 Eclipse 中激活包含文件分辨率。为此，在 Eclipse **项目属性**中，导航到**C/c++ 常规/路径和符号**部分，然后导航到**包含**选项卡，并添加 Box2d 目录`${env_var:ANDROID_NDK}/sources/box2d`。

## *刚刚发生了什么？*

启动 DroidBlaster 编译。Box2D 编译无误。多亏了 NDK，我们已经将我们的第二个开源库(在`libpng`之后)移植到了安卓系统上！我们终于可以重用社区已经创建的许多轮子中的一个了！将原生库移植到安卓系统主要包括编写一个`Android.mk`模块 makefile 来描述源文件、依赖项、编译标志等等，就像我们到目前为止对主模块 DroidBlaster 所做的那样。

我们已经看到了在模块中使用的一些最重要的变量，它们如下:

*   `LOCAL_MODULE`:这声明了一个唯一的模块名，最终的库名取决于它的值
*   `LOCAL_SRC_FILES`:列出所有相对于模块根目录要编译的文件
*   `LOCAL_C_INCLUDES`:定义`include`文件目录
*   `LOCAL_EXPORT_C_INCLUDES`:这定义了`include`文件目录，但这次包括模块

Box2D 模块构建的顺序由以下指令之一给出:

*   `BUILD_STATIC_LIBRARY`:这将模块编译为静态库
*   `BUILD_SHARED_LIBRARY`:这次也编译了模块，但是作为共享库

一个模块可以像 STL 一样被编译成一个静态的或者共享的库。每次客户端应用程序导入模块或更改其编译设置时，都会动态执行编译(即按需)。希望 NDK 能够逐步编译源代码。

### 类型

要为仅头库创建模块，例如 Boost 或 GLM 的部分(用于 OpenGL ES 矩阵计算的库)，请定义一个未定义`LOCAL_SRC_FILES`的模块。只有`LOCAL_MODULE`和`LOCAL_EXPORT_C_INCLUDES`是必须的。

从客户端`Android.mk`的角度来看(在我们的例子中是`the DroidBlaster` makefile)，NDK `import-module`指令触发的，大致来说，包括子模块`Android.mk` 文件。没有它，NDK 将无法发现依赖模块，编译它们，并包括它们的头。所有模块，主模块和子模块都在`<PROJECT_DIR>/libs`生产，中间二进制文件在主应用模块的`<PROJECT_DIR>/obj`中。

### 类型

`import-module` 指令应该位于文件的末尾，以避免改变模块定义。

以下是链接主`Android.mk` Makefile 中“子模块”库的三种方式:

*   静态库必须列在`LOCAL_STATIC_LIBRARIES`变量中(就像我们对 Box2D 所做的那样)
*   共享库需要在`LOCAL_SHARED_LIBRARIES`变量中列出
*   共享系统库应该在`LOCAL_LDLIBS`中列出(比如我们已经为 OpenGL ES 做的)

有关 Makefiles 的更多信息，请参见*主控模块 Makefiles* 部分。

编写 Makefile 是移植过程的一个重要部分。然而，这并不总是足够的。移植库可能会稍微复杂一些，这取决于它的原始平台。例如，一段已经移植到 iOS 的代码通常更容易移植到安卓。在更复杂的情况下，可能有必要修补代码，使其在安卓系统上正常运行。当你注定要完成这样一项艰巨而又非琐碎的任务时，老实说，这是相当频繁的，请始终考虑以下几点:

*   请确保所需的库存在，如果不存在，请先移植它们。
*   如果您的库提供了主配置头文件，请查找主配置头文件(因为这是经常发生的情况)。这是调整已启用或已禁用功能、移除不需要的依赖项或定义新宏的好地方。
*   关注系统相关的宏(即`#ifdef _LINUX`...)，这是在代码中寻找要进行的更改的第一批地方之一。通常，需要定义宏，如`_ANDROID_`，并在适当的地方插入它们。
*   评论非必要的代码，检查库是否可以编译，以及它的核心功能是否可以工作。事实上，如果你还不确定它是否会起作用，就不要费心去解决所有问题。

希望 Box2D 不要太拘泥于特定的平台，因为它主要依赖纯 C/C++ 计算，而不是外部 API。在这种情况下，移植代码变得容易得多。既然 Box2D 已经编译好了，让我们用自己的代码运行它。

# 行动时间-运行 Box2D 物理引擎

让我们用 Box2D 重写 DroidBlaster 物理引擎，步骤如下:

1.  Open the `jni/PhysicsManager.hpp` header and insert the Box2D `include` file.

    定义一个常数`PHYSICS_SCALE`将身体位置从物理转换为游戏坐标。事实上，Box2D 使用自己的比例来提高精度。

    然后，用新的结构`PhysicsCollision`替换`PhysicsBody`，这将指示哪些物体进入碰撞，如下所示:

    ```cpp
    #ifndef PACKT_PHYSICSMANAGER_HPP
    #define PACKT_PHYSICSMANAGER_HPP

    #include "GraphicsManager.hpp"
    #include "TimeManager.hpp"
    #include "Types.hpp"

    #include <Box2D/Box2D.h>
    #include <vector>

    #define PHYSICS_SCALE 32.0f

    struct PhysicsCollision {
        bool collide;

        PhysicsCollision():
            collide(false)
        {}
    };
    ...
    ```

2.  Then, make `PhysicsManager` inherit from `b2ContactListener`. A contact listener gets notified about new collisions each time the simulation is updated. Our `PhysicsManager` inherits one of its method's named `BeginContact()`, used to react to collisions.

    我们还需要三种方法，如下所示:

    *   `loadBody()`在物理引擎内创建一个新实体
    *   `loadTarget()`创造一个向目标(我们的宇宙飞船)移动的实体
    *   `start()`游戏开始时初始化引擎

    另外，定义成员变量，如下所示:

    *   `mWorld`代表整个 Box2D 模拟，其中包含我们要创建的所有实体
    *   `mBodies`是我们注册的所有物理实体的列表
    *   `mLocations`包含游戏坐标中`b2Body`位置的副本(而不是具有不同比例的物理坐标)
    *   `mBoundsBodyObj`定义了我们的宇宙飞船能够移动的边界

        ```cpp
        ...
        class PhysicsManager : private b2ContactListener {
        public:
            PhysicsManager(TimeManager& pTimeManager,
                    GraphicsManager& pGraphicsManager);
            ~PhysicsManager();

            b2Body* loadBody(Location& pLocation, uint16 pCategory,
                uint16 pMask, int32_t pSizeX, int32_t pSizeY,
                float pRestitution);
            b2MouseJoint* loadTarget(b2Body* pBodyObj);
            void start();
            void update();

        private:
            PhysicsManager(const PhysicsManager&);
            void operator=(const PhysicsManager&);

            void BeginContact(b2Contact* pContact);

            TimeManager& mTimeManager;
            GraphicsManager& mGraphicsManager;

            b2World mWorld;
            std::vector<b2Body*> mBodies;
            std::vector<Location*> mLocations;
            b2Body* mBoundsBodyObj;
        };
        #endif
        ```

3.  Implement `jni/PhysicsManager.cpp`.

    迭代常数决定了模拟精度。这里，Box2D 将主要处理碰撞和简单的运动。因此，将速度和位置迭代分别固定到`6`和`2`就足够了(稍后再详细讨论它们的含义)。

    初始化新的`PhysicsManager`成员，让其在`mWorld`对象上监听与`SetContactListener()`的碰撞事件，如下图所示:

    ```cpp
    #include "PhysicsManager.hpp"
    #include "Log.hpp"

    static const int32_t VELOCITY_ITER = 6;
    static const int32_t POSITION_ITER = 2;

    PhysicsManager::PhysicsManager(TimeManager& pTimeManager,
            GraphicsManager& pGraphicsManager) :
      mTimeManager(pTimeManager), mGraphicsManager(pGraphicsManager),
      mWorld(b2Vec2_zero), mBodies(),
      mLocations(),
      mBoundsBodyObj(NULL) {
        Log::info("Creating PhysicsManager.");
        mWorld.SetContactListener(this);
    }

    PhysicsManager::~PhysicsManager() {
        std::vector<b2Body*>::iterator bodyIt;
        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++ bodyIt) {
            delete (PhysicsCollision*) (*bodyIt)->GetUserData();
        }
    }
    ...
    ```

4.  游戏开始时初始化 Box2D 世界边界。这些边界与转换成*物理系统坐标*的显示窗口大小相匹配。事实上，物理系统使用自己预先定义的比例来保持浮点值的准确性。我们需要四条边来定义这些边界，如下图所示:

    ```cpp
    ...
    void PhysicsManager::start() {
        if (mBoundsBodyObj == NULL) {
            b2BodyDef boundsBodyDef;
            b2ChainShape boundsShapeDef;
            float renderWidth = mGraphicsManager.getRenderWidth()
                                    / PHYSICS_SCALE;
            float renderHeight = mGraphicsManager.getRenderHeight()
                                    / PHYSICS_SCALE;
            b2Vec2 boundaries[4];
            boundaries[0].Set(0.0f, 0.0f);
            boundaries[1].Set(renderWidth, 0.0f);
            boundaries[2].Set(renderWidth, renderHeight);
            boundaries[3].Set(0.0f, renderHeight);
            boundsShapeDef.CreateLoop(boundaries, 4);

            mBoundsBodyObj = mWorld.CreateBody(&boundsBodyDef);
            mBoundsBodyObj->CreateFixture(&boundsShapeDef, 0);
        }
    }
    ```

5.  Initialize and register asteroid or ship physics bodies in `loadBody()`.

    身体定义描述了一个动态的身体(与静态相反)，清醒的(也就是说，由 Box2D 主动模拟的)，并且不能旋转(这个属性对于多边形形状特别重要，意味着它总是指向上方)。

    还要注意我们如何在`userData`字段中保存`PhysicsCollision`自引用，以便稍后在 Box2D 回调中访问它。

    定义体型，我们近似为一个圆。请注意，Box2D 需要从对象的中心到其边框的一半尺寸，如以下代码片段所示:

    ```cpp
    b2Body* PhysicsManager::loadBody(Location& pLocation,
            uint16 pCategory, uint16 pMask, int32_t pSizeX, int32_t pSizeY,
            float pRestitution) {
        PhysicsCollision* userData = new PhysicsCollision();

        b2BodyDef mBodyDef;
        b2Body* mBodyObj;
        b2CircleShape mShapeDef; b2FixtureDef mFixtureDef;

        mBodyDef.type = b2_dynamicBody;
        mBodyDef.userData = userData;
        mBodyDef.awake = true;
        mBodyDef.fixedRotation = true;

        mShapeDef.m_p = b2Vec2_zero;
        int32_t diameter = (pSizeX + pSizeY) / 2;
        mShapeDef.m_radius = diameter / (2.0f * PHYSICS_SCALE);
        ...
    ```

6.  Body fixture is the "glue" that ties together body definition, shape, and physical properties. We also use it to set the body's category and mask, and to filter collisions between objects (for instance, asteroids can collide with the ship but not between themselves in DroidBlaster). One bit represents one category.

    最后，在 Box2D 物理世界中有效地实例化您的`body`，如以下代码所示:

    ```cpp
        ...
        mFixtureDef.shape = &mShapeDef;
        mFixtureDef.density = 1.0f;
        mFixtureDef.friction = 0.0f;
        mFixtureDef.restitution = pRestitution;
        mFixtureDef.filter.categoryBits = pCategory;
        mFixtureDef.filter.maskBits = pMask;
        mFixtureDef.userData = userData;

        mBodyObj = mWorld.CreateBody(&mBodyDef);
        mBodyObj->CreateFixture(&mFixtureDef);
        mBodyObj->SetUserData(userData);
        mLocations.push_back(&pLocation);
        mBodies.push_back(mBodyObj);
        return mBodyObj;
    }
    ...
    ```

7.  实现`loadTarget()`方法，创建一个 Box2D 鼠标关节来模拟飞船运动。这样的`Joint`定义了一个空的目标，物体(这里在参数中指定)朝着这个目标移动，就像一种弹性。这里使用的设置(`maxForce`、`dampingRatio`和`frequencyHz`)控制船只的反应，可以通过调整它们来确定，如以下代码所示:

    ```cpp
    ...
    b2MouseJoint* PhysicsManager::loadTarget(b2Body* pBody) {
        b2BodyDef emptyBodyDef;
        b2Body* emptyBody = mWorld.CreateBody(&emptyBodyDef);

        b2MouseJointDef mouseJointDef;
        mouseJointDef.bodyA = emptyBody;
        mouseJointDef.bodyB = pBody;
        mouseJointDef.target = b2Vec2(0.0f, 0.0f);
        mouseJointDef.maxForce = 50.0f * pBody->GetMass();
        mouseJointDef.dampingRatio = 0.15f;
        mouseJointDef.frequencyHz = 3.5f;

        return (b2MouseJoint*) mWorld.CreateJoint(&mouseJointDef);
    }
    ...
    ```

8.  写出`update()`方法。
    *   首先，清除上一次迭代期间在`BeginContact()`中缓冲的任何冲突标志。
    *   然后，通过调用`Step()`进行模拟。时间段指定必须模拟多少时间。迭代常数决定模拟精度。
    *   最后，在所有的物理体上循环提取它们的坐标，将它们从 Box2D 转换成游戏坐标，并将结果存储到我们自己的`Location`对象中，如下面的代码所示:

        ```cpp
        ...
        void PhysicsManager::update() {
            // Clears collision flags.
            int32_t size = mBodies.size();
            for (int32_t i = 0; i < size; ++ i) {
                PhysicsCollision* physicsCollision =
                       ((PhysicsCollision*) mBodies[i]->GetUserData());
                physicsCollision->collide = false;
            }
            // Updates simulation.
            float timeStep = mTimeManager.elapsed();
            mWorld.Step(timeStep, VELOCITY_ITER, POSITION_ITER);

            // Caches the new state.
            for (int32_t i = 0; i < size; ++ i) {
                const b2Vec2& position = mBodies[i]->GetPosition();
                mLocations[i]->x = position.x * PHYSICS_SCALE;
                mLocations[i]->y = position.y * PHYSICS_SCALE;
            }
        }
        ...
        ```

9.  用`b2ContactListener`继承的`BeginContact()`方法结束。该回调通知物体之间新的碰撞，一次两个(命名为`A`和`B`)。事件信息存储在一个`b2contact`结构中，该结构包含各种属性，例如摩擦力、恢复力和两个物体，通过它们的固定装置参与。这些夹具本身包含了对我们自己的`PhysicsCollision`的引用。当 Box2D 检测到一个触点时，我们可以使用以下链接切换`PhysicsCollision` 碰撞标志:

    ```cpp
    ...
    void PhysicsManager::BeginContact(b2Contact* pContact) {
        void* userDataA = pContact->GetFixtureA()->GetUserData();
        void* userDataB = pContact->GetFixtureB()->GetUserData();
        if (userDataA != NULL && userDataB != NULL) {
            ((PhysicsCollision*)userDataA)->collide = true;
            ((PhysicsCollision*)userDataB)->collide = true;
        }
    }
    ```

10.  在`jni/Asteroid.hpp`中，将`PhysicsBody`的用法替换为 Box2D `b2Body`结构，如下代码所示:

    ```cpp
    ...
    class Asteroid {
        ...
    private:
        void spawn(b2Body* pBody);

        TimeManager& mTimeManager;
        GraphicsManager& mGraphicsManager;
        PhysicsManager& mPhysicsManager;

        std::vector<b2Body*> mBodies;
        float mMinBound;
        float mUpperBound; float mLowerBound;
        float mLeftBound; float mRightBound;
    };
    #endif
    ```

11.  在`jni/Asteroid.cpp`中，物理坐标系的比例常数和边界:

    ```cpp
    #include "Asteroid.hpp"
    #include "Log.hpp"

    static const float BOUNDS_MARGIN = 128 / PHYSICS_SCALE;
    static const float MIN_VELOCITY = 150.0f / PHYSICS_SCALE;
    static const float VELOCITY_RANGE = 600.0f / PHYSICS_SCALE;

    ...
    void Asteroid::initialize() {
        mMinBound = mGraphicsManager.getRenderHeight() / PHYSICS_SCALE;
        mUpperBound = mMinBound * 2;
        mLowerBound = -BOUNDS_MARGIN;
        mLeftBound = -BOUNDS_MARGIN;
        mRightBound = (mGraphicsManager.getRenderWidth() / PHYSICS_SCALE)
                          + BOUNDS_MARGIN;

        std::vector<b2Body*>::iterator bodyIt;
        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++ bodyIt) {
            spawn(*bodyIt);
        }
    }
    ...
    ```

12.  Then, update the way an asteroid body is registered. Register physics properties with a category and mask. Here, asteroids are declared as belonging to category 1 (`0X1` in hexadecimal notation), and only bodies in group 2 (`0X2` in hexadecimal) are considered when evaluating collisions:

    ```cpp
    ...
    void Asteroid::registerAsteroid(Location& pLocation,
            int32_t pSizeX, int32_t pSizeY) {
        mBodies.push_back(mPhysicsManager.loadBody(pLocation,
                0X1, 0x2, pSizeX, pSizeY, 2.0f));
    }
    ...
    ```

    替换并更新剩余的代码，以适应新的`b2Body`结构而不是`PhysicsBody`结构的使用:

    ```cpp
    ...
    void Asteroid::update() {
        std::vector<b2Body*>::iterator bodyIt;
        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++ bodyIt) {
            b2Body* body = *bodyIt;
            if ((body->GetPosition().x < mLeftBound)
             || (body->GetPosition().x > mRightBound)
             || (body->GetPosition().y < mLowerBound)
             || (body->GetPosition().y > mUpperBound)) {
                spawn(body);
            }
        }
    }
    ...
    ```

13.  最后，还要更新`spawn()`代码来初始化`PhysicsBody`，如下图所示:

    ```cpp
    ...
    void Asteroid::spawn(b2Body* pBody) {
        float velocity = -(RAND(VELOCITY_RANGE) + MIN_VELOCITY);
        float posX = mLeftBound + RAND(mRightBound - mLeftBound);
        float posY = mMinBound + RAND(mUpperBound - mMinBound);
        pBody->SetTransform(b2Vec2(posX, posY), 0.0f);
        pBody->SetLinearVelocity(b2Vec2(0.0f, velocity));
    }
    ```

14.  Open `jni/Ship.hpp` to turn it into a Box2D body.

    在`registerShip()`方法中增加一个新的`b2Body`参数。

    然后，定义以下两种附加方法:

    *   `update()`，里面包含了一些新的游戏逻辑，在飞船与小行星碰撞时摧毁飞船
    *   `isDestroyed()`表示该船是否已被摧毁

    声明以下必要变量:

    *   `mBody`管理 Box2D 中的船舶表示
    *   `mDestroyed`和`mLives`为游戏逻辑

        ```cpp
        ...
        #include "GraphicsManager.hpp"
        #include "PhysicsManager.hpp"
        #include "SoundManager.hpp"
        ...

        class Ship {
        public:
            Ship(android_app* pApplication,
                 GraphicsManager& pGraphicsManager,
                 SoundManager& pSoundManager);

            void registerShip(Sprite* pGraphics, Sound* pCollisionSound,
         b2Body* pBody);

            void initialize();
            void update();

            bool isDestroyed() { return mDestroyed; }

        private:
            GraphicsManager& mGraphicsManager;
            SoundManager& mSoundManager;
            Sprite* mGraphics;
            Sound* mCollisionSound;
            b2Body* mBody;
            bool mDestroyed; int32_t mLives;
        };
        #endif
        ```

15.  Declare a few new constants in `jni/Ship.cpp`.

    然后，正确初始化新的成员变量。注意`initialize()`中不再需要播放碰撞声:

    ```cpp
    #include "Log.hpp"
    #include "Ship.hpp"

    static const float INITAL_X = 0.5f;
    static const float INITAL_Y = 0.25f;
    static const int32_t DEFAULT_LIVES = 10;

    static const int32_t SHIP_DESTROY_FRAME_1 = 8;
    static const int32_t SHIP_DESTROY_FRAME_COUNT = 9;
    static const float SHIP_DESTROY_ANIM_SPEED = 12.0f;

    Ship::Ship(android_app* pApplication,
            GraphicsManager& pGraphicsManager,
            SoundManager& pSoundManager) :
      mGraphicsManager(pGraphicsManager),
      mGraphics(NULL),
      mSoundManager(pSoundManager),
      mCollisionSound(NULL),
      mBody(NULL),
      mDestroyed(false), mLives(0) {
    }

    void Ship::registerShip(Sprite* pGraphics, Sound* pCollisionSound,
                            b2Body* pBody) {
        mGraphics = pGraphics;
        mCollisionSound = pCollisionSound;
        mBody = pBody;
    }

    void Ship::initialize() {
        mDestroyed = false;
     mLives = DEFAULT_LIVES;

        b2Vec2 position(
           mGraphicsManager.getRenderWidth() * INITAL_X / PHYSICS_SCALE,
           mGraphicsManager.getRenderHeight() * INITAL_Y / PHYSICS_SCALE);
        mBody->SetTransform(position, 0.0f);
        mBody->SetActive(true);
    }
    ...
    ```

16.  In `update()`, check if the ship body has collided with an asteroid. To do so, check the `PhysicsCollision` structure stored in the ship `b2Body` custom user data. Remember that its content is set in the `PhysicsManager::BeginContact()` method

    当船碰撞时，我们可以减少它的寿命，播放碰撞声。

    如果它没有更多的生命，我们可以开始播放一个毁灭动画。当这种情况发生时，身体应该是不活动的，以避免与小行星进一步碰撞。

    当飞船被完全摧毁后，我们可以保存它的状态以便游戏循环可以适当的行动，如下代码所示:

    ```cpp
    ...
    void Ship::update() {
        if (mLives >= 0) {
            if (((PhysicsCollision*) mBody->GetUserData())->collide) {
                mSoundManager.playSound(mCollisionSound);
                --mLives;
                if (mLives < 0) {
                    Log::info("Ship has been destroyed");
                    mGraphics->setAnimation(SHIP_DESTROY_FRAME_1,
                        SHIP_DESTROY_FRAME_COUNT, SHIP_DESTROY_ANIM_SPEED,
                        false);
                    mBody->SetActive(false);
                } else {
                    Log::info("Ship collided");
                }
            }
        }
        // Destroyed.
        else {
            if (mGraphics->animationEnded()) {
                mDestroyed = true;
            }
        }
    }
    ```

17.  Update the `jni/MoveableBody.hpp` component so that it returns a `b2Body` structure in `registerMoveableBody()`.

    增加以下两个新成员:

    *   `mBody`为物理体
    *   `mTarget`为小鼠关节:

        ```cpp
        #ifndef _PACKT_MOVEABLEBODY_HPP_
        #define _PACKT_MOVEABLEBODY_HPP_

        #include "InputManager.hpp"
        #include "PhysicsManager.hpp"
        #include "Types.hpp"

        class MoveableBody {
        public:
            MoveableBody(android_app* pApplication,
               InputManager& pInputManager, PhysicsManager& pPhysicsManager);

            b2Body* registerMoveableBody(Location& pLocation,
                    int32_t pSizeX, int32_t pSizeY);

            void initialize();
            void update();

        private:
            PhysicsManager& mPhysicsManager;
            InputManager& mInputManager;

            b2Body* mBody;
            b2MouseJoint* mTarget;
        };
        #endif
        ```

18.  使`jni/MoveableBody.cpp`常量适应新的刻度，并在构造函数中初始化新成员:

    ```cpp
    #include "Log.hpp"
    #include "MoveableBody.hpp"

    static const float MOVE_SPEED = 10.0f / PHYSICS_SCALE;

    MoveableBody::MoveableBody(android_app* pApplication,
          InputManager& pInputManager, PhysicsManager& pPhysicsManager) :
      mInputManager(pInputManager),
      mPhysicsManager(pPhysicsManager),
      mBody(NULL), mTarget(NULL) {
    }

    b2Body* MoveableBody::registerMoveableBody(Location& pLocation,
            int32_t pSizeX, int32_t pSizeY) {
        mBody = mPhysicsManager.loadBody(pLocation, 0x2, 0x1, pSizeX,
                pSizeY, 0.0f);
        mTarget = mPhysicsManager.loadTarget(mBody);
        mInputManager.setRefPoint(&pLocation);
        return mBody;
    }
    ...
    ```

19.  然后，设置并更新`physicsbody`，使其跟随船只的目标。目标根据用户输入移动，如下图所示:

    ```cpp
    ...
    void MoveableBody::initialize() {
        mBody->SetLinearVelocity(b2Vec2(0.0f, 0.0f));
    }

    void MoveableBody::update() {
        b2Vec2 target = mBody->GetPosition() + b2Vec2(
            mInputManager.getDirectionX() * MOVE_SPEED,
            mInputManager.getDirectionY() * MOVE_SPEED);
        mTarget->SetTarget(target);
    }
    ```

20.  最后，编辑`jni/DroidBlaster.cpp`并更改船舶登记代码以适应新的变化，如下代码所示:

    ```cpp
    ...

    DroidBlaster::DroidBlaster(android_app* pApplication):
        ... {
        Log::info("Creating DroidBlaster");

        Sprite* shipGraphics = mSpriteBatch.registerSprite(mShipTexture,
                SHIP_SIZE, SHIP_SIZE);
        shipGraphics->setAnimation(SHIP_FRAME_1, SHIP_FRAME_COUNT,
                SHIP_ANIM_SPEED, true);
        Sound* collisionSound =
                mSoundManager.registerSound(mCollisionSound);
        b2Body* shipBody = mMoveableBody.registerMoveableBody(
                shipGraphics->location, SHIP_SIZE, SHIP_SIZE);
        mShip.registerShip(shipGraphics, collisionSound, shipBody);

        // Creates asteroids.
        ...
    }
    ...
    ```

21.  别忘了在`onActivate()`中启动`PhysicsManager`，如下码所示:

    ```cpp
    ...
    status DroidBlaster::onActivate() {
        Log::info("Activating DroidBlaster");
        // Starts managers.
        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;
        if (mSoundManager.start() != STATUS_OK) return STATUS_KO;
        mInputManager.start();
        mPhysicsManager.start();

        ...
    }
    ...
    ```

22.  通过在`onStep()`中更新和检查船舶状态来终止。当它被破坏后，退出游戏循环如下:

    ```cpp
    ...
    status DroidBlaster::onStep() {
        mTimeManager.update();
        mPhysicsManager.update();

        // Updates modules.
        mAsteroids.update();
        mMoveableBody.update();
        mShip.update();

        if (mShip.isDestroyed()) return STATUS_EXIT;
        return mGraphicsManager.update();
    }
    ...
    ```

## *刚刚发生了什么？*

我们使用 Box2D 物理引擎创建了一个物理模拟。更具体地说，我们已经看到了如何做到以下几点:

*   创建一个 Box2D 世界来描述物理模拟
*   定义实体(船只和小行星)的物理表示
*   模拟
*   过滤并检测实体之间的冲突
*   提取模拟状态(即坐标)以提供图形表示

Box2D 使用自己的分配器来优化内存管理。因此，要创建和销毁 Box2D 对象，需要系统地使用提供的工厂方法(`CreateX()`、`DestroyX()`)。大多数时候，Box2D 会自动为你管理内存。当一个物体被摧毁时，所有相关的*子物体*都会被摧毁(例如，当世界被摧毁时，身体也会被摧毁)。但是，如果你需要更早地处理掉你的物品，也就是手动处理，那么一定要销毁尸体。

Box2D 是一段复杂的代码，很难正确调整。让我们更深入地探讨一下它的世界是如何描述的，以及如何处理碰撞。

## 潜入 Box2D 世界

Box2D 中访问的中心点是`b2World`对象，它存储了要模拟的物理实体的集合。Box2D 车身由以下部件组成:

*   `b2BodyDef`:这个定义了体型(`b2_staticBody, b2_dynamicBody`等等)和初始属性，比如它的位置、角度(以弧度为单位)等等。
*   `b2Shape`:用于碰撞检测，并从其密度中导出体重。可以是`b2PolygonShape`、`b2CircleShape`等等。
*   `b2FixtureDef`:这个把一个体型，一个体型定义，以及它的物理属性，比如密度联系在一起。
*   `b2Body`:这是世界上的一个身体实例(也就是每个游戏对象一个)。它是根据实体定义、形状和夹具创建的。

身体的特点是有一些物理属性，如下所示:

*   **形状**:这代表了 DroidBlaster 中的一个圆，不过也可以使用多边形或长方体。
*   **密度**:这是表示的千克/平方米，根据其形状和大小计算体重。值应大于或等于`0.0`。保龄球的密度比足球大。
*   **摩擦力**:这个表示一个物体在另一个物体上滑动的程度(例如，道路上或结冰的道路上的汽车)。数值通常在`0.0` 到`1.0`之间，其中`0.0`表示无摩擦，`1.0`表示强摩擦。
*   **恢复原状**:这表示物体对碰撞的反应程度，例如一个弹跳的球。值`0.0`表示不恢复原状， `1.0`表示完全恢复原状。

跑步时，身体会受到以下因素的影响:

*   **力**:这使得物体直线运动。
*   **扭矩**:代表施加在物体上的旋转力。
*   **阻尼**:这类似于摩擦，虽然它不仅仅发生在一个物体与另一个物体接触的时候。把它看作是阻力使物体减速的效果。

Box2D 针对包含从`0.1`到`10`(单位:米)的对象的世界进行了调整。当在这个范围之外使用时，数值近似会使模拟不准确。因此，非常有必要从 Box2D 参照(物体应保持在(粗略)范围内[ `0.1`，`10`)和游戏或直接到图形参照来缩放坐标。这就是为什么我们定义了`SCALE_FACTOR`来缩放坐标变换。

## 关于碰撞检测的更多信息

在 Box2D 中有几种检测和处理碰撞的方法。最基本的一个包括在更新后，检查所有存储在世界或体内的联系人。然而，这可能会导致在 Box2D 内部迭代过程中秘密发生的遗漏接触。

我们见过的更好的检测接触的方法是`b2ContactListener`，可以在世界对象上注册。可以覆盖以下四个回调:

*   `BeginContact (b2Contact)`:检测两个物体碰撞进入的时间。
*   `EndContact(b2Contact)`:这是`BeginContact()`的对应物，表示物体不再碰撞的时间。打给`BeginContact()`的电话后面总是跟着一个匹配的`EndContact()`。
*   `PreSolve (b2Contact, b2Manifold)`:在检测到碰撞之后，但在碰撞解决之前，即在计算碰撞产生的冲量之前，调用这个函数。`b2Manifold`结构将接触点、法线等信息保存在一个地方。
*   `PostSolve(b2Contact, b2ContactImpulse)`:这是在实际冲量(即物理反应)已经被 Box2D 计算出来之后调用的。

前两个回调对于触发游戏逻辑很有意思(例如，实体破坏)。最后两个有趣的是在计算物理模拟时改变物理模拟(更具体地说，通过*禁用*接触来忽略一些碰撞)，或者获得关于它的更精确的细节。例如，使用`PreSolve()`创建一个单侧平台，实体只有从上方落下时才会与之碰撞(而不是从下方跳下时)。使用`PostSolve()`检测碰撞强度，并据此计算损害。

`PreSolve()`和`PostSolve()`方法在`BeginContact()`和T3 之间可以调用几次，在一次世界更新中可以从零到多次调用自己。接触可以在一个模拟步骤中开始，在几个步骤后终止。在这种情况下，事件解决回调在“中间”步骤中连续发生。因为步进模拟时会发生许多碰撞。因此，回调可以被调用很多次，并且应该尽可能高效。

当在`BeginContact()`回调中分析冲突时，我们缓冲了一个冲突标志。这是必要的，因为 Box2D 会重用在触发回调时传递的`b2Contact`参数。此外，由于这些回调是在计算模拟时调用的，因此只有在模拟步进结束后，物理体才能在那一刻被破坏。因此，强烈建议复制为`postprocessing`收集的任何信息(例如，销毁实体)。

## 碰撞模式和过滤

我想指出的是 Box2D 提供了一种所谓的`bullet`模式，可以使用相应的布尔成员在身体定义上激活:

```cpp
mBodyDef.bullet = true;
```

子弹模式对于像子弹这样快速移动的物体是必须的！默认情况下，Box2D 使用**离散碰撞检测**，该检测将处于最终位置的物体视为碰撞检测，不包括位于初始位置和最终位置之间的任何物体。但是，对于快速移动的物体，应该考虑所遵循的整个路径。这个更正式的叫**连续碰撞检测** ( **CCD** )。显然，电荷耦合器件很贵，应该节俭使用。请参考下图:

![Collision modes and filtering](graphics/9645_09_02.jpg)

我们有时希望在不产生碰撞的情况下检测身体何时重叠(就像汽车到达终点线):这被称为传感器。通过将夹具中的`isSensor`布尔构件设置为`true`，可以轻松设置传感器，如下所示:

```cpp
mFixtureDef.isSensor = true;
```

听众可以通过`BeginContact()`和`EndContact()`或使用`b2Contact`类上的`IsTouching()`快捷方式来查询传感器。

碰撞的另一个重要方面是不碰撞，或者更准确地说，过滤碰撞。通过禁用触点，可以在`PreSolve()`中执行一种过滤。这是最灵活、最强大的解决方案，也是最复杂的。

但是，正如我们所看到的，通过使用类别和掩码技术，可以以更简单的方式执行过滤。每个主体被分配一个或多个类别(每个类别由短整数中的一个位表示，`categoryBits`成员)和描述它们可以碰撞的主体类别的掩码(每个过滤的类别由设置为 0 的位表示，`maskBits`成员)，如下图所示:

![Collision modes and filtering](graphics/9645_09_04.jpg)

上图中`Body A`在类别`1`和`3`中，与类别`2`和`4`中的物体发生碰撞，这个可怜的`Body B`就是如此，除非它的蒙版滤镜与`Body A`类别(即`1`和`3`)发生碰撞。换句话说，A 体和 B 体都必须同意碰撞！

Box2D 也有碰撞组的概念。实体的碰撞组设置为以下任意值:

*   **正整数**:表示其他碰撞组值相同的体可以碰撞
*   **负整数**:表示过滤掉其他碰撞组值相同的体

在 DroidBlaster 中，使用碰撞组也可能是避免小行星之间碰撞的一种解决方案，尽管它不如类别和遮罩灵活。请注意，组在类别之前被过滤。

一个比类别和组过滤器更灵活的解决方案是`b2ContactFilter`类。这个类有一个`ShouldCollide(b2Fixture, b2Fixture)`方法，你可以自定义它来执行你自己的过滤。实际上，类别/组过滤本身就是这样实现的。

## 继续使用 Box2D

这个关于 Box2D 的简短介绍只给你一个 Box2D 能力的概述！以下非详尽的清单留在阴影中:

*   连接两个物体的关节
*   **光线投射**到查询物理世界(例如，枪指向哪个位置)
*   接触属性:法线、脉冲、流形等

### 类型

Box2D 现在有一个名为 **LiquidFun** 的小兄弟，用来模拟流体。您可以在[http://google.github.io/liquidfun/](http://google.github.io/liquidfun/)下载并观看它的运行。

Box2D 有一个非常好的文档，其中包含有用的信息，可以在[http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)找到。此外，Box2D 还打包了一个测试床目录(在`Box2D/Testbed/Tests`中)，该目录具有许多用例。看一看它们，以便更好地了解它的功能。因为物理模拟有时会相当棘手，所以我也鼓励你在[http://www.box2d.org/forum/](http://www.box2d.org/forum/)访问相当活跃的 Box2D 论坛。

# 在安卓上预构建 Boost

如果说 STL 是 C++ 程序中最常见的框架，那么 Boost 可能排在第二位。一把真正的瑞士军刀！该工具包包含大量实用程序来处理最常见的需求，甚至更多。

大部分 Boost 特性都是作为纯头文件代码提供的，这意味着我们不需要编译它。包含标题是使用它的足够优势。这是 Boost 最受欢迎的特性的案例:**智能指针**，一个自动处理内存分配和取消分配的引用计数指针类。它们几乎免费地避免了大多数内存泄漏和指针误用。

然而，Boost 的一些部分需要首先编译，比如线程或者单元测试库。我们现在将看到如何用安卓 NDK 构建它们，并编译一个单元测试可执行文件。

### 注

产生的项目以`DroidBlaster_Part18`的名称提供本书。

# 行动时间-预构建 Boost 静态库

让我们通过以下步骤为安卓预构建 Boost 作为静态库:

1.  Download Boost from [http://www.boost.org/](http://www.boost.org/) (Version 1.55.0, in this book). Unzip the archive into `${ANDROID_NDK}/sources`. Name the directory `boost`.

    打开一个命令行窗口，进入`boost`目录。在 Windows 或上启动`bootstrap.bat`。`/bootstrap.sh`在 Linux 和 Mac 上 OS X 打造 **b2** 。这个程序，之前被命名为 **BJam** ，是一个类似于 **Make** 的自定义构建工具。

    ### 注

    Boost 1.55.0 存档在`Libraries/boost`目录中是随本书提供的。

    在 DroidBlaster 中更改 NDK 构建命令，以生成详细的编译日志。为此，在 Eclipse **项目属性**中，导航到 **C/C++ 构建**部分。在那里，您应该会看到下面的构建命令:`ndk-build NDK_DEBUG=1`。将其更改为`build NDK_DEBUG=0 V=1`以详细日志的发布模式进行编译。

2.  Rebuild DroidBlaster (you might need to clean your project first). If you look, for example, at the following compilation extract, you should see some logs similar to the extract below. This log, although barely readable, gives all the information about the commands run to build DroidBlaster.
    *   用于构建 DroidLaster(`arm-linux-androideabi-4.6`)的工具链
    *   构建 DroidBlaster 的系统(`linux-x86_64`)
    *   编译器可执行文件(`arm-linux-androideabi-g++ `)
    *   归档程序可执行文件(`arm-linux-androideabi-ar`)
    *   还有传递给它们的所有编译标志(这里是 ARM 处理器)

    我们可以用以下作为灵感来源来确定`Boost`编译旗(在这个旗汤里！):

    ```cpp
    ...
    /opt/android-ndk/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/bin/arm-linux-androideabi-g++ -MMD -MP -MF ./obj/local/armeabi/objs/DroidBlaster/Asteroid.o.d -fpic -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fno-exceptions -fno-rtti -mthumb -Os -g -DNDEBUG -fomit-frame-pointer -fno-strict-aliasing -finline-limit=64 -I/opt/android-ndk/sources/android/native_app_glue -I/opt/android-ndk/sources/libpng -I/opt/android-ndk/sources/box2d -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/include -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/include -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/include/backward -Ijni -DANDROID  -Wa,--noexecstack -Wformat -Werror=format-security      -I/opt/android-ndk/platforms/android-16/arch-arm/usr/include -c  jni/Asteroid.cpp -o ./obj/local/armeabi/objs/DroidBlaster/Asteroid.o

    ...
    /opt/android-ndk/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/bin/arm-linux-androideabi-ar crsD ./obj/local/armeabi/libandroid_native_app_glue.a ./obj/local/armeabi/objs/android_native_app_glue/android_native_app_glue.o
    ...
    ```

3.  在`boost` 目录下，打开`tools/build/v2/user-config.jam`文件。这个文件，顾名思义，就是一个可以设置自定义`Boost` 编译的配置文件。初始内容仅包含注释，可以删除。开始包括以下内容:

    ```cpp
    import feature ;
    import os ;

    if [ os.name ] = CYGWIN || [ os.name ] = NT {
        androidPlatform = windows ;
    } else if [ os.name ] = LINUX {
        if [ os.platform ] = X86_64 {
            androidPlatform = linux-x86_64 ;
        } else {
            androidPlatform = linux-x86 ;
        }
    } else if [ os.name ] = MACOSX {
        androidPlatform = darwin-x86 ;
    }
    ...
    ```

4.  编译是静态执行的。 **BZip** 被停用，因为它在安卓系统上默认不可用(不过我们可以单独编译):

    ```cpp
    ...
    modules.poke : NO_BZIP2 : 1 ;
    ...
    ```

5.  Retrieve the `android_ndk` environment variable which points to the NDK location on disk.

    声明我们可以称之为“配置”`android4.6_armeabi`。

    然后，重新配置 Boost，在静态模式下使用 NDK ARM GCC 工具链(`g++ `、`ar`和`ranlib`)，归档器负责创建静态库。我们可以使用在步骤 2 中的日志中找到的信息来填充它们各自的路径。

    `sysroot`指令指示编译和链接哪个安卓应用编程接口版本。位于 NDK 的指定目录包含特定于此版本的`include`文件和库，如以下代码所示:

    ```cpp
    ...
    android_ndk = [ os.environ ANDROID_NDK ] ;
    using gcc : android4.6_armeabi :
        $(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-g++ :
        <archiver>$(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-ar
        <ranlib>$(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-ranlib
        <compileflags>--sysroot=$(android_ndk)/platforms/android-16/arch-arm
        <compileflags>-I$(android_ndk)/sources/cxx-stl/gnu-libstdc++/4.6/include
        <compileflags>-I$(android_ndk)/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/include
    ...
    ```

6.  助推需求例外还有 RTTI。使用`–fexceptions`和`–frtti`标志启用它们，如下代码所示:

    ```cpp
    ...
        <compileflags>-fexceptions
        <compileflags>-frtti
    ...
    ```

7.  A few options have to be defined to tweak `Boost` compilation. This is where we can take inspiration from the compilation flags discovered in step 2, such as the following:
    *   `-march=armv5te`指定目标平台
    *   `-mthumb`，表示生成的代码应该使用 thumb 指令(`-marm`也可以改为使用 ARM 指令)
    *   `-0s`启用编译器优化
    *   `-DNDEBUG`在发布模式下请求编译

    还包括或调整其他选项，例如:

    *   - `D__arm__`、`-D__ARM_ARCH_5__`等等，帮助从代码中确定目标平台
    *   `-DANDROID`、`-D__ANDROID__`，有助于确定目标 OS
    *   `-DBOOST_ASIO_DISABLE_STD_ATOMIC`禁用`std::atomic`的使用，这在安卓系统上是有问题的(只能通过(糟糕的)“体验”来学习的东西)……。

        ```cpp
            <compileflags>-march=armv5te
            <compileflags>-mthumb
            <compileflags>-mtune=xscale
            <compileflags>-msoft-float
            <compileflags>-fno-strict-aliasing
            <compileflags>-finline-limit=64
            <compileflags>-D__arm__
            <compileflags>-D__ARM_ARCH_5__
            <compileflags>-D__ARM_ARCH_5T__
            <compileflags>-D__ARM_ARCH_5E__
            <compileflags>-D__ARM_ARCH_5TE__
            <compileflags>-MMD
            <compileflags>-MP
            <compileflags>-MF
            <compileflags>-fpic
            <compileflags>-ffunction-sections
            <compileflags>-funwind-tables
            <compileflags>-fstack-protector
            <compileflags>-no-canonical-prefixes
            <compileflags>-Os
            <compileflags>-fomit-frame-pointer
            <compileflags>-fno-omit-frame-pointer
            <compileflags>-DANDROID
            <compileflags>-D__ANDROID__
            <compileflags>-DNDEBUG
            <compileflags>-D__GLIBC__
            <compileflags>-DBOOST_ASIO_DISABLE_STD_ATOMIC
            <compileflags>-D_GLIBCXX__PTHREADS
            <compileflags>-Wa,--noexecstack
            <compileflags>-Wformat
            <compileflags>-Werror=format-security
            <compileflags>-lstdc++
            <compileflags>-Wno-long-long
                ;
        ```

8.  从位于 boost 目录中的终端指向，使用以下命令行启动编译。我们需要排除 **Python** 模块，该模块需要额外的库，而这些库在默认情况下在 NDK 是不可用的。

    ```cpp
    ./b2 --without-python toolset=gcc-android4.6_armeabi link=static runtime-link=static target-os=linux architecture=arm --stagedir=android-armeabi threading=multi

    ```

最终静态库在`android-armeabi/lib/`中生成。

对 ArmV7 和 X86 平台重复相同的步骤，为它们创建新的配置。ArmV7 的暂存目录必须是`armeabi-v7a`，X86 的暂存`android-x86`。

### 注

最终`user-config.jam`在`Libraries/boost`目录中提供了本书。

## *刚刚发生了什么？*

我们已经定制了 Boost 配置，使用原始的安卓 GCC 工具链作为独立的编译器(也就是说，没有 NDK 包装器)。我们已经声明了各种标志来使编译适应安卓目标平台。然后，我们使用其专用构建工具`b2`手动构建了 Boost。现在每次 Boost 更新或者修改，都要用`b2`再次手动编译代码。

我们还强制 NDK-Build 使用`V=1`参数生成详细的日志。这有助于解决编译问题，或者获得关于 NDK-Build 编译内容和方式的反馈。

最后，我们通过切换`NDK_DEBUG`到`0`启用了发布编译模式，也就是代码优化。这也可以通过在`jni/Application.mk`中设置`APP_OPTIM := release`来实现。海合会主要有五个优化级别，如下:

*   **-O0** :这将禁用任何优化。当`APP_OPTIM`被设置为`debug`时，这是由 NDK 自动设置的(在本章最后一部分关于 Makefiles 中有更多的说明)。
*   **-O1** :这允许在不增加太多编译时间的情况下进行基本优化。这些优化不需要任何速度-空间权衡，这意味着它们在不增加可执行文件大小的情况下产生更快的代码。
*   **-O2** :这允许高级优化(包括`-O1`)，但代价是编译时间。像`–O1`一样，这些优化不需要速度和空间的权衡。
*   **-O3** :这执行激进的优化(包括`-O2`)，可以增加可执行文件的大小，比如**函数内联**。这通常是有利可图的，但有时会适得其反(例如，增加内存使用也会增加缓存未命中)。
*   **-Os** :这个在速度之前优化了编译后的代码大小(是`–O2`的子集)。

虽然`-Os`或`–O2`通常是发布模式的选择，但是`-O3`也可以考虑用于性能关键的代码。`-0x`标志是各种 GCC 优化标志的快捷方式，启用`–O2`并附加额外的“细粒度”标志(例如，`-finline-functions`)也是一个选项。无论你选择什么选项，找到最佳选择的最好方法就是简单地执行基准测试！要获得更多关于众多 GCC 优化选项的信息，请查看[http://gcc.gnu.org/](http://gcc.gnu.org/)。

现在 Boost 模块已经预先构建好了，我们可以在应用程序中嵌入它的任何库。

# 行动时间–编译链接到 Boost 的可执行文件

让我们使用 Boost 单元测试库，通过以下步骤构建我们自己的单元测试可执行文件:

1.  Still in the `boost` directory, create a new `Android.mk` file to declare the newly prebuilt libraries as Android modules and make them available to NDK applications. This file needs to contain one module declaration per library. For example, define one module `boost_unit_test_framework`:
    *   `LOCAL_SRC_FILES`参考我们用 b2 构建的静态库`libboost_unit_test_framework.a`。

    使用`$(TARGET_ARCH_ABI)`变量确定正确的使用路径，具体取决于目标平台。它的值可以是`armeabi`、`armeabi-v7a`或`x86`。如果你为 X86 编译 DroidBlaster，NDK 将在`androidx86/lib`中寻找`libboost_unit_test_framework.a`。

    *   `LOCAL_EXPORT_C_INCLUDES`自动将 boost 根目录追加到包含模块的包含文件目录列表中。
    *   用`$(PREBUILT_STATIC_LIBRARY)`指令

        ```cpp
        LOCAL_PATH:= $(call my-dir)

        include $(CLEAR_VARS)

        LOCAL_MODULE:= boost_unit_test_framework
        LOCAL_SRC_FILES:= android-$(TARGET_ARCH_ABI)/lib/libboost_unit_test_framework.a
        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)

        include $(PREBUILT_STATIC_LIBRARY)
        ```

        指示该模块是一个预构建的库

    可以在同一文件中用同一组行声明更多的模块(例如`boost_thread`)。

    ### 注

    最终`user-config.jam`在`Libraries/boost`目录中提供了本书。

2.  回到`DroidBlaster`项目，创建一个包含单元测试文件`test/Test.cpp`的新目录`test`。编写一个测试来检查`TimeManager`的行为，如下面的代码所示:

    ```cpp
    #include "Log.hpp"
    #include "TimeManager.hpp"

    #include <unistd.h>

    #define BOOST_TEST_MODULE DroidBlaster_test_module
    #include <boost/test/included/unit_test.hpp>

    BOOST_AUTO_TEST_SUITE(suiteTimeManager)

    BOOST_AUTO_TEST_CASE(testTimeManagerTest_elapsed)
    {
        TimeManager timeManager;
        timeManager.reset();

        sleep(1);
        timeManager.update();
        BOOST_REQUIRE(timeManager.elapsed() > 0.9f);
        BOOST_REQUIRE(timeManager.elapsed() < 1.2f);

        sleep(1);
        timeManager.update();
        BOOST_REQUIRE(timeManager.elapsed() > 0.9f);
        BOOST_REQUIRE(timeManager.elapsed() < 1.2f);
    }

    BOOST_AUTO_TEST_SUITE_END()
    ```

3.  要在应用程序中包含 Boost，我们需要将其与支持异常和 RTTI 的 STL 实现相链接。在`Application.mk`文件中全局启用，如下代码所示:

    ```cpp
    APP_ABI := armeabi armeabi-v7a x86
    APP_STL := gnustl_static
    APP_CPPFLAGS := -fexceptions –frtti

    ```

4.  Finally, open DroidBlaster `jni/Android.mk` and create a second module named `DroidBlaster_test` before the `import-module` section. This module compiles the additional `test/Test.cpp` test file and must be linked to the Boost unit test library. Build this module as an executable, and not a shared library, with `$(BUILD_EXECUTABLE)`.

    最后，在导入模块部分导入`Boost`模块本身，如下代码所示:

    ```cpp
    ...
    include $(BUILD_SHARED_LIBRARY)

    include $(CLEAR_VARS)

    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))
    LS_CPP_TEST=$(subst $(1)/,,$(wildcard $(1)/../test/*.cpp))
    LOCAL_MODULE := DroidBlaster_test
    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH)) \

    $(call LS_CPP_TEST,$(LOCAL_PATH))
    LOCAL_LDLIBS := -landroid -llog -lEGL -lGLESv2 -lOpenSLES
    LOCAL_STATIC_LIBRARIES := android_native_app_glue png box2d_static \
        libboost_unit_test_framework

    include $(BUILD_EXECUTABLE)

    $(call import-module,android/native_app_glue)
    $(call import-module,libpng)
    $(call import-module,box2d)
    $(call import-module,boost)

    ```

5.  构建项目。如果你查看`libs`文件夹，除了共享库，你应该还会看到一个`droidblaster_test`文件。这是一个可执行文件，我们可以在模拟器或根设备上运行(假设您有权部署和更改文件权限)。部署这个文件并运行它(在 Arm V7 模拟器实例上):

    ```cpp
    adb push libs/armeabi-v7a/droidblaster_test /data/data/
    adb shell /data/data/droidblaster_test

    ```

![Time for action – compiling an executable linked to Boost](graphics/9645_09_01.jpg)

## *刚刚发生了什么？*

我们已经使用 Boost 预构建模块创建了一个完全本机的可执行文件，并且可以在 Android 上运行。Boost 预建静态库已经从`Boost`目录中的 Boost `Android.mk`模块文件中“发布”。

事实上，有四种主要的方法来构建本机库。我们已经在 Box2D 部分看到了`BUILD_STATIC_LIBRARY`和`BUILD_SHARED_LIBRARY`。两种选择并存，其中如下:

*   `PREBUILT_STATIC_LIBRARY`使用现有的(即，预构建的)二进制静态库
*   `PREBUILT_SHARED_LIBRARY`使用现有的二进制共享库

这些指令表明库已经准备好进行链接。

在主模块文件中，正如我们在 Box2D 中看到的，链接的子模块需要列在:

*   `LOCAL_SHARED_LIBRARIES`为共享库
*   `LOCAL_STATIC_LIBRARIES`为静态库

无论库是否是预构建的，同样的规则也适用。模块，无论是静态的、共享的、预构建的还是按需构建的，都必须使用 NDK `import-module`指令导入到最终的主模块中。

当预构建的库链接到主模块时，源文件是不必要的。包含文件显然仍然是必需的。因此，如果您想在不发布源代码的情况下向第三方提供库，预构建库是一个合适的选择。另一方面，按需编译允许从主`Application.mk`项目文件中调整所有包含库的编译标志(如优化标志、ARM 模式等)。

为了与 Boost 正确链接，我们还在整个项目中启用了例外和 RTTI。通过将`-fexceptions`和`-frtti`附加到相关库的`Application.mk`文件或`LOCAL_CPPFLAGS`文件中的`APP_CPPFLAGS`指令，可以非常容易地激活例外和 RTTI。默认情况下，安卓编译带有`-fno-exceptions`和`-fno-rtti`标志。

事实上，异常会使编译后的代码变得更大，效率更低。它们阻止编译器执行一些巧妙的优化。然而，异常是否比错误检查更糟糕，甚至根本没有检查，这是一个非常有争议的问题。事实上，谷歌的工程师在最初的版本中放弃了它们，因为 GCC 3.x 为 ARM 处理器生成了一个糟糕的异常处理代码。然而，构建链现在使用 GCC 4.x，它没有这个缺陷。与手动错误检查和异常情况的处理相比，这种惩罚在大多数情况下可能并不重要。因此，异常的选择取决于您(和您的嵌入式库)！

### 类型

C++ 中的异常处理并不容易，而且要求严格的纪律！它们必须严格用于特殊情况，并且需要精心设计的代码。看一下**资源获取是初始化** ( **RAII** )成语来妥善处理他们。更多信息请看[http://en . Wikipedia . org/wiki/Resource _ Acquisition _ Is _ Initialization](http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)。

显然，Boost 提供了比单元测试更有趣的特性。在 http://www.boost.org/doc/libs 的官方文档中发现它的全部丰富性。请注意，Boost 在安卓系统上经常会出现重大变化或错误，因为它在该平台上没有得到非常积极的维护和测试。准备好直接在其代码中调查和修复问题。

现在我们已经在练习中看到了如何编写模块 Makefiles，让我们来了解更多关于它们的知识。

# 主控模块制作文件

安卓制作文件是 NDK 建设过程中必不可少的一部分。因此，为了正确地构建和管理一个项目，理解它们的工作方式是很重要的。

## Makefile 变量

编译设置是通过一组预定义的 NDK 变量来定义的。我们已经看到了三个最重要的:`LOCAL_PATH, LOCAL_MODULE`，和`LOCAL_SRC_FILES`，但是还有很多其他的存在。我们可以区分以下四种类型的变量，每种变量都有不同的前缀:

*   `LOCAL_`变量:这些专用于单个模块编译，在`Android.mk`文件中定义。
*   `APP_`变量:这些指的是应用范围的选项，在`Application.mk`中设置。
*   `NDK_`变量:这些主要是内部变量，通常指环境变量(例如`NDK_ROOT`、`NDK_APP_CFLAGS,`或`NDK_APP_CPPFLAGS`)。有两个明显的例外:`NDK_TOOLCHAIN_VERSION`和`NDK_APPLICATION_MK`。后者可以传递给 NDK-内置参数，以定义不同的`Application.mk`位置。
*   `PRIVATE_`前缀变量:这些仅供 NDK 内部使用。

下表包含`LOCAL`变量的非穷举列表:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

可变的

 | 

描述

 |
| --- | --- |
| `LOCAL_PATH` | 指定源文件的根位置。必须在`include $(CLEAR_VARS)`之前的`Android.mk`文件开头定义。 |
| `LOCAL_MODULE` | 要定义模块名称，它在所有模块中必须是唯一的。 |
| `LOCAL_MODULE_FILENAME` | 覆盖编译模块的默认名称，即:`- lib<module name>.so`为共享库。`- lib<module name>.a`为静态库。不能指定自定义文件扩展名以使`.so`或`.a`保持附加状态。 |
| `LOCAL_SRC_FILES` | 定义要编译的源文件列表，每个文件由一个空格分隔，并且相对于`LOCAL_PATH`。 |
| `LOCAL_C_INCLUDES` | 为 C 和 C++ 语言指定头文件目录。目录可以是相对于`${ANDROID_NDK}`目录的，但是除非需要包含特定的 NDK 文件，否则建议使用绝对路径(可以从 Makefile 变量如`$(LOCAL_PATH)`构建)。 |
| `LOCAL_CPP_EXTENSION` | 更改默认的 C++ 文件扩展名，即`.cpp`(例如`.cc`或`.cxx`)。可以指定由空格分隔的文件扩展名列表。GCC 需要扩展名来确定哪个文件与哪个语言相关。 |
| `LOCAL_CFLAGS`、`LOCAL_CPPFLAGS`、`LOCAL_LDLIBS` | 为编译和链接指定任何选项、标志或宏定义。第一个适用于 C 和 C++，第二个仅适用于 C++，最后一个适用于链接器。 |
| `LOCAL_SHARED_LIBRARIES`、`LOCAL_STATIC_LIBRARIES` | 分别声明与其他模块(不是系统库)、共享模块和静态模块的依赖关系。`LOCAL_SHARED_LIBRARIES`管理依赖关系，而`LOCAL_LDLIBS`应该用于声明系统库。 |
| `LOCAL_ARM_MODE`、`LOCAL_ARM_NEON`、`LOCAL_DISABLE_NO_EXECUTE`、`LOCAL_FILTER_ASM` | 处理处理器和汇编/二进制代码生成的高级变量。对于大多数程序来说，它们不是必需的。 |
| `LOCAL_EXPORT_C_INCLUDES`、`LOCAL_EXPORT_CFLAGS`、`LOCAL_EXPORT_CPPFLAGS`、`LOCAL_EXPORT_LDLIBS` | 在导入模块中定义附加到客户端模块选项的附加选项或标志。例如，如果模块 A 定义了`LOCAL_EXPORT_LDLIBS := -llog`因为它需要一个安卓日志模块。然后，依赖于模块 A 的模块 B 将自动链接到`–llog`。`LOCAL_EXPORT_`编译导出变量的模块时不使用变量。如果需要，他们也需要在他们的`LOCAL`对应物中指定。 |

关于这些变量的文件可以在`${ANDROID_NDK}/docs/ANDROID-MK.html`找到。

下表包含`APP`变量的非穷举列表(所有变量都是可选的):

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

可变的

 | 

描述

 |
| --- | --- |
| `APP_PROJECT_PATH` | 指定应用程序项目的根目录。 |
| `APP_MODULES` | 要用标识符编译的模块列表。还包括相关模块。例如，这可以用来强制生成静态库。 |
| `APP_OPTIM` | 设置为`release`或`debug`以使编译设置适应您想要的构建类型。当没有明确指定时，NDK 使用 AndroidManifest 中的可调试标志来确定构建类型。 |
| `APP_CFLAGS``APP_CPPFLAGS``APP_LDFLAGS` | 为编译和链接全局指定任何选项、标志或宏定义。第一个适用于 C 和 C++，第二个仅适用于 C++，最后一个适用于链接器。 |
| `APP_BUILD_SCRIPT` | 重新定义 Android.mk 文件的位置(默认在项目的`jni`目录中)。 |
| `APP_ABI` | 应用程序支持的 ABI(即“CPU 架构”)列表，用空格分隔。当前支持的值有`armeabi`、`armeabi-v7a`、`x86`、mips 或`all`。每个模块每 ABI 重新编译一次。所以，你支持的 ABI 越多，建设的时间就越长。 |
| `APP_PLATFORM` | 目标 Android 平台的名称。该信息默认在`project.properties`文件中找到。 |
| `APP_STL` | 要使用的 C++ 运行时。可能的值有`system`、`gabi++ _static`、`gabi++ _shared`、`stlport_static`、`stlport_shared`、`gnustl_static`、`gnustl_shared`、`c++ _static`和`c++ _shared`。 |

关于这些变量的文件可以在`${ANDROID_NDK}/docs/APPLICATION-MK.html`找到。

## 启用 C++ 11 支持和 Clang 编译器

可以在`Application.mk`文件中重新定义`NDK_TOOLCHAIN_VERSION`变量，以明确选择编译工具链。 NDK R10 的可能值是`4.6`(现已弃用)`4.8`和`4.9`，它们仅对应于 GCC 版本。可能的版本号可能会在 NDK 的未来版本中发生变化。要找到他们，看一下`$ANDROID_NDK/toolchains`目录。

安卓 NDK 提供 C++ 11 支持，从 GCC 4.8 工具链开始。您可以通过附加`-std=c++ 11`编译标志并激活 GNU STL(不支持 STL Port，编写本书时只部分支持 Libc++)来启用它，以获得适当的 C++ 11 支持。以下是激活 C++ 11 的`an Android.mk`提取的例子:

```cpp
...
NDK_TOOLCHAIN_VERSION := 4.8
APP_CPPFLAGS += -std=c++ 11
APP_STL := gnustl_shared
...
```

### 类型

切换到 GCC4.8 和 C++ 11 可能感觉不太容易。事实上，比如说，编译器比以前稍微宽松了一点。万一你在用这个新的工具链编译遗留代码时遇到麻烦，试试`–fpermissive`标志(或者重写你的代码！).

此外，请注意，虽然 C++ 11 的支持相当大，但您可能仍然会遇到一些问题或缺少一些功能。

要启用基于 LLVM 的编译器 Clang(因被苹果使用而闻名)，代替 GCC，只需将`NDK_TOOLCHAIN_VERSION`设置为`clang`。也可以指定编译器版本，如`clang3.4`或`clang3.5`。同样，在 NDK 的未来版本中，可能的版本号可能会改变。要找到他们，看一下`$ANDROID_NDK/toolchains`目录。

## 制作文件说明

Makefile 是真正的语言，有编程指令和函数。

Makefiles 可以分解成几个子 Makefiles，包含在`include`指令中。变量初始化有以下两种方式:

*   简单做作(`operator :=`)，在变量初始化时展开变量
*   递归做作(`operator =`)，每次调用受影响的表达式时都会重新计算它

以下条件和循环指令可用:`ifdef/endif`、`ifeq/endif`、`ifndef/endif`、`and for…in/do/done`。例如，要仅在定义变量时显示消息，请执行以下操作:

```cpp
ifdef my_var
    # Do something...
endif
```

更高级的东西，比如功能性的`if`、`and`、`or`等等，你可以随意使用，但是很少使用。Makefiles 还提供了一些有用的内置函数，如下表所示:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| `$(info <message>)` | 允许将消息打印到标准输出。这是编写 Makefiles 时最基本的工具！信息消息中的变量是允许的。 |
| `$(warning <message>)`、`$(error <message>)` | 允许打印停止编译的警告或致命错误。Eclipse 可以解析这些消息。 |
| `$(foreach <variable>`、`<list>`、`<operation>)` | 对变量列表执行操作。在对列表的每个元素应用操作之前，该元素在第一个参数变量中展开。 |
| `$(shell <command>)` | 在 Make 之外执行命令。这将 Unix Shell 的所有功能都引入到 Makefiles 中，但严重依赖于系统。尽可能避免。 |
| `$(wildcard <pattern>)` | 根据模式选择文件和目录名。 |
| `$(call <function>)` | 允许计算函数或宏。我们看到的一个宏是`my-dir`，它返回最后执行的 Makefile 的目录路径。这就是为什么`LOCAL_PATH := $(call my-dir)`被系统地写在每个`Android.mk`文件的开头，保存在当前的 Makefile 目录中。 |

使用`call`指令可以很容易地编写自定义函数。这些函数看起来有点类似于递归影响的变量，只是可以定义参数:第一个参数为`$(1)`，第二个参数为`$(2)`，依此类推。对函数的调用可以在一行中执行，如以下代码所示:

```cpp
my_function=$(<do_something> ${1},${2})
$(call my_function,myparam)
```

字符串和文件操作功能也可用，如下表所示:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| `$(join <str1>, <str2>)` | 连接两个字符串。 |
| `$(subst <from>,``<replacement>,<string>)`，`$(patsubst <pattern>,``<replacement>,<string>)` | 用另一个子字符串替换每个出现的子字符串。第二个更强大，因为它允许使用模式(必须以“%”开头)。 |
| `$(filter <patterns>, <text>)``$(filter-out <patterns>, <text>)` | 从匹配模式的文本中过滤字符串。这对于过滤文件很有用。例如，下面一行过滤任何 C 文件:`$(filter %.c, $(my_source_list))` |
| `$(strip <string>)` | 删除任何不必要的空白。 |
| `$(addprefix <prefix>,<list>)`，`$(addsuffix <suffix>, <list>)` | 分别为列表的每个元素添加前缀和后缀，每个元素之间用空格隔开。 |
| `$(basename <path1>, <path2>, ...)` | 返回从中删除文件扩展名的字符串。 |
| `$(dir <path1>, <path2>)`，`$(notdir <path1>, <path2>)` | 分别提取路径中的目录和文件名。 |
| `$(realpath <path1>, <path2>, ...)`，`$(abspath <path1>, <path2>, ...)` | 返回每个路径参数的两个规范路径，除了第二个不计算符号链接。 |

这只是对 Makefiles 功能的一个概述。有关更多信息，请参考位于[http://www.gnu.org/software/make/manual/make.html](http://www.gnu.org/software/make/manual/make.html)的完整 Makefile 文档。如果你对 Makefiles 过敏，可以看看 CMake。CMake 是一个简化的 Make 系统，已经在市场上建立了许多开源库。安卓系统上的一个 CMake 端口可以在[http://code.google.com/p/android-cmake](http://code.google.com/p/android-cmake)找到。

## 有一个围棋英雄——掌握 Makefiles

我们可以用 Makefiles 以多种方式玩游戏:

*   试试做作的操作符。例如，在你的`Android.mk`文件中写下下面这段使用`:= operator`的代码:

    ```cpp
    my_value   := Android
    my_message := I am an $(my_value)
    $(info $(my_message))
    my_value   := Android eating an apple
    $(info $(my_message))
    ```

*   启动编译时观察结果。然后，使用`=`执行相同的操作。打印当前优化模式。使用`APP_OPTIM`和内部变量`NDK_APP_CFLAGS`，观察`release`和`debug`模式的区别:

    ```cpp
    $(info Optimization level: $(APP_OPTIM) $(NDK_APP_CFLAGS))
    ```

*   检查变量是否定义正确，例如:

    ```cpp
    ifndef LOCAL_PATH
        $(error What a terrible failure! LOCAL_PATH not defined...)
    endif
    ```

*   尝试使用`foreach`指令打印项目根目录及其`jni`文件夹内的文件和目录列表(并确保使用递归方式):

    ```cpp
    ls = $(wildcard $(var_dir))
    dir_list := . ./jni
    files := $(foreach var_dir, $(dir_list), $(ls))
    ```

*   尝试创建一个宏来记录标准输出的消息及其时间:

    ```cpp
    log=$(info $(shell date +'%D %R'): $(1))
    $(call log,My message)
    ```

*   最后，测试`my-dir`的宏观行为，了解为什么`LOCAL_PATH := $(call my-dir)`会系统地写在每个`Android.mk`文件的开头:

    ```cpp
    $(info MY_DIR    =$(call my-dir))
    include $(CLEAR_VARS)
    $(info MY_DIR    =$(call my-dir))
    ```

## 中央处理器架构(ABI)

在当前安卓 ARM 设备上编译的本机 C/C++ 代码遵循**应用程序二进制接口** ( **ABI** )。ABI 指定了二进制代码格式(指令集、调用约定等)。GCC 将代码翻译成这种二进制格式。因此，ABI 与处理器密切相关。目标 ABI 可以用`APP_ABI`变量在`Application.mk`文件中选择。安卓支持的 ABI 主要有以下五种:

*   **拇指**:这是默认选项，应该兼容所有 ARM 设备。Thumb 是一种特殊的指令集，它将指令编码为 16 位，而不是 32 位，以提高代码大小(对于内存受限的设备非常有用)。与 ArmEABI 相比，指令集受到严格限制。
*   **armeabi** (或 Arm v5):这应该在所有 Arm 设备上运行。指令以 32 位编码，但可能比 Thumb 代码更简洁。Arm v5 不支持浮点加速等高级扩展，因此比 Arm v7 慢。
*   **armeabi-v7a** :这支持 Thumb-2(类似于 Thumb，但有额外的 32 位指令)和 VFP 等扩展，外加一些可选的扩展，如 NEON。为 Arm V7 编译的代码不会在 Arm V5 处理器上运行。
*   **x86** :这是针对“*类 PC*”架构(也就是英特尔/AMD)，更确切的说是英特尔凌动处理器。这个 ABI 提供了特定的扩展，如 MMX 或上交所。
*   **mips** :这是为畅想科技(也生产power VR 图形处理器)开发的 mips 处理器。在写这本书的时候，只有少数设备存在。

默认情况下，每个 ABI 的编译二进制文件都嵌入在 APK 中。安装时选择最合适的。谷歌 Play 还支持为每个 ABI 上传不同的 apk，以限制应用程序的大小。

## 高级指令集(NEON、VFP、上交所、MSA)

如果你正在读这本书，代码性能可能是你的主要标准之一。为了实现这一点，ARM 创建了一个名为 NEON 的 SIMD 指令集(首字母缩略词单指令多数据，也就是用一条指令并行处理几个数据)，这个指令集是和 VFP(浮点加速)单元一起引入的。NEON 并非在所有芯片上都可用(例如，Nvidia Tegra 2 不支持它)，但在密集型多媒体应用中相当受欢迎。它们也是补偿某些处理器(例如 Cortex-A8)的弱 VFP 单元的好方法。

### 类型

NEON 代码可以用汇编指令写在专用的`asm volatile`块中的独立汇编文件中，也可以写在 C/C++ 文件中，或者作为内函数(封装在 GCC C 例程中的 NEON 指令)。由于 GCC 经常不能生成有效的机器代码(或者需要很多复杂的提示)，所以使用 Intrinsics 应该非常小心。一般建议编写真正的汇编代码。

X86 CPUs 有自己的扩展集，不同于 ARM 的扩展集:MMX、SSE、SSE2 和 SSE3。SSE 指令集相当于英特尔的 NEON SIMS 指令。当前的 X86 处理器通常不支持最新的 SSE4 指令。显然，上交所和霓虹是不兼容的，这意味着专门为霓虹编写的代码需要为上交所重写，并相互重写。

### 类型

安卓提供了一个`cpu-features.h`应用编程接口(使用`android_getCpuFamily()`和`android_getCpuFeatures()`方法)，在运行时检测主机设备上的可用功能。它有助于检测中央处理器(ARM、X86)及其功能(ArmV7 支持、NEON、VFP 等)。

一般来说，NEON、SSE 和现代处理器都不容易掌握。互联网上充满了可以从中获得灵感的例子。参考技术文档可在 ARM 网站的[http://infocenter.arm.com/](http://infocenter.arm.com/)和英特尔开发人员手册的[http://www.intel.com/](http://www.intel.com/)上找到。

MIPS 也有自己的 SIMD 指令集，命名为 MSA。它提供了诸如向量算术和分支运算，或者整数值和浮点值之间的转换等功能。更多信息，请看[http://www.imgtec.com/mips/architectures/simd.asp](http://www.imgtec.com/mips/architectures/simd.asp)。

所有这些东西都很有趣，但它没有回答你可能在问自己的问题:将代码从 ARM 移植到 X86 有多难(或者反过来)？答案是“视情况而定”:

*   如果您使用纯 C/C++ 本机代码，没有特定的指令集，代码应该是可移植的，只需将`x86`或`mips`附加到`APP_ABI`变量即可。
*   如果您的代码包含汇编代码，您将需要为其他 ABI 重写相应的部分或提供一个后备。
*   如果您的代码包含特定的指令集，如 NEON(使用 C/C++ 内部代码或汇编代码)，您将需要为其他 ABI 重写相应的部分或提供回退。
*   如果您的代码依赖于特定的内存对齐，您可能需要使用显式对齐。实际上，当您编译数据结构时，编译器可能会使用填充来适当地对齐内存中的数据，以加快内存访问。但是，根据 ABI 的不同，对齐要求也不同。

例如，ARM 上的 64 位变量与 8 对齐，这意味着，例如，double 必须有一个内存地址，它是 8 的倍数。X86 内存可以更密集地打包。

### 类型

数据对齐在大多数情况下都不是问题，除非您明确依赖于数据位置(例如，如果您使用序列化)。即使您没有对齐问题，调整或优化结构布局以避免无用的填充并获得更好的性能也总是很有趣的。

因此，大多数时候，将代码从一个 ABI 移植到另一个应该相当简单。在特定情况下，当需要特定的中央处理器特性或汇编代码时，提供回退。最后，请注意，在一些罕见的情况下，可能会出现一些内存对齐问题。

### 类型

正如我们在预构建增强部分看到的，每个 ABI 都有自己的编译标志来优化编译。虽然 NDK 使用的默认海湾合作委员会选项是一个合适的基础，调整它们可以提高效率和性能。比如可以使用`-mtune=atom -mssse3 -mfpmath=sse`优化 X86 平台上的发布代码。

# 总结

本章介绍了 NDK 的一个基本方面:便携性。由于最近在构建工具链方面的改进，安卓 NDK 现在可以利用庞大的 C/C++ 生态系统。它打开了生产环境的大门，在这里，代码与其他平台共享，目的是高效地创建新的尖端应用程序。

更具体地说，您学习了如何在 NDK makefile 系统中用一个简单的标志激活 STL。我们已经将 Box2D 库移植到一个 NDK 模块中，该模块可以在安卓项目中重用。您还看到了如何使用原始的 NDK 工具链预构建 Boost，而无需任何包装器。我们启用了异常和 RTTI，并深入研究了如何编写模块 makefiles。

我们强调了利用 NDK 作为杠杆创建专业应用程序的途径。但是不要期望所有的 C/C++ 库都能如此容易地移植。说到路径，我们几乎到了尽头。至少，这是关于 DroidBlaster 的最后一章。

下一章和最后一章将介绍 RenderScript，这是一种先进的技术，可以最大限度地提高您的安卓应用程序性能。**