# 第四章。从本机代码调用 Java

> *为了充分发挥潜力，JNI 允许从 C/C++ 回调 Java 代码。“Back”，因为本机代码首先从 Java 中调用，而 Java 又调用它。这种调用是通过反射式应用编程接口来执行的，它允许做几乎任何可以直接在 Java 中完成的事情。*
> 
> *JNI 要考虑的另一个重要问题是线程化。本机代码可以在由 Dalvik VM 管理的 Java 线程上运行，也可以从使用标准 POSIX 原语创建的本机线程中运行。显然，一个本地线程不能调用 JNI 代码，除非它变成一个托管 Java 线程！用 JNI 编程需要了解所有这些微妙之处。这一章将指导你通过主要的。*
> 
> *最后一个主题是安卓专用的，而不是 JNI 专用的，其他:安卓专用的位图应用编程接口旨在为运行在这些微小(但功能强大)设备上的图形应用程序提供全部处理能力。*
> 
> *安卓 NDK 还提出了一个新的 API，用于本地访问一种重要类型的对象:位图。位图应用编程接口是安卓专用的，它为运行在这些微小(但功能强大)设备上的图形应用程序提供了完全的处理能力。*

我们在前一章开始的`Store`项目将成为我们演示 JNI 回调和同步的画布。为了说明位图处理，我们将创建一个新项目，在本机代码中解码设备的摄像头提要。

总而言之，在本章中，我们将学习如何:

*   从本机代码中调用 Java
*   将本机线程附加到 Dalvik 虚拟机，并处理与 Java 线程的同步
*   用本机代码处理 Java 位图

到本章结束时，您应该能够使 Java 和 C/C++ 相互通信和同步。

# 从本机代码调用 Java

在的前一章中，我们发现了如何用 JNI 方法`FindClass()`获得一个 Java 类描述符。然而，我们可以得到更多！事实上，如果你是一个普通的 Java 开发人员，这应该会让你想起一些事情:Java 反射应用编程接口。JNI 的类似之处在于，它可以修改 Java 对象字段、运行 Java 方法和访问静态成员，但只能从本机代码访问！

对于`Store`项目的最后一部分，让我们增强我们的商店应用程序，以便它在条目成功插入时通知 Java。

### 注

由此产生的项目以`Store_Part10`的名称提供本书。

# 行动时间-确定 JNI 方法签名

让我们定义一个 Java 接口，本机 C/C++ 代码将通过 JNI 调用该接口:

1.  创建一个`StoreListener.java`，它包含一个定义了几个回调的接口，一个用于整数，一个用于字符串，一个用于颜色，如下所示:

    ```cpp
    package com.packtpub.store;

    public interface StoreListener {
        void onSuccess(int pValue);

        void onSuccess(String pValue);

        void onSuccess(Color pValue);
    }
    ```

2.  打开`Store.java`做一些改动。
    *   声明一个成员委托`StoreListener`，向其发送成功回调
    *   Change the `Store` constructor to inject the delegate listener, which is going to be `StoreActivity`

        ```cpp
        Public class Store implements StoreListener {
         private StoreListener mListener;
            public Store(StoreListener pListener) {
                mListener = pListener;
            }
            ...
        ```

        最后，实现`StoreListener`接口及其相应的方法，它只是将调用转发给委托:

        ```cpp
            ...
         public void onSuccess(int pValue) {
         mListener.onSuccess(pValue);
         }

         public void onSuccess(String pValue) {
         mListener.onSuccess(pValue);
         }

         public void onSuccess(Color pValue) {
         mListener.onSuccess(pValue);
            }
        }
        ```

3.  Open `StoreActivity.java` and implement the `StoreListener` interface in `PlaceholderFragment`.

    另外，相应地改变和`Store`的结构:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment
     implements StoreListener {
     private Store mStore = new Store(this);
            ...
    ```

    收到成功回拨后，会发出一条简单的祝酒信息:

    ```cpp
            ...
     public void onSuccess(int pValue) {
     displayMessage(String.format(
     "Integer '%1$d' successfuly saved!", pValue));
     }

     public void onSuccess(String pValue) {
     displayMessage(String.format(
     "String '%1$s' successfuly saved!", pValue));
     }

     public void onSuccess(Color pValue) {
     displayMessage(String.format(
     "Color '%1$s' successfuly saved!", pValue));
            }
        }
    }
    ```

4.  Open a terminal in the `Store` project's directory and run the `javap` command to determine method signatures.

    ```cpp
    javap –s -classpath bin/classes com.packtpub.store.Store
    ```

    ![Time for action – determining JNI method signatures](graphics/9645_04_01.jpg)

## *刚刚发生了什么？*

用 JNI 应用编程接口回调 Java 方法需要**描述符**，我们将在下一部分看到。为了确定一个 Java 方法描述符，我们需要一个**签名**。的确，Java 中的方法可以**重载**，这意味着可以有两个同名但参数不同的方法。这就是为什么需要签名。

我们可以用`javap`来确定一个方法的签名，这是一个 JDK 实用程序，用来分解`.class`文件。然后可以将这个签名提供给 JNI 反射应用编程接口。从形式上讲，签名是通过以下方式声明的:

```cpp
(<Parameter 1 Type Code>[<Parameter 1 Class>];...)<Return Type Code>
```

例如，方法`boolean myFunction(android.view.View pView, int pIndex)`的签名将是`(Landroid/view/View;I)Z`。另一个例子，`(I)V`表示需要一个整数，返回一个空值。最后一个例子，`(Ljava/lang/String;)V`表示一个字符串被传入参数。

下表总结了 JNI 可用的各种类型及其代码:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

Java 类型

 | 

本地类型

 | 

本机数组类型

 | 

类型代码

 | 

数组类型代码

 |
| --- | --- | --- | --- | --- |
| `boolean` | `jboolean` | `jbooleanArray` | `Z` | `[Z` |
| `byte` | `jbyte` | `jbyteArray` | `B` | `[B` |
| `char` | `jchar` | `jcharArray` | `C` | `[C` |
| `double` | `jdouble` | `jdoubleArray` | `D` | `[D` |
| `float` | `jfloat` | `jfloatArray` | `F` | `[F` |
| `int` | `jint` | `jintArray` | `I` | `[I` |
| `long` | `jlong` | `jlongArray` | `J` | `[J` |
| `Short` | `jshort` | `jshortArray` | `S` | `[S` |
| `Object` | `jobject` | `jobjectArray` | `L` | `[L` |
| `String` | `jstring` | `N/A` | `L` | `[L` |
| `Class` | `jclass` | `N/A` | `L` | `[L` |
| `Throwable` | `jthrowable` | `N/A` | `L` | `[L` |
| `void` | `void` | `N/A` | `V` | `N/A` |

所有这些值都对应于`javap`转储的值。有关描述符和签名的更多信息，请查看位于[的甲骨文](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3)文档。

现在我们有了合适的签名，就可以开始从 C/C++ 调用【Java 了。

# 行动时间——从本机代码回调 Java

让我们通过调用我们从本机代码中定义的接口来继续我们的`Store`:

1.  在`com_packtpub_store_Store.cpp`中，为每个回调声明类型为`jmethodID`的方法描述符，该描述符将被缓存:

    ```cpp
    ...
    static Store gStore;

    static jclass StringClass;
    static jclass ColorClass;

    static jmethodID MethodOnSuccessInt;
    static jmethodID MethodOnSuccessString;
    static jmethodID MethodOnSuccessColor;
    ...
    ```

2.  Then, cache all the callback descriptors in `JNI_OnLoad()`. This can be done in two main steps:

    使用 JNI 方法`FindClass()`获取类描述符。可以找到一个类描述符，这要归功于它的绝对包路径，这里:`com./packtpub/store/Store`。

    用`GetMethodID()`从类描述符中检索方法描述符。为了区分几个重载方法，必须指定先前用`javap`检索的签名:

    ```cpp
    ...
    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
        JNIEnv *env;
        if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
            abort();
        }
        ...
        // Caches methods.
     jclass StoreClass = env->FindClass("com/packtpub/store/Store");
     if (StoreClass == NULL) abort();

     MethodOnSuccessInt = env->GetMethodID(StoreClass, "onSuccess",
     "(I)V");
     if (MethodOnSuccessInt == NULL) abort();

     MethodOnSuccessString = env->GetMethodID(StoreClass, "onSuccess",
     "(Ljava/lang/String;)V");
     if (MethodOnSuccessString == NULL) abort();

     MethodOnSuccessColor = env->GetMethodID(StoreClass, "onSuccess",
     "(Lcom/packtpub/store/Color;)V");
     if (MethodOnSuccessColor == NULL) abort();
     env->DeleteLocalRef(StoreClass);

        // Store initialization.
        gStore.mLength = 0;
        return JNI_VERSION_1_6;
    }
    ...
    ```

3.  当整数成功插入`setInteger()`时，通知 Java 商店(即`pThis`)。要在 Java 对象上调用 Java 方法，只需使用`CallVoidMethod()`(这意味着被调用的 Java 方法返回 void)。为此，我们需要:
    *   对象实例
    *   方法签名
    *   要通过的有效参数，如果适用(此处为整数值)

        ```cpp
        ...
        JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setInteger
          (JNIEnv* pEnv, jobject pThis, jstring pKey, jint pInteger) {
            StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
            if (entry != NULL) {
                entry->mType = StoreType_Integer;
                entry->mValue.mInteger = pInteger;

         pEnv->CallVoidMethod(pThis, MethodOnSuccessInt,
         (jint) entry->mValue.mInteger);
            }
        }
        ...
        ```

4.  对琴弦重复操作。分配返回的 Java 字符串时，不需要生成全局引用，因为它会立即在 Java 回调中使用。我们也可以在使用后立即销毁对该字符串的本地引用，但是 JNI 将在从本机回调返回时处理这个问题:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setString
      (JNIEnv* pEnv, jobject pThis, jstring pKey, jstring pString) {
        // Turns the Java string into a temporary C string.
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            entry->mType = StoreType_String;
            ...

            pEnv->CallVoidMethod(pThis, MethodOnSuccessString,
     (jstring) pEnv->NewStringUTF(entry->mValue.mString));
        }
    }
    ...
    ```

5.  最后，对颜色重复操作:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColor
      (JNIEnv* pEnv, jobject pThis, jstring pKey, jobject pColor) {
        // Save the Color reference in the store.
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            entry->mType = StoreType_Color;
            entry->mValue.mColor = pEnv->NewGlobalRef(pColor);

            pEnv->CallVoidMethod(pThis, MethodOnSuccessColor,
     (jstring) entry->mValue.mColor);
        }
    }
    ...
    ```

## *刚刚发生了什么？*

启动应用程序并插入整数、字符串或颜色条目。将显示带有插入值的成功消息。多亏了 JNI 反射应用编程接口，本机代码被称为 Java 端。这个 API 不仅对执行一个 Java 方法有用，也是处理传递给本机方法的`jobject`参数的唯一途径。然而，如果从 Java 调用 C/C++ 代码相当容易，那么从 C/C++ 执行 Java 操作就有点复杂了！

虽然有点重复和冗长，但是调用任何 Java 方法都应该像这样简单:

*   从我们想要调用的方法中检索类描述符(这里是`Store` Java 对象):

    ```cpp
    jclass StoreClass = env->FindClass("com/packtpub/store/Store");
    ```

*   检索我们想要调用的回调的方法描述符(比如 Java 中的`Method`类)。这些方法描述符是从拥有它的类描述符中获取的(就像 Java 中的`Class`:

    ```cpp
    jmethodID MethodOnSuccessInt = env->GetMethodID(StoreClass,
                                                    "onSuccess", "(I)V");
    ```

*   Optionally, cache the descriptors so that they can be used immediately in future native calls. Again, `JNI_OnLoad()` makes it easy to cache JNI descriptors before any native call is made. Descriptors whose names end with `Id`, such as `jmethodID`, can be freely cached. They are not references that can be leaked, or have to be made global on the opposite to `jclass` descriptors.

    ### 类型

    缓存描述符绝对是好的做法，因为通过 JNI 反射检索字段或方法可能会导致一些开销。

*   使用对象上的必要参数调用方法。相同的方法描述符可以在相应类的任何对象实例上重用:

    ```cpp
    env->CallVoidMethod(pThis, MethodOnSuccessInt, (jint) myInt); 
    ```

无论您需要在一个 Java 对象上调用什么方法，相同的过程总是适用的。

## 关于 JNI 反射 API 的更多信息

一旦你知道了反射 API，你就知道了 JNI 的大部分。以下是一些可能有用的方法:

*   `FindClass()`根据描述符对象的绝对路径

    ```cpp
    jclass FindClass(const char* name)
    ```

    ，检索对描述符对象的(本地)引用
*   `GetObjectClass()`有相同的目的，只是`FindClass()`根据类定义的绝对路径找到类定义，而另一个直接从对象实例中找到类(比如 Java 中的`getClass()`:

    ```cpp
    jclass GetObjectClass(jobject obj)
    ```

*   下列方法允许您检索方法和字段以及静态或实例成员的 JNI 描述符。这些描述符是标识，而不是对 Java 对象的引用。没有必要把它们变成全球参考。这些方法需要方法或字段名和签名来区分重载。构造函数描述符的检索方式与方法相同，只是它们的名称总是`<init>`并且它们有一个 void 返回值:

    ```cpp
    jmethodID GetMethodID(jclass clazz, const char* name,
                          const char* sig) 
    jmethodID GetStaticMethodID(jclass clazz, const char* name,
                                const char* sig)

    jfieldID GetStaticFieldID(jclass clazz, const char* name,
                              const char* sig)
    jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)
    ```

*   还有第二组方法可以使用相应的描述符来检索字段值。每个原语类型有一个 getter 和一个 setter 方法，另外还有一个用于对象的方法:

    ```cpp
    jobject GetObjectField(jobject obj, jfieldID fieldID)
    <primitive> Get<Primitive>Field(jobject obj, jfieldID fieldID)

    void SetObjectField(jobject obj, jfieldID fieldID, jobject value)
    void Set<Primitive>Field(jobject obj, jfieldID fieldID,
                             <jprimitive> value)
    ```

*   方法也是如此，根据它们的返回值:

    ```cpp
    jobject CallObjectMethod(JNIEnv*, jobject, jmethodID, ...)

    <jprimitive> Call<Primitive>Method(JNIEnv*, jobject, jmethodID, ...);
    ```

*   这些方法的变体存在一个`A`和`V`后缀。行为是相同的，除了分别使用`va_list`(即变量参数列表)或`jvalue`数组(`jvalue`是所有 JNI 类型的并集)指定参数:

    ```cpp
    jobject CallObjectMethodV(JNIEnv*, jobject, jmethodID, va_list);
    jobject CallObjectMethodA(JNIEnv*, jobject, jmethodID, jvalue*);
    ```

看看安卓 NDK `include`目录中的`jni.h`，看看 JNI 反射 API 带来的所有可能性。

## 调试 JNI

JNI 通话的目标往往是性能。因此，当调用其 API 方法时，JNI 不会执行高级检查。希望有一个**扩展检查**模式，它在安卓日志中执行高级检查并给出反馈。

要激活它，请从命令提示符运行以下命令:

```cpp
adb shell setprop debug.checkjni 1

```

扩展检查模式适用于设置该标志后启动的应用程序，直到设置为`0`或设备重新启动。对于根设备，可以使用以下命令在此模式下启动整个设备:

```cpp
adb shell stop
adb shell setprop dalvik.vm.checkjni true
adb shell start

```

如果一切正常，当您的应用程序启动时，Logcat 中会出现一条消息**延迟启用–xccheck:JNI**。然后，定期检查日志以发现其 JNI 警告或错误。

![Debugging JNI](graphics/9645_04_04.jpg)

## 同步 Java 和本机线程

并行编程是如今的主流学科。自多核处理器推出以来，安卓也不例外。您可以完全在 Java 端(使用 Java 线程和并发 API)、本机端(使用 NDK 提供的 **POSIX PThread** API)以及更有趣的是，使用 JNI 在 Java 和本机端之间执行线程。

在这一部分，我们将创建一个后台线程，观察者，它持续关注数据存储中的内容。它遍历所有条目，然后休眠一段固定的时间。当观察线程发现代码中预定义的特定类型的键时，它会相应地采取行动。对于第一部分，我们将把整数值裁剪到一个预定义的范围内。

当然，线程需要同步。只有当用户理解用户界面线程，并且不修改它时，本机线程才会访问和更新存储。本机线程是用 C/C++ 创建的，但用户界面线程是一个 Java 线程。我们将使用 JNI 监视器来同步它们。

# 行动时间-用 JNI 分配对象

让我们定义一个后台观察器，它将使用 Java 和 C/C++ 之间共享的一个对象作为锁:

1.  在`Store.java`中，添加两个新方法来启动和停止一个观察器线程。这些方法分别返回一个`long`作为参数。这个值帮助我们在 Java 端持有一个本机指针:

    ```cpp
    public class Store implements StoreListener {
        ...
        public native long startWatcher();
     public native void stopWatcher(long pPointer);
    }
    ```

2.  创建新文件，`StoreThreadSafe.java`。`StoreThreadSafe`类继承自`Store`类，旨在使用`synchronized` Java 块使`Store`实例线程安全。声明类型为`Object`的静态成员字段`LOCK`，并定义默认构造函数:

    ```cpp
    package com.packtpub.store;

    import com.packtpub.exception.InvalidTypeException;
    import com.packtpub.exception.NotExistingKeyException;

    public class StoreThreadSafe extends Store {
        protected static Object LOCK;

        public StoreThreadSafe(StoreListener pListener) {
            super(pListener);
        }
        ...
    ```

3.  使用与`LOCK`对象同步的 Java 块覆盖方法，如`getCount()`、`getInteger()`和`setInteger()`:

    ```cpp
        ...
        @Override
        public int getCount() {
            synchronized (LOCK) {
                return super.getCount();
            }
        }
        ...
        @Override
        public int getInteger(String pKey)
            throws NotExistingKeyException, InvalidTypeException
        {
            synchronized (LOCK) {
                return super.getInteger(pKey);
            }
        }

        @Override
        public void setInteger(String pKey, int pInt) {
            synchronized (LOCK) {
                super.setInteger(pKey, pInt);
            }
        }
        ...
    ```

4.  Do the same for all other methods, such as `getString()`, `setString()`, `getColor()`, `setColor()`, etc., and the `stopWatcher()` method. Do not override the `onSuccess` callbacks and the `startWatcher()` method:

    ```cpp
        ...
        @Override
        public void stopWatcher(long pPointer) {
            synchronized (LOCK) {
                super.stopWatcher(pPointer);
            }
        }
    }
    ```

    不要让*超越`onSuccess`回调和`startWatcher()`方法。*

5.  打开`StoreActivity.java`，用`StoreThreadSafe`的实例替换之前的`Store`实例。另外，创建一个类型为`long`的成员字段来保存指向观察器线程的本机指针。当片段恢复时，启动观察线程并保存其指针。当片段暂停时，用先前保存的指针停止观察线程:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment
        implements StoreListener {
            private StoreThreadSafe mStore = new StoreThreadSafe(this);
     private long mWatcher;
            private EditText mUIKeyEdit, mUIValueEdit;
            private Spinner mUITypeSpinner;
            private Button mUIGetButton, mUISetButton;
            private Pattern mKeyPattern;

            ...
     @Override
     public void onResume() {
     super.onResume();
     mWatcher = mStore.startWatcher();
     }
     @Override
     public void onPause() {
     super.onPause();
     mStore.stopWatcher(mWatcher);
            }
            ...
        }
    }
    ```

6.  编辑`jni/Store.h`并添加新标题`pthread.h` :

    ```cpp
    #ifndef _STORE_H_
    #define _STORE_H_

    #include <cstdint>
    #include <pthread.h>
    #include "jni.h"
    ```

7.  观察者在定期更新的`Store`实例上工作。它需要:
    *   它观察的`Store`结构的实例
    *   一个`JavaVM`，它是线程间唯一可以安全共享的对象，并且`JNIEnv`可以从其中安全检索
    *   要同步的 Java 对象(对应于我们在 Java 端定义的`LOCK`对象)
    *   一个专用于本机线程管理的`pthread` 变量
    *   停止观察线程的指示器

        ```cpp
        ...
        typedef struct { 
         Store* mStore; 
         JavaVM* mJavaVM; 
         jobject mLock; 
         pthread_t mThread; 
         int32_t mRunning; 
        } StoreWatcher;
        ...
        ```

8.  最后，定义三种方法来启动和停止观察线程，运行它的主循环，并处理一个条目:

    ```cpp
    ...
    StoreWatcher* startWatcher(JavaVM* pJavaVM, Store* pStore, 
     jobject pLock); 
    void stopWatcher(StoreWatcher* pWatcher); 
    void* runWatcher(void* pArgs); 
    void processEntry(StoreEntry* pEntry);
    #endif
    ```

9.  Refresh the JNI header file `jni/com_packtpub_Store.h` with `javah`. You should see two new methods, `Java_com_packtpub_store_Store_startWatcher()` and `Java_com_packtpub_store_Store_stopWatcher()`, in it.

    在`com_packtpub_store_Store.cpp`中，创建一个新的静态变量`gLock`，用于保存 Java 同步对象。

    ```cpp
    ...
    static Store gStore;
    static jobject gLock;
    ...
    ```

10.  使用 JNI 反射应用编程接口在`JNI_OnLoad()`中创建`Object`类的实例:
    *   首先用`GetMethodID()`找到它的`Object`构造函数。JNI 的施工人员被命名为`<init>`，没有结果。
    *   然后，调用构造函数创建一个实例并使其成为全局的。
    *   最后，删除本地引用，当它们变得无用时:

        ```cpp
        JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
            JNIEnv *env;
            if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
                abort();
            }
            ...
         jclass ObjectClass = env->FindClass("java/lang/Object");
         if (ObjectClass == NULL) abort();
         jmethodID ObjectConstructor = env->GetMethodID(ObjectClass,
         "<init>", "()V");
         if (ObjectConstructor == NULL) abort();
         jobject lockTmp = env->NewObject(ObjectClass, ObjectConstructor);
         env->DeleteLocalRef(ObjectClass);
         gLock = env->NewGlobalRef(lockTmp);
         env->DeleteLocalRef(lockTmp);
            ...
        ```

11.  将创建的`Object`实例保存在`StoreThreadSafe.LOCK`字段中。该对象将在应用程序的生存期内用于同步:
    *   首先，使用 JNI 反射方法`FindClass()`和`GetStaticFieldId()`检索`StoreThreadSafe`类及其`LOCK`字段
    *   然后，使用 JNI 方法`SetStaticObjectField()`将该值保存到`LOCK`静态字段中，这需要字段签名(如方法)
    *   最后，当`StoreThreadSafe`类变得无用时，移除对它的局部引用:

        ```cpp
            ...
         jclass StoreThreadSafeClass = env->FindClass(
         "com/packtpub/store/StoreThreadSafe");
         if (StoreThreadSafeClass == NULL) abort();
         jfieldID lockField = env->GetStaticFieldID(StoreThreadSafeClass,
         "LOCK", "Ljava/lang/Object;");
         if (lockField == NULL) abort();
         env->SetStaticObjectField(StoreThreadSafeClass, lockField, gLock);
         env->DeleteLocalRef(StoreThreadSafeClass);

            return JNI_VERSION_1_6;
        }
        ...
        ```

12.  实现`startWatcher()`，调用前面定义的对应方法。它需要`JavaVM`，可以用`GetJavaVM()`从`JNIEnv`对象中检索。指向所创建的`Store`的指针(即内存地址)作为`long`值返回给 Java 端，然后 Java 端可以存储它以供更改使用:

    ```cpp
    ...
    JNIEXPORT jlong JNICALL Java_com_packtpub_store_Store_startWatcher
      (JNIEnv *pEnv, jobject pThis) {
        JavaVM* javaVM;
        // Caches the VM.
        if (pEnv->GetJavaVM(&javaVM) != JNI_OK) abort();

        // Launches the background thread.
        StoreWatcher* watcher = startWatcher(javaVM, &gStore, gLock);
        return (jlong) watcher;
    }
    ...
    ```

13.  通过实现`stopWatcher()`终止，这将给定的`long`值转换回本机指针。传给对应的方法:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_stopWatcher
      (JNIEnv *pEnv, jobject pThis, jlong pWatcher) {
        stopWatcher((StoreWatcher*) pWatcher);
    }
    ```

## *刚刚发生了什么？*

我们使用 JNI 从本机代码中分配一个 Java 对象，并将其保存在静态 Java 字段中。这个例子展示了 JNI 反射应用编程接口的强大功能；几乎任何可以用 Java 完成的事情，都可以用 JNI 的原生代码来完成。

为了分配 Java 对象，JNI 提供了以下方法:

*   `NewObject()`到使用指定的构造函数方法实例化一个 Java 对象:

    ```cpp
    jobject NewObject(jclass clazz, jmethodID methodID, ...)
    ```

*   这种方法的变体存在一个`A`和`V`后缀。行为是相同的，除了分别使用`va_list`或`jvalue`数组指定参数:

    ```cpp
    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)
    jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)
    ```

*   `AllocObject()`分配一个新对象，但不调用其构造函数。一种可能的用法是分配许多对象，这不需要初始化来获得一些性能增益。只有在你知道自己在做什么的情况下才能使用:

    ```cpp
    jobject AllocObject(jclass clazz)
    ```

在前一章中，我们为本机存储使用了静态变量，因为它的生命周期与应用程序相关联。我们希望在应用程序退出之前记住值。如果用户离开活动，稍后再返回活动，则在流程保持活动状态时，值仍然可用。

对于观察者线程，我们使用了不同的策略，因为它的生命周期与活动相关联。当活动获得焦点时，线程被创建并启动。当活动失去焦点时，线程被停止并销毁。由于此线程可能需要时间来停止，因此可能会同时出现几次(如果您在`Store`示例中多次快速转动屏幕)。

因此，使用静态变量是不安全的，因为它可能被同时覆盖(导致内存泄漏)，或者更糟的是，被释放(导致内存损坏)。当一个活动开始另一个活动时，这些问题也会出现。在这种情况下，第一个活动的`onStop()`和`onDestroy()`出现在第二个活动的`onCreate()`和`onStart()`之后，这在安卓活动生命周期中进行了定义。

相反，处理这种情况的更好的解决方案是允许 Java 端管理本机内存。在我们的示例中，指向在本机端分配的本机结构的指针作为`long`值返回到 Java 端。任何进一步的 JNI 调用都必须以这个指针作为参数来执行。当这段数据的生命周期结束时，这个指针可以返回到本机端。

### 类型

使用`long`值(以 64 位表示)保存本机指针是必要的，以便与安卓棒棒糖附带的 64 位版本的安卓系统(具有 64 位内存地址)保持兼容。

总而言之，小心使用本机静态变量。如果您的变量与应用程序生命周期相关联，静态变量也可以。如果您的变量与活动生命周期相关联，您应该在活动中分配它们的一个实例，并从那里管理它们以避免问题。

现在我们在 Java 和本地端之间有了一个共享锁，让我们通过实现 Watcher 线程来继续我们的例子。

# 行动时间–运行和同步线程

让我们使用 POSIX PThread API 创建一个本机线程，并将其附加到虚拟机上:

1.  In `Store.cpp`, include `unistd.h`, which gives access to the `sleep()` function:

    ```cpp
    #include "Store.h"
    #include <cstdlib>
    #include <cstring>
    #include <unistd.h>
    ...
    ```

    执行`startWatcher()`。此方法从用户界面线程执行。为此，首先实例化并初始化一个`StoreWatcher`结构。

2.  Then, initialize and launch a native thread with the `pthread` POSIX API:

    ```cpp
    StoreWatcher* startWatcher(JavaVM* pJavaVM, Store* pStore,
            jobject pLock) {
        StoreWatcher* watcher = new StoreWatcher();
        watcher->mJavaVM = pJavaVM;
        watcher->mStore = pStore;
        watcher->mLock = pLock;
        watcher->mRunning = true;
    ...
    ```

    然后，使用 PThread POSIX API 初始化并启动一个本机线程:

    *   `pthread_attr_init()`初始化必要的数据结构
    *   `pthread_create()`启动螺纹

        ```cpp
        ...
            pthread_attr_t lAttributes;
            if (pthread_attr_init(&lAttributes)) abort();
            if (pthread_create(&watcher->mThread, &lAttributes,
                                    runWatcher, watcher)) abort();
            return watcher;
        }
        ...
        ```

3.  执行`stopWatcher()`，关闭运行指示灯，请求观察线程停止:

    ```cpp
    ...
    void stopWatcher(StoreWatcher* pWatcher) { 
        pWatcher->mRunning = false; 
    } 
    ...
    ```

4.  在`runWatcher()`中执行线程的主循环。在这里，我们不再在 UI 线程上，而是在观察者线程上。
    *   首先，使用`AttachCurrentThreadAsDaemon()`将线程作为守护进程附加到达尔维克虚拟机。该操作从给定的`JavaVM`返回`JNIEnv`。这让我们可以从这个新线程直接访问 Java 端。请记住`JNIEnv`是特定于线程的，不能在线程之间直接共享。
    *   然后，使用`sleep()` :

        ```cpp
        ...
        void* runWatcher(void* pArgs) {
            StoreWatcher* watcher = (StoreWatcher*) pArgs;
            Store* store = watcher->mStore;

            JavaVM* javaVM = watcher->mJavaVM;
            JavaVMAttachArgs javaVMAttachArgs;
            javaVMAttachArgs.version = JNI_VERSION_1_6;
            javaVMAttachArgs.name = "NativeThread";
            javaVMAttachArgs.group = NULL;

            JNIEnv* env;
            if (javaVM->AttachCurrentThreadAsDaemon(&env,
                    &javaVMAttachArgs) != JNI_OK) abort();
            // Runs the thread loop.
            while (true) {
                sleep(5); // In seconds.
                    ...
        ```

        进行这个线程循环，并在每次迭代中小睡几秒钟
5.  While in a loop iteration, delimit a critical section (where only one thread can go at the same time) with JNI methods `MonitorEnter()` and `MonitorExit()`. These methods require an object to synchronize on (like a `synchronized` block in Java).

    然后，您可以放心地:

    *   检查线程是否应该停止，并在这种情况下退出循环
    *   处理来自商店的每个条目

        ```cpp
                    ...
                // Critical section beginning, one thread at a time.
                // Entries cannot be added or modified.
                env->MonitorEnter(watcher->mLock);
                if (!watcher->mRunning) break;
                StoreEntry* entry = watcher->mStore->mEntries;
                StoreEntry* entryEnd = entry + watcher->mStore->mLength;
                while (entry < entryEnd) {
                    processEntry(entry);
                    ++ entry;
                }
                // Critical section end.
                env->MonitorExit(watcher->mLock);
            }
            ...
        ```

    在退出之前，在线程将要结束并退出时将其分离。始终分离一个附加的线程是非常重要的，这样 Dalvik 或 ART 虚拟机就可以停止管理它。

6.  最后，使用`pthread_exit()` API 方法

    ```cpp
        ...
        javaVM->DetachCurrentThread();
        delete watcher;
        pthread_exit(NULL);
    }
    ...
    ```

    终止线程
7.  最后写 `processEntry()`方法，无非是检查整数条目的边界，限制在任意范围`[-100000,100000]`内。您也可以处理您希望的任何其他条目:

    ```cpp
    ...
    void processEntry(StoreEntry* pEntry) {
        switch (pEntry->mType) {
        case StoreType_Integer:
            if (pEntry->mValue.mInteger > 100000) {
                pEntry->mValue.mInteger = 100000;
            } else if (pEntry->mValue.mInteger < -100000) {
                pEntry->mValue.mInteger = -100000;
            }
            break;
        }
    }
    ```

## *刚刚发生了什么？*

使用 Eclipse Java 调试器(不是本机调试器)在调试模式下编译和运行应用程序。当应用程序启动时，一个本地后台线程被创建并附加到达尔维克虚拟机。您可以在**调试**视图中看到。然后，用户界面线程和本地后台线程与 JNI 监视器应用编程接口一起同步，以正确处理并发问题。最后，当离开应用程序时，后台线程被分离和销毁。因此，它从**调试**视图中消失了:

![What just happened?](graphics/9645_04_02.jpg)

现在，从你的安卓设备上的`Store`界面，定义一个键，输入一个大于`100,000`的整数值。等待几秒钟，然后使用相同的键检索该值。它应该看起来被守望者的线夹住了`100,000`。该观察器查找存储中的每个值，并在需要时进行更改。

观察器运行在本地线程上(也就是说，不是由 Java 虚拟机直接创建的)。NDK 允许使用 PThread POSIX 应用编程接口创建本机线程。这个 API 是 Unix 系统上常用的多线程标准。它定义了一组函数和数据结构，都以`pthread_`为前缀，不仅创建线程，还创建**互斥体**(其中代表互斥)或**条件** **变量**(使线程等待特定条件)。

PThread API 本身就是一个完整的主题，不在本书的讨论范围之内。你需要知道它才能在安卓系统上掌握本机多线程。更多关于这个主题的信息，请看[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)和[http://randu.org/tutorials/threads/](http://randu.org/tutorials/threads/)。

## 将 Java 和 C/C++ 与 JNI 监视器同步

在 Java 端，我们使用任意的锁对象来同步线程。Java 也允许方法成为`synchronized`，不管是不是本地的。在这种情况下，锁定对象隐式地是对象，在其上定义了本机方法。例如，我们可以如下定义一个本机方法:

```cpp
public class MyNativeClass {
 public native synchronized int doSomething();
    ...
}
```

这在我们的例子中是行不通的，因为在本地端只有一个静态的存储实例。我们需要锁对象的一个静态实例。

### 注

请注意，这里使用的模式，即使`StoreThreadSafe`从`Store`类继承，重写其方法并使用静态变量，不应被特别认为是最佳实践。因为`Store`和`lock`对象是静态的，所以在本书中为了简单起见使用了它。

在本机端，使用 JNI 监视器执行同步，这相当于 Java 中的`synchronized`关键字:

*   `MonitorEnter()`划定临界区的起点。监视器与一个对象相关联，该对象可以被视为一种标识符。一次只能有一个线程进入该对象定义的部分:

    ```cpp
    jint MonitorEnter(jobject obj)
    ```

*   `MonitorExit()`划定临界区的终点。必须和`MonitorEnter()`一起调用，确保显示器释放，其他线程可以走:

    ```cpp
    jint MonitorExit(jobject obj)
    ```

因为 Java 线程在内部是基于 POSIX 原语的，所以也可以使用 POSIX API 完全在本地实现线程同步。你可以在[https://computing.llnl.gov/tutorials/pthreads/](https://computing.llnl.gov/tutorials/pthreads/)找到更多关于它的信息。

### 类型

Java 和 C/C++ 是不同的语言，语义相似，但有些不同。因此，始终注意不要期望 C/C++ 的行为像 T2 Java。例如， volatile 在 Java 和 C/C++ 中有不同的语义，因为两者遵循不同的内存模型。

## 附加和分离本机线程

默认情况下， Dalvik VM 不知道在同一个进程中运行的本机线程。作为回报，本机线程也不能访问虚拟机...除非它附在上面。附件在 JNI 通过以下方法处理:

*   `AttachCurrentThread()`告诉 VM 管理当前线程。连接后，当前线程的指针返回到指定位置:

    ```cpp
    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)
    ```

*   `AttachCurrentThreadAsDaemon()`附加一个线程作为守护进程。Java 规范定义了 JVM 在离开之前不必等待守护线程退出，这与普通线程相反。这种区别在安卓上没有真正的意义，因为一个应用可以随时被系统杀死:

    ```cpp
    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)
    ```

*   `DetachCurrentThread()` indicates to the VM that a thread does not need to be managed anymore. An attached thread like the Watcher thread must be eventually unattached before exiting. Dalvik detects threads that are not detached and reacts by aborting and leaving a dirty crash dump in your logs! When getting detached, any monitor held is released, and any waiting thread is notified:

    ```cpp
    jint DetachCurrentThread()
    ```

    ### 类型

    从安卓 2.0 开始，一种确保线程被系统分离的技术是将析构函数回调绑定到带有`pthread_key_create()`的本地线程，并在其中调用`DetachCurrentThread()`。一个`JNIEnv`实例可以用`pthread_setspecific()`保存到线程本地存储中，作为一个参数传递给析构函数。

附加线程后，**类加载器** JNI 使用 Java 类来对应它在调用栈上找到的第一个对象。对于纯本机线程，可能找不到`ClassLoader`。在这种情况下，JNI 使用的系统`ClassLoader`，可能找不到自己的应用类，也就是`FindClass()`失败。在这种情况下，要么在`JNI_OnLoad()`中全局缓存必要的 JNI 元素，要么与需要的线程共享一个应用程序类加载器。

# 本机处理位图

安卓 NDK 提出了一个专用于位图处理的应用编程接口，可以直接访问安卓位图的表面。这个应用编程接口是安卓专用的，与 JNI 规范无关。然而，位图是 Java 对象，需要在本机代码中这样对待。

为了更具体地了解如何从本机代码中修改位图，让我们尝试从本机代码中解码相机馈送。在安卓系统上录制的原始视频帧通常以特定的格式编码， **YUV** ，这与经典的 RGB 图像不兼容。在这种情况下，本地代码来帮助我们解码这样的图像。在下面的示例中，我们将把每个颜色分量(即红色、绿色和蓝色)提取到一个单独的位图中。

### 注

由此产生的项目以`LiveCamera`的名称提供本书。

# 行动时间——解码摄像头的视频

让我们编写必要的 Java 代码，在一个全新的项目中记录和显示图片:

1.  创建新的混合 Java/C++ 项目，如[第 2 章](02.html "Chapter 2. Starting a Native Android Project")、*启动原生安卓项目*所示:
    *   命名为`LiveCamera`
    *   主要包装是`com.packtpub.livecamera`
    *   主要活动是`LiveCameraActivity`
    *   主要活动布局名称为`activity_livecamera`
    *   使用**空白活动**模板
2.  创建后，将项目转换为已经看到的原生项目。在`AndroidManifest.xml`文件中，请求对摄像机的访问权限。然后，将活动样式设置为`fullscreen`，方向设置为`landscape`。横向定位避免了大多数在安卓设备上遇到的摄像头定位问题:

    ```cpp
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.packtpub.livecamera"
      android:versionCode="1" android:versionName="1.0" >
      <uses-sdk android:minSdkVersion="14" android:targetSdkVersion="19"/>
     <uses-permission android:name="android.permission.CAMERA" />
      <application
        android:allowBackup="false"
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <activity
          android:name=".LiveCameraActivity"
          android:label="@string/app_name"
          android:screenOrientation="landscape"
     android:theme="@android:style/Theme.NoTitleBar.Fullscreen" >
          <intent-filter>
            <action android:name="android.intent.action.MAIN" />
            <category android:name="android.intent.category.LAUNCHER" />
          </intent-filter>
        </activity>
      </application>
    </manifest>
    ```

3.  定义 `activity_livecamera.xml`布局如下。它代表一个 2x2 网格，包含一个`TextureView`和三个`ImageView`元素:

    ```cpp
    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout 
      xmlns:a="http://schemas.android.com/apk/res/android"
      a:baselineAligned="true" a:orientation="horizontal"
      a:layout_width="fill_parent" a:layout_height="fill_parent" >
      <LinearLayout
        a:layout_width="fill_parent" a:layout_height="fill_parent"
        a:layout_weight="1" a:orientation="vertical" >
        <TextureView
          a:id="@+id/preview" a:layout_weight="1"
          a:layout_width="fill_parent" a:layout_height="fill_parent" />
        <ImageView
          a:id="@+id/imageViewR" a:layout_weight="1"
          a:layout_width="fill_parent" a:layout_height="fill_parent" />
      </LinearLayout>
      <LinearLayout
        a:layout_width="fill_parent" a:layout_height="fill_parent"
        a:layout_weight="1" a:orientation="vertical" >
        <ImageView
          a:id="@+id/imageViewG" a:layout_weight="1"
          a:layout_width="fill_parent" a:layout_height="fill_parent" />
        <ImageView
          a:id="@+id/imageViewB" a:layout_weight="1"
          a:layout_width="fill_parent" a:layout_height="fill_parent" />
      </LinearLayout>
    </LinearLayout>
    ```

4.  Open `LiveCameraActivity.java` and implement it as follows:
    *   首先，扩展`SurfaceTextureListener`，这将帮助我们初始化并关闭摄像头进给
    *   然后，扩展`PreviewCallback`界面，监听新的摄像头帧

    不要忘记加载本机静态库，如下所示:

    ```cpp
    package com.packtpub.livecamera;
    ...
    public class LiveCameraActivity extends Activity implements
    TextureView.SurfaceTextureListener, Camera.PreviewCallback {
        static {
            System.loadLibrary("livecamera");
        }
        ...
    ```

5.  Create a few member variables:
    *   `mCamera`是安卓相机 API
    *   `mTextureView`显示原始摄像机输入
    *   `mVideoSource`将摄像机帧捕获到一个字节缓冲区中
    *   `mImageViewR`、`G`和`B`显示处理后的图像，每个颜色分量一个图像
    *   `mImageR`、`G`和`B`是支持`ImageView`(“后台缓冲区”)

        ```cpp
            ...
            private Camera mCamera;
            private TextureView mTextureView;
            private byte[] mVideoSource;
            private ImageView mImageViewR, mImageViewG, mImageViewB;
            private Bitmap mImageR, mImageG, mImageB;
            ...
        ```

        的位图

    在`onCreate()`中，指定上一步定义的布局。

    然后，检索视图以显示图像。

6.  最后，用`setSurfaceTextureListener()`收听`TextureView`事件。您可以忽略一些在本例中不必要的回调:

    ```cpp
        ...
        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_livecamera);
            mTextureView = (TextureView) findViewById(R.id.preview);
            mImageViewR = ((ImageView)findViewById(R.id.imageViewR));
            mImageViewG = ((ImageView)findViewById(R.id.imageViewG));
            mImageViewB = ((ImageView)findViewById(R.id.imageViewB));

            mTextureView.setSurfaceTextureListener(this);
        }
        @Override
        public void onSurfaceTextureSizeChanged(SurfaceTexture pSurface,
           int pWidth, int pHeight) {}

        @Override
        public void onSurfaceTextureUpdated(SurfaceTexture pSurface) {}
        ...
    ```

7.  The `onSurfaceTextureAvailable()` callback in `LiveCameraActivity.java` is triggered after the `TextureView` surface is created. This is the place where surface dimensions and pixel formats get known.

    于是，打开安卓摄像头，将`TextureView`设置为其预览目标。使用`setPreviewCallbackWithBuffer()`收听新的摄像机画面:

    ```cpp
        ...
        @Override
        public void onSurfaceTextureAvailable(SurfaceTexture pSurface,
                                              int pWidth, int pHeight) {
            mCamera = Camera.open();
            try {
                mCamera.setPreviewTexture(pSurface);
                mCamera.setPreviewCallbackWithBuffer(this);
                // Sets landscape mode to avoid complications related to
                // screen orientation handling.
                mCamera.setDisplayOrientation(0);
                ...
    ```

8.  然后，调用`findBestResolution()`，接下来我们将实现它来为相机馈送找到合适的分辨率。使用`YCbCr_420_SP`格式相应地设置后者(这应该是安卓系统上的默认值)。

    ```cpp
                ...
                Size size = findBestResolution(pWidth, pHeight);
                PixelFormat pixelFormat = new PixelFormat();
                PixelFormat.getPixelFormatInfo(mCamera.getParameters()
                                .getPreviewFormat(), pixelFormat);
                int sourceSize = size.width * size.height
                                * pixelFormat.bitsPerPixel / 8;
                // Set-up camera size and video format.
                // should be the default on Android anyway.
                Camera.Parameters parameters = mCamera.getParameters();
                parameters.setPreviewSize(size.width, size.height);
                parameters.setPreviewFormat(PixelFormat.YCbCr_420_SP);
                mCamera.setParameters(parameters);
                ...
    ```

9.  After that, set up the video buffer and the bitmaps that display camera frames:

    ```cpp
                ...
                mVideoSource = new byte[sourceSize];
                mImageR = Bitmap.createBitmap(size.width, size.height,
                                              Bitmap.Config.ARGB_8888);
                mImageG = Bitmap.createBitmap(size.width, size.height,
                                              Bitmap.Config.ARGB_8888);
                mImageB = Bitmap.createBitmap(size.width, size.height,
                                              Bitmap.Config.ARGB_8888);
                mImageViewR.setImageBitmap(mImageR);
                mImageViewG.setImageBitmap(mImageG);
                mImageViewB.setImageBitmap(mImageB);
                ...
    ```

    最后，将视频帧缓冲区入队并开始相机预览:

    ```cpp
                ...
                mCamera.addCallbackBuffer(mVideoSource);
                mCamera.startPreview();
            } catch (IOException ioe) {
                mCamera.release();
                mCamera = null;
                throw new IllegalStateException();
            }
        }
        ...
    ```

10.  还在`LiveCameraActivity.java`，执行`findBestResolution()`。安卓相机可以支持各种分辨率，这高度依赖于设备。由于默认分辨率没有规定，我们需要寻找一个合适的分辨率。这里，我们选择适合显示表面的最大分辨率，如果找不到，则选择默认分辨率。

    ```cpp
        ...
        private Size findBestResolution(int pWidth, int pHeight) {
            List<Size> sizes = mCamera.getParameters()
                            .getSupportedPreviewSizes();
            // Finds the biggest resolution which fits the screen.
            // Else, returns the first resolution found.
            Size selectedSize = mCamera.new Size(0, 0);
            for (Size size : sizes) {
                if ((size.width <= pWidth)
                 && (size.height <= pHeight)
                 && (size.width >= selectedSize.width)
                 && (size.height >= selectedSize.height)) {
                    selectedSize = size;
                }
            }
            // Previous code assume that there is a preview size smaller
            // than screen size. If not, hopefully the Android API
            // guarantees that at least one preview size is available.
            if ((selectedSize.width == 0) || (selectedSize.height == 0)) {
                selectedSize = sizes.get(0);
            }
            return selectedSize;
        }
    ...
    ```

11.  在`onSurfaceTextureDestroyed()`中`TextureView`曲面被破坏时释放相机，因为它是共享资源。位图缓冲区也可以回收和无效，以减轻垃圾收集器的工作。

    ```cpp
    ...
        @Override
        public boolean onSurfaceTextureDestroyed(SurfaceTexture pSurface)
        {
            // Releases camera which is a shared resource.
            if (mCamera != null) {
                mCamera.stopPreview();
                mCamera.release();
                // These variables can take a lot of memory. Get rid of
                // them as fast as we can.
                mCamera = null;
                mVideoSource = null;
                mImageR.recycle(); mImageR = null;
                mImageG.recycle(); mImageG = null;
                mImageB.recycle(); mImageB = null;
            }
            return true;
        }
    ...
    ```

12.  Finally, decode raw video frames in `onPreviewFrame()`. This handler is triggered by the `Camera` class each time a new frame is ready.

    原始视频字节与背景位图和用于选择每个颜色分量的过滤器一起被传递给本机方法`decode()`。

    解码后，使曲面无效以重新绘制。

    最后，将原始视频缓冲区“重新排队”以请求捕获新的视频帧。

    ```cpp
    ...
        @Override
        public void onPreviewFrame(byte[] pData, Camera pCamera) {
            // New data has been received from camera. Processes it and
            // requests surface to be redrawn right after.
            if (mCamera != null) {
                decode(mImageR, pData, 0xFFFF0000);
                decode(mImageG, pData, 0xFF00FF00);
                decode(mImageB, pData, 0xFF0000FF);
                mImageViewR.invalidate();
                mImageViewG.invalidate();
                mImageViewB.invalidate();

                mCamera.addCallbackBuffer(mVideoSource);
            }
        }

        public native void decode(Bitmap pTarget, byte[] pSource,
                                  int pFilter);
    }
    ```

## *刚刚发生了什么？*

多亏了安卓相机应用编程接口，我们从设备的相机中捕捉到了实时图像。在设置了相机捕捉格式和定义后，我们创建了所有必要的捕捉缓冲区和输出图像来显示在屏幕上。当应用程序需要一个新帧时，捕获被保存在一个由应用程序排队的缓冲区中。然后，给这个缓冲区一个本机方法的位图，我们将在下一节中写它。最后，输出图像显示在屏幕上。

视频馈送是以 YUV NV21 格式编码的。YUV 是一种彩色格式，最初是在电子设备的旧时代发明的，目的是使黑白视频接收器与彩色传输兼容，现在仍然普遍使用。安卓规范保证默认帧格式为安卓系统上的 **YCbCr 420 SP** (或 **NV21** )。

### 类型

虽然 YCbCr 420 SP 是安卓系统上默认的视频格式，但是模拟器只支持 YCbCr 422 SP。这个缺陷应该不会引起太多麻烦，因为它基本上是交换颜色的。这个问题不应该出现在真实设备上。

现在，我们的实时图像被捕获，让我们在原生端处理它。

# 行动时间-使用位图应用编程接口处理图片

让我们继续我们的应用，通过颜色通道在原生端解码和过滤图像:

1.  Create native C source, `jni/CameraDecoder.c` (not a C++ file, so that we can see the difference with JNI code written in C++).

    包括`android/bitmap.h`，定义了 NDK 位图处理 API 和`stdlib.h`(不是本文件用 C 写的`cstdlib`):

    ```cpp
    #include <android/bitmap.h>
    #include <stdlib.h>
    ...
    ```

    写几个实用宏来帮助解码视频。

    *   `toInt()`将一个 jbyte 转换为整数，用掩码擦除所有无用的位
    *   `max()`获取两个值之间的最大值
    *   `clamp()`将一个值限制在一个定义的区间内
    *   `color()`从每个颜色成分中构建 ARGB 颜色

        ```cpp
        ...
        #define toInt(pValue) \
            (0xff & (int32_t) pValue)
        #define max(pValue1, pValue2) \
            (pValue1 < pValue2) ? pValue2 : pValue1
        #define clamp(pValue, pLowest, pHighest) \
            ((pValue < 0) ? pLowest : (pValue > pHighest) ? pHighest : pValue)
        #define color(pColorR, pColorG, pColorB) \
            (0xFF000000 | ((pColorB << 6)  & 0x00FF0000) \
                        | ((pColorG >> 2)  & 0x0000FF00) \
                        | ((pColorR >> 10) & 0x000000FF))
        ...
        ```

2.  Implement the native method `decode()`.

    首先，检索位图信息并检查其像素格式是否为 32 位 RGBA。然后，锁定它以允许绘图操作。

    之后，访问作为 Java 字节数组传递的输入视频帧内容，其`GetPrimitiveArrayCritical()`:

    ```cpp
    ...
    void JNICALL decode(JNIEnv * pEnv, jclass pClass, jobject pTarget,
            jbyteArray pSource, jint pFilter) {
        // Retrieves bitmap information and locks it for drawing.
        AndroidBitmapInfo bitmapInfo;
        uint32_t* bitmapContent;
        if (AndroidBitmap_getInfo(pEnv,pTarget, &bitmapInfo) < 0) abort();
        if (bitmapInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) abort();
        if (AndroidBitmap_lockPixels(pEnv, pTarget,
                (void**)&bitmapContent) < 0) abort();

        // Accesses source array data.
        jbyte* source = (*pEnv)->GetPrimitiveArrayCritical(pEnv,
                pSource, 0);
        if (source == NULL) abort();
        ...
    ```

3.  Decode the raw video frame into the output bitmap. The video frame is encoded in the YUV format, which is quite different from RGB. The YUV format encodes a color in three components:
    *   一个亮度分量，即颜色的灰度表示。
    *   两个色度分量，编码颜色信息(也称为 **Cb** 和 **Cr** ，因为它们代表蓝色差异和红色差异)。
    *   基于 YUV 颜色的帧格式有很多。这里，我们按照 YCbCr 420 SP(或 NV21)格式转换帧。这种图像帧由一个 8 位 Y 亮度样本的缓冲器组成，随后是交错的 8 位 V 和 U 色度样本的第二个缓冲器。对 VU 缓冲液进行二次采样，这意味着与 Y 样本相比，U 和 V 样本较少(4 Y 样本为 1 个 U 样本和 1 个 V 样本)。以下算法处理每个像素，并使用适当的公式将每个 YUV 像素转换为 RGB(更多信息请参见`http://www.fourcecc.org/fccyvrgb.php`:

        ```cpp
        ...
            int32_t frameSize = bitmapInfo.width * bitmapInfo.height;
            int32_t yIndex, uvIndex, x, y;
            int32_t colorY, colorU, colorV;
            int32_t colorR, colorG, colorB;
            int32_t y1192;

            // Processes each pixel and converts YUV to RGB color.
            // Algorithm originates from the Ketai open source project.
            // See http://ketai.googlecode.com/.
            for (y = 0, yIndex = 0; y < bitmapInfo.height; ++ y) {
                colorU = 0; colorV = 0;
                // Y is divided by 2 because UVs are subsampled vertically.
                // This means that two consecutives iterations refer to the
                // same UV line (e.g when Y=0 and Y=1).
                uvIndex = frameSize + (y >> 1) * bitmapInfo.width;

                for (x = 0; x < bitmapInfo.width; ++ x, ++ yIndex) {
                    // Retrieves YUV components. UVs are subsampled
                    // horizontally too, hence %2 (1 UV for 2 Y).
                    colorY = max(toInt(source[yIndex]) - 16, 0);
                    if (!(x % 2)) {
                        colorV = toInt(source[uvIndex++ ]) - 128;
                        colorU = toInt(source[uvIndex++ ]) - 128;
                    }

                    // Computes R, G and B from Y, U and V.
                    y1192 = 1192 * colorY;
                    colorR = (y1192 + 1634 * colorV);
                    colorG = (y1192 - 833  * colorV - 400 * colorU);
                    colorB = (y1192 + 2066 * colorU);

                    colorR = clamp(colorR, 0, 262143);
                    colorG = clamp(colorG, 0, 262143);
                    colorB = clamp(colorB, 0, 262143);

                    // Combines R, G, B and A into the final pixel color.
                    bitmapContent[yIndex] = color(colorR,colorG,colorB);
                    bitmapContent[yIndex] &= pFilter;
                }
            }
            ...
        ```

    最后，释放之前获取的 Java 字节缓冲区，并解锁后备位图。

    ```cpp
        ...
        (*pEnv)-> ReleasePrimitiveArrayCritical(pEnv,pSource,source,0);
        if (AndroidBitmap_unlockPixels(pEnv, pTarget) < 0) abort();
    }
    ...
    ```

4.  Instead of relying on a naming convention to find native methods, JNI allows native methods to be registered manually in `JNI_OnLoad()`.

    因此，定义一个表来描述本地方法，以注册它们的名称、签名和地址。这里只需要指定`decode()`。

    然后在`JNI_OnLoad()`中，找到声明了原生方法`decode()`的 Java(这里是`LiveCameraActivity`，告诉 JNI 使用`RegisterNatives()`的方法:

    ```cpp
    ...
    static JNINativeMethod gMethodRegistry[] = {
      { "decode", "(Landroid/graphics/Bitmap;[BI)V", (void *) decode }
    };
    static int gMethodRegistrySize = sizeof(gMethodRegistry)
                                   / sizeof(gMethodRegistry[0]);

    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
        JNIEnv *env;
        if ((*pVM)->GetEnv(pVM, (void**) &env, JNI_VERSION_1_6) != JNI_OK)
        { abort(); }

        jclass LiveCameraActivity = (*env)->FindClass(env,
                "com/packtpub/livecamera/LiveCameraActivity");
        if (LiveCameraActivity == NULL) abort();
        (*env)->RegisterNatives(env, LiveCameraActivity,
                gMethodRegistry, 1);
        (*env)->DeleteLocalRef(env, LiveCameraActivity);

        return JNI_VERSION_1_6;
    }
    ```

5.  将`Application.mk` makefile 编写如下:

    ```cpp
    APP_PLATFORM := android-14
    APP_ABI := all
    ```

6.  编写`Android.mk` makefile 如下(链接到`jnigraphics`模块，定义安卓位图 API):

    ```cpp
    LOCAL_PATH := $(call my-dir)

    include $(CLEAR_VARS)

    LOCAL_MODULE    := livecamera
    LOCAL_SRC_FILES := CameraDecoder.c
    LOCAL_LDLIBS    := -ljnigraphics

    include $(BUILD_SHARED_LIBRARY)
    ```

## *刚刚发生了什么？*

编译并运行应用程序。原始视频源显示在左上角，没有任何转换。原始视频帧用本机代码解码，每个颜色通道被提取为三个 Java 位图。这些位图显示在屏幕每个角落的三个`ImageView`元素中。

![What just happened?](graphics/9645_04_03.jpg)

用于解码 YUV 帧的算法源于科泰开源项目，这是一个针对安卓的图像和传感器处理库。详见[http://ketai.googlecode.com/](http://ketai.googlecode.com/)。请注意，YUV 转 RGB 是一个昂贵的操作，可能会成为您的程序中的一个争议点( **RenderScript** ，我们将在[第 10 章](10.html "Chapter 10. Intensive Computing with RenderScript")，*RenderScript 的密集计算*中发现，它可以帮助完成该任务)。

这里呈现的代码远非最佳(解码算法可以优化，视频帧可以用多个缓冲区捕获，内存访问可以减少，代码可以多线程化)，但它概述了如何使用 NDK 本地处理位图。

由于`jnigraphics`模块中定义的安卓 NDK 位图应用编程接口，本机代码可以直接访问位图表面。该应用编程接口可以被认为是 JNI 的安卓专用扩展，它定义了以下方法:

*   `AndroidBitmap_getInfo()`检索位图信息。出现问题时返回值为负，否则`0` :

    ```cpp
    int AndroidBitmap_getInfo(JNIEnv* env, jobject jbitmap,
                              AndroidBitmapInfo* info);
    ```

*   在`AndroidBitmapInfo`结构中检索位图信息，定义如下:

    ```cpp
    typedef struct {
        uint32_t    width;  // Width in pixels
        uint32_t    height; // Height in pixels
        uint32_t    stride; // Number of bytes between each line
        int32_t     format; // Pixel structure (see AndroidBitmapFormat)
        uint32_t    flags;  // Unused for now
    } AndroidBitmapInfo;
    ```

*   `AndroidBitmap_lockPixels()`在处理位图时授予对位图的独占访问权。出现问题时返回值为负，否则`0` :

    ```cpp
    int AndroidBitmap_lockPixels(JNIEnv* env, jobject jbitmap, void** addrPtr);
    ```

*   `AndroidBitmap_unlockPixels()`释放位图上的排他锁。出现问题时返回值为负，否则`0` :

    ```cpp
    int AndroidBitmap_unlockPixels(JNIEnv* env, jobject jbitmap);
    ```

对任何位图的绘制操作系统地分为三个主要步骤:

1.  首先，获取位图表面。
2.  然后，位图像素被修改。这里，视频像素被转换为 RGB 并写入位图表面。
3.  最后，释放位图表面。

位图必须系统地锁定，然后在本地访问时解锁。绘制操作必须在锁定/解锁对之间进行。更多信息请看`bitmap.h`头文件。

## 手动注册本机方法

在我们的商店示例中，`Javah`使用特定的名称和参数约定自动生成了本机方法原型。然后，达尔维克虚拟机可以在运行时通过“猜测”它们的名称来加载它们。然而，这种约定很容易被打破，并且没有运行时的灵活性。希望 JNI 允许您手动注册将要从 Java 调用的本机方法。还有什么地方比`JNI_OnLoad()`更适合做这个呢？

使用以下 JNI 方法进行注册:

```cpp
jint RegisterNatives(jclass clazz, const JNINativeMethod* methods,
                     jint nMethods)
```

*   `jclass`是对托管本机方法的 Java 类的引用。我们将在这一章和下一章看到更多的内容。
*   `methods`是`JNINativeMethod`的数组，T1 是描述要注册的本机方法的结构。
*   `nMethods`表示`methods`数组中描述了多少种方法。

`JNINativeMethod`结构定义如下:

```cpp
typedef struct {
    const char* name;
    const char* signature;
    void*       fnPtr;
} JNINativeMethod;
```

第一个和第二个元素是对应的 Java 方法的`name`和`signature`，第三个参数`fnPtr`，是指向原生端对应方法的指针。这样，您可以摆脱`javah`及其烦人的命名约定，并在运行时选择调用哪个方法。

## C 语言中的 JNI 对 C++ 中的 JNI

NDK 允许用 C(像我们的`LiveCamera`例子)或 C++(像我们的`Store`例子)编写应用程序。JNI 也是。

C 不是一种面向对象的语言，但是 C++ 是。这就是为什么你不像 C++ 那样用 C 写 JNI。在 C 语言中，`JNIEnv`实际上是一个包含函数指针的结构。当然，当`JNIEnv`给你的时候，所有这些指针都是初始化的，这样你就可以有点像对象一样调用它们。然而，这个在面向对象语言中隐含的参数在 C 语言中作为第一个参数给出(在下面的代码中是`env`)。此外，`JNIEnv`需要在第一次运行方法时取消引用:

```cpp
JNIEnv *env = ...;
(*env)->RegisterNative(env, ...); 
```

C++ 代码更加自然和简单。这个参数是隐式的，不需要去引用 `JNIEnv`，因为方法不再声明为函数指针，而是声明为实成员方法:

```cpp
JNIEnv *env = ...;
env->RegisterNative(env, ...); 
```

因此，尽管非常相似，你用 C 写 JNI 代码的方式与你用 C++ 写它的方式并不完全相同。

# 总结

多亏了 JNI，Java 和 C/C++ 可以紧密地集成在一起。安卓现在完全双语了！Java 可以用任何类型的数据或对象调用 C/C++ 代码，本机代码可以回调 Java。

我们还发现了如何使用 JNI 反射应用编程接口从本机代码调用 Java 代码。由于它，几乎任何 Java 操作都可以从本机代码中执行。但是，为了获得最佳性能，必须缓存类、方法或字段描述符。

我们还看到了如何将一个线程附加和分离到虚拟机，以及如何将 Java 和本机线程与 JNI 监视器同步。多线程代码可能是编程中最困难的主题之一。小心行事！

最后，多亏了 JNI，我们还对位图进行了本地处理，并手工解码了一个视频源。然而，从默认的 YUV 格式(根据安卓规范，每个设备都应该支持)到 RGB 需要昂贵的转换。

在安卓系统上处理本地代码时，JNI 几乎总是碍事。它是一个冗长且技术性很强的 API，更不用说繁琐了，需要小心谨慎。它的微妙之处需要整本书才能深入理解。相反，本章为您提供了将自己的 C/C++ 模块集成到自己的 Java 应用程序中的基本知识。

在下一章中，我们将看到如何创建一个完全本机的应用程序，它完全摆脱了 JNI。