# 五、编写完全本机的应用

> *在前几章，我们已经用 JNI 攻破了安卓 NDK 的地表。但是里面还有很多东西要找！NDK 有自己的一套特色，其中之一是“T2”本地活动“T3”。本机活动允许只基于本机代码创建应用，而不需要一行 Java。再也没有 JNI 了！没有更多的参考！再也没有 Java 了！*
> 
> *除了原生活动外，NDK 还带来了一些用于原生访问安卓资源的 API，如**显示窗口**、**资产**、**设备配置**……这些 API 有助于摆脱嵌入原生代码经常需要的曲折的 JNI 桥。尽管还缺少很多，而且不太可能提供(Java 仍然是 GUI 和大多数框架的主要平台语言)，但是多媒体应用是应用它们的完美目标...*

本章介绍了在本书中逐步开发的一个原生 C++ 项目: **DroidBlaster** 。基于自上而下的观点，这个样本滚动射手将具有 2D 图形，稍后，三维图形，声音，输入和传感器管理。在本章中，我们将创建它的基本结构和主要游戏组件。

现在让我们通过以下方式进入安卓 NDK 的核心:

*   创建完全原生的活动
*   处理主要活动事件
*   本机访问显示窗口
*   检索时间和计算延迟

# 创建本地活动

`NativeActivity`类提供了一种工具来最小化创建本地应用所需的工作。它让开发人员摆脱所有的样板代码来初始化和与本机代码通信，并专注于核心功能。这个*胶水*活动是编写应用最简单的方法，比如没有一行 Java 代码的游戏。

### 注

由此产生的项目以`DroidBlaster_Part1`的名称提供本书。

# 行动时间-创建基本的本地活动

我们现在将看到如何创建一个运行事件循环的最小本地活动。

1.  创建一个新的混合 Java/C++ 项目，如[第 2 章](02.html "Chapter 2. Starting a Native Android Project")、*启动原生安卓项目*所示。
    *   命名为`DroidBlaster`。
    *   如前一章所述，将项目转换为原生项目。命名原生模块`droidblaster`。
    *   删除由 ADT 创建的本机源文件和头文件。
    *   删除对**项目属性** | **Java 构建路径** | **来源**中的 Java `src`目录的引用。然后，删除磁盘上的目录本身。
    *   去掉`res/layout`目录中的所有布局。
    *   如果`jni/droidblaster.cpp`已经创建，则将其删除。
2.  In `AndroidManifest.xml`, use `Theme.NoTitleBar.Fullscreen` as the application theme.

    使用元数据属性`android.app.lib_name`声明一个引用名为`droidblaster`的本机模块的`NativeActivity`(也就是我们将要编译的本机库):

    ```cpp
    <?xml version="1.0" encoding="utf-8"?>
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        package="com.packtpub.droidblaster2d" android:versionCode="1"
        android:versionName="1.0">
        <uses-sdk
            android:minSdkVersion="14"
            android:targetSdkVersion="19"/>

        <application android:icon="@drawable/ic_launcher"
            android:label="@string/app_name"
            android:allowBackup="false"
            android:theme         ="@android:style/Theme.NoTitleBar.Fullscreen">
     <activity android:name="android.app.NativeActivity"
                android:label="@string/app_name"
                android:screenOrientation="portrait">
                <meta-data android:name="android.app.lib_name"
     android:value="droidblaster"/>
                <intent-filter>
                    <action android:name ="android.intent.action.MAIN"/>
                    <category
                        android:name="android.intent.category.LAUNCHER"/>
                </intent-filter>
            </activity>
        </application>
    </manifest>
    ```

3.  创建文件`jni/Types.hpp`。该标题将包含常见类型和标题`cstdint` :

    ```cpp
    #ifndef _PACKT_TYPES_HPP_
    #define _PACKT_TYPES_HPP_

    #include <cstdint>

    #endif
    ```

4.  让我们编写一个日志类，在日志中获得一些反馈。
    *   创建`jni/Log.hpp`并声明一个新的类`Log`。
    *   定义`packt_Log_debug`宏，允许激活或停用带有简单编译标志的调试消息:

        ```cpp
        #ifndef _PACKT_LOG_HPP_
        #define _PACKT_LOG_HPP_

        class Log {
        public:
            static void error(const char* pMessage, ...);
            static void warn(const char* pMessage, ...);
            static void info(const char* pMessage, ...);
            static void debug(const char* pMessage, ...);
        };

        #ifndef NDEBUG
            #define packt_Log_debug(...) Log::debug(__VA_ARGS__)
        #else
            #define packt_Log_debug(...)
        #endif

        #endif
        ```

5.  Implement the `jni/Log.cpp` file and implement the `info()` method. To write messages to Android logs, the NDK provides a dedicated logging API in the `android/log.h` header, which can be used similarly as `printf()` or `vprintf()` (with `varArgs`) in C:

    ```cpp
    #include "Log.hpp"

    #include <stdarg.h>
    #include <android/log.h>

    void Log::info(const char* pMessage, ...) {
        va_list varArgs;
        va_start(varArgs, pMessage);
        __android_log_vprint(ANDROID_LOG_INFO, "PACKT", pMessage,
            varArgs);
        __android_log_print(ANDROID_LOG_INFO, "PACKT", "\n");
        va_end(varArgs);
    }
    ...
    ```

    写其他日志方法，`error()`、`warn()`、`debug()`，几乎一样，除了级别宏分别是`ANDROID_LOG_ERROR, ANDROID_LOG_WARN`，改为`ANDROID_LOG_DEBUG`。

6.  Application events in `NativeActivity` can be processed with an event loop. So, create `jni/EventLoop.hpp` to define a class with a unique method `run()`.

    包括`android_native_app_glue.h`头，它定义了`android_app`结构。它代表了可以被称为**应用上下文**，在这里所有的信息都与本地活动相关；它的状态、窗口、事件队列等等:

    ```cpp
    #ifndef _PACKT_EVENTLOOP_HPP_
    #define _PACKT_EVENTLOOP_HPP_

    #include <android_native_app_glue.h>

    class EventLoop {
    public:
        EventLoop(android_app* pApplication);

        void run();

    private:
        android_app* mApplication;
    };
    #endif
    ```

7.  Create `jni/EventLoop.cpp` and implement the activity event loop in the `run()` method. Include a few log events to get some feedback in Android logs.

    在整个活动生命周期内，`run()`方法连续循环事件，直到请求终止。当一个活动将要被销毁时，`android_app`结构中的`destroyRequested`值在内部被改变，以向客户端代码指示它必须退出。

    另外，调用`app_dummy()`以确保将本机代码绑定到`NativeActivity`的粘合代码不会被链接器剥离。我们将在[第 9 章](09.html "Chapter 9. Porting Existing Libraries to Android")、*中看到更多关于将现有库移植到安卓系统*的内容。

    ```cpp
    #include "EventLoop.hpp"
    #include "Log.hpp"

    EventLoop::EventLoop(android_app* pApplication):
            mApplication(pApplication)
    {}

    void EventLoop::run() {
        int32_t result; int32_t events;
        android_poll_source* source;

        // Makes sure native glue is not stripped by the linker.
        app_dummy();

        Log::info("Starting event loop");
        while (true) {
            // Event processing loop.
            while ((result = ALooper_pollAll(-1, NULL, &events,
                    (void**) &source)) >= 0) {
                // An event has to be processed.
                if (source != NULL) {
                    source->process(mApplication, source);
                }
                // Application is getting destroyed.
                if (mApplication->destroyRequested) {
                    Log::info("Exiting event loop");
                    return;
                }
            }
        }
    }
    ```

8.  最后，创建`jni/Main.cpp`定义程序入口点`android_main()`，在新文件`Main.cpp` :

    ```cpp
    #include "EventLoop.hpp"
    #include "Log.hpp"

    void android_main(android_app* pApplication) {
        EventLoop(pApplication).run();
    }
    ```

    中运行事件循环
9.  Edit the `jni/Android.mk` file to define the `droidblaster` module (the `LOCAL_MODULE` directive).

    描述 C++ 文件，以便借助`LS_CPP`宏编译`LOCAL_SRC_FILES`指令(更多信息请参见[第 9 章](09.html "Chapter 9. Porting Existing Libraries to Android")、*将现有库移植到安卓系统*)。

    将`droidblaster`与`native_app_glue`模块(`LOCAL_STATIC_LIBRARIES`指令)和`android`(由**本机 App Glue** 模块要求)以及`log`库(`LOCAL_LDLIBS`指令)链接起来:

    ```cpp
    LOCAL_PATH := $(call my-dir)

    include $(CLEAR_VARS)

    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))
    LOCAL_MODULE := droidblaster
    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))
    LOCAL_LDLIBS := -landroid -llog
    LOCAL_STATIC_LIBRARIES := android_native_app_glue

    include $(BUILD_SHARED_LIBRARY)

    $(call import-module,android/native_app_glue)
    ```

10.  创建`jni/Application.mk`为多个`ABI` s 编译原生模块，我们将使用最基本的，如下面的代码所示:

    ```cpp
    APP_ABI := armeabi armeabi-v7a x86
    ```

## *刚刚发生了什么？*

构建并运行应用。当然，当启动这个应用时，您不会看到任何巨大的东西。其实你只会看到一个黑屏！但是，如果您仔细查看 Eclipse 中的 **LogCat** 视图(或`adb logcat`命令)，您会发现一些有趣的消息，这些消息是由您的本地应用响应活动事件而发出的:

![What just happened?](graphics/9645_05_01.jpg)

我们发起了一个没有一行 Java 代码的 Java Android 项目！我们引用了安卓框架提供的`android.app.NativeActivity`类，而不是引用`AndroidManifest`中`Activity`的子类。

`NativeActivity`是一个 Java 类，像任何其他安卓活动一样启动，像任何其他 Java 类一样由 Dalvik 虚拟机解释。然而，我们从未直接面对它。`NativeActivity`实际上是 Android SDK 提供的一个助手类，它包含了处理应用事件(生命周期、输入、传感器等)所需的所有粘合代码，并对本机代码透明地广播它们。因此，本地活动并不能消除对 JNI 的需求。它只是把它藏在盖子下面！但是，`NativeActivity`运行的原生 C/C++ 模块是在自己的线程中在 Dalvik 边界之外执行的，完全是原生的(使用 Posix Thread API)！

`NativeActivity`和本机代码通过`native_app_glue`模块连接在一起。原生应用胶负责:

*   启动本机线程，它运行我们自己的本机代码
*   从`NativeActivity`接收事件
*   将这些事件路由到本机线程事件循环进行进一步处理

`Native glue`模块代码位于`${ANDROID_NDK}/sources/android/native_app_glue`中，可以随意分析、修改或分叉(更多信息请参见[第 9 章](09.html "Chapter 9. Porting Existing Libraries to Android")、*将现有库移植到安卓*)。在`${ANDROID_NDK}/platforms/<Target Platform>/<Target Architecture>/usr/include/android/`中可以找到与本地应用接口相关的头，如`looper.h`。让我们更详细地看看它是如何工作的。

## 关于原生应用胶水的更多信息

我们自己的原生代码入口点在`android_main()`方法内部声明，类似于桌面应用中的主要方法。`NativeActivity`实例化启动时只调用一次。它循环应用事件，直到`NativeActivity`被用户终止(例如，当按下设备的后退按钮时)，或者直到它自己退出(下一部分将详细介绍这一点)。

`android_main()`方法不是真正的原生应用入口点。真正的切入点是隐藏在`android_native_app_glue`模块中的`ANativeActivity_onCreate()`方法。我们在`android_main()`中实现的事件循环实际上是一个委托事件循环，由 glue 模块在其自己的本地线程中启动。这种设计将本机代码从运行在 Java 端 UI 线程上的`NativeActivity`类中分离出来。因此，即使您的代码需要很长时间来处理事件，`NativeActivity`也不会被阻止，并且您的安卓设备仍然保持响应。

在我们的例子中，`android_main()`中的委托本地事件循环本身由两个嵌套的 while 循环组成。外部循环是一个无限循环，仅当系统请求销毁活动时终止(由`destroyRequested`标志指示)。它执行一个内部循环，处理所有挂起的应用事件。

```cpp
...
int32_t result; int32_t events;
android_poll_source* source;
while (true) {
    while ((result = ALooper_pollAll(-1, NULL, &events,
            (void**) &source)) >= 0) {
        if (source != NULL) {
           source->process(mApplication, source);
        }
        if (mApplication->destroyRequested) {
            return;
        }
    }
}
...
```

内部`For`循环通过调用`ALooper_pollAll()`来轮询事件。这个方法是`Looper` API 的一部分，可以描述为 Android 提供的通用事件循环管理器。当超时设置为`-1`时，就像前面的例子一样，`ALooper_pollAll()`在等待事件时仍然被阻止。当至少收到一个时，`ALooper_pollAll()`返回，代码流程继续。

描述事件的`android_poll_source`结构被填充，然后被客户端代码用于进一步处理。该结构如下所示:

```cpp
struct android_poll_source {
    int32_t id; // Source identifier
    struct android_app* app; // Global android application context
    void (*process)(struct android_app* app,
            struct android_poll_source* source); // Event processor
};
```

`process()`函数指针可以定制为手动处理应用事件，我们将在下一节中看到。

正如我们在这一部分看到的，事件循环在参数中接收一个`android_app`结构。在`android_native_app_glue.h`中描述的这个结构包含一些上下文信息，如下表所示的:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| `void* userData` | 指针指向你想要的任何数据。这对于给活动或输入事件回调提供一些上下文信息是至关重要的。 |
| `void (*pnAppCmd)(…)`和`int32_t (*onInputEvent)(…)` | 这些成员变量表示当活动或输入事件发生时，由本机应用胶水触发的事件回调。我们将在下一节看到更多关于这方面的内容。 |
| `ANativeActivity* activity` | 描述 Java 本机活动(其作为 JNI 对象的类、其数据目录等)，并给出检索 JNI 上下文所需的信息。 |
| `AConfiguration* config` | 描述当前硬件和系统状态，如当前语言和国家、当前屏幕方向、密度、大小等。 |
| `void* savedState size_t`和`savedStateSize` | 用于在活动(及其本机线程)被破坏并在以后恢复时保存数据缓冲区。 |
| `AInputQueue* inputQueue` | 提供输入事件(由本机胶水内部使用)。我们将在[第 8 章](08.html "Chapter 8. Handling Input Devices and Sensors")、*处理输入设备和传感器*中看到更多关于输入事件的信息。 |
| `ALooper* looper` | 允许附加和分离本机粘附内部使用的事件队列。侦听器轮询并等待通信管道上发送的事件。 |
| `ANativeWindow* window`和`ARect contentRect` | 表示可以绘制图形的“可绘制”区域。在`native_window.h`中声明的`ANativeWindow`应用编程接口允许检索窗口宽度、高度和像素格式，并更改这些设置。 |
| `int activityState` | 当前活动状态，即`APP_CMD_START`、`APP_CMD_RESUME`、`APP_CMD_PAUSE`等等。 |
| `int destroyRequested` | 当等于`1`时，表示应用即将被销毁，必须立即终止本机线程。必须在事件循环中检查该标志。 |

`android_app`结构还包含一些仅供内部使用的附加数据，不应更改。

了解所有这些细节对于编写原生程序来说并不重要，但可以帮助你理解背后发生的事情。现在让我们看看如何处理这些活动事件。

# 处理活动事件

在第一部分中，运行了一个本地事件循环，它刷新事件而不真正处理它们。在第二部分中，我们将会发现更多关于在活动生命周期中发生的这些事件，以及如何处理它们，剩下的时间我们将逐步应用。

### 注

由此产生的项目以`DroidBlaster_Part2`的名称提供本书。

# 行动时间–逐步推进事件循环

让我们扩展前面的例子，在处理事件时逐步执行我们的应用。

1.  打开`jni/Types.hpp`并定义一个新的类型状态来表示返回代码:

    ```cpp
    #ifndef _PACKT_TYPES_HPP_
    #define _PACKT_TYPES_HPP_

    #include <cstdlib>

    typedef int32_t status;

    const status STATUS_OK   = 0;
    const status STATUS_KO   = -1;
    const status STATUS_EXIT = -2;

    #endif
    ```

2.  创建`jni/ActivityHandler.hpp`头并定义一个“接口”来观察本地活动事件。每个可能的事件都有自己的处理方法:`onStart()`、`onResume()`、`onPause()`、`onStop()`、`onDestroy()`等等。然而，我们通常对活动生命周期中的三个特定时刻感兴趣:
    *   `onActivate()`，当活动恢复并且其窗口可用并聚焦时调用
    *   `onDeactivate()`，当活动暂停或显示窗口失去焦点或被破坏时调用
    *   `onStep()`，当没有事件需要处理并且可以进行计算时调用

        ```cpp
        #ifndef _PACKT_ACTIVITYHANDLER_HPP_
        #define _PACKT_ACTIVITYHANDLER_HPP_

        #include "Types.hpp"

        class ActivityHandler {
        public:
            virtual ~ActivityHandler() {};

            virtual status onActivate() = 0;
            virtual void onDeactivate() = 0;
            virtual status onStep() = 0;

            virtual void onStart() {};
            virtual void onResume() {};
            virtual void onPause() {};
            virtual void onStop() {};
            virtual void onDestroy() {};

            virtual void onSaveInstanceState(void** pData, size_t* pSize) {};
            virtual void onConfigurationChanged() {};
            virtual void onLowMemory() {};

            virtual void onCreateWindow() {};
            virtual void onDestroyWindow() {};
            virtual void onGainFocus() {};
            virtual void onLostFocus() {};
        };
        #endif
        ```

3.  Enhance `jni/EventLoop.hpp` with the following methods:
    *   `activate()`和`deactivate()`，当活动可用性改变时执行
    *   `callback_appEvent()`，为静态，将事件路由至`processActivityEvent()`

    另外，定义一些成员变量如下:

    *   `mActivityHandler`观察活动事件。该实例作为构造函数参数给出，需要包含`ActivityHandler.hpp`
    *   `mEnabled`当应用处于活动/暂停状态时，保存应用状态
    *   `mQuit`表示事件循环需要退出

        ```cpp
        #ifndef _PACKT_EVENTLOOP_HPP_
        #define _PACKT_EVENTLOOP_HPP_

        #include "ActivityHandler.hpp"
        #include <android_native_app_glue.h>

        class EventLoop {
        public:
            EventLoop(android_app* pApplication,
                    ActivityHandler& pActivityHandler);

            void run();

        private:
         void activate();
         void deactivate();

         void processAppEvent(int32_t pCommand);

         static void callback_appEvent(android_app* pApplication,
         int32_t pCommand);

        private:
            android_app* mApplication;
            bool mEnabled;
         bool mQuit;

         ActivityHandler& mActivityHandler;
        };
        #endif
        ```

4.  编辑`jni/EventLoop.cpp`。构造函数初始化列表本身实现起来很简单。然后，用附加信息填充`android_app`应用上下文:
    *   `userData`指向任何你想要的数据。这是之前声明的`callback_appEvent()`中唯一可访问的信息。在我们的例子中，这是`EventLoop`实例(即`this`)。
    *   `onAppCmd`指向每次事件发生时触发的内部回调。在我们的例子中，这是专门用于静态方法`callback_appEvent()`的角色。

        ```cpp
        #include "EventLoop.hpp"
        #include "Log.hpp"

        EventLoop::EventLoop(android_app* pApplication,
                ActivityHandler& pActivityHandler):
         mApplication(pApplication),
         mEnabled(false), mQuit(false),
         mActivityHandler(pActivityHandler) {
         mApplication->userData = this;
         mApplication->onAppCmd = callback_appEvent;
        }
        ...
        ```

    *   更新`run()`主事件循环。`ALooper_pollAll()`必须让程序流继续执行循环处理，而不是在没有更多活动事件要处理时阻塞。这里，处理由`mActivityHandler.onStep()`中的收听者执行。显然，只有在启用应用时，才需要这种行为。
    *   此外，允许使用`AnativeActivity_finish()`方法以编程方式终止活动。

        ```cpp
        ...
        void EventLoop::run() {
            int32_t result; int32_t events;
            android_poll_source* source;

            // Makes sure native glue is not stripped by the linker.
            app_dummy();

            Log::info("Starting event loop");
            while (true) {
                // Event processing loop.
                while ((result = ALooper_pollAll(mEnabled ? 0 : -1,         NULL,
         &events, (void**) &source)) >= 0) {
                    // An event has to be processed.
                    if (source != NULL) {
                        Log::info("Processing an event");
                        source->process(mApplication, source);
                    }
                    // Application is getting destroyed.
                    if (mApplication->destroyRequested) {
                        Log::info("Exiting event loop");
                        return;
                    }
                }

                // Steps the application.
         if ((mEnabled) && (!mQuit)) {
         if (mActivityHandler.onStep() != STATUS_OK) {
         mQuit = true;
         ANativeActivity_finish(mApplication->activity);
                    }
                }
            }
        }
        ...
        ```

## *刚刚发生了什么？*

当没有更多事件需要处理时，我们改变了事件循环来更新我们的应用，而不是无用的阻塞。该行为在`ALooper_pollAll()`中通过其第一个参数超时来指定:

*   如前所述，当超时为`-1`时，呼叫被阻止，直到接收到事件。
*   当超时为`0`时，调用是非阻塞的，因此，如果队列中没有剩余，程序流继续(内部 while 循环终止)，并使执行循环处理成为可能。
*   当超时大于`0`时，我们有一个阻塞呼叫，它会一直保持到收到事件或持续时间过去。

在这里，我们要对活动(即执行计算)处于活动状态时进行步进(`mEnabled`为`true`)；既然如此，超时就是`0`。当活动处于停用状态(`mEnabled`为`false`)时，事件仍在处理中(例如，恢复活动)，但无需计算任何内容。线程必须被阻塞，以避免无用地消耗电池和处理器时间；那样的话，超时就是`-1`。

一旦处理完所有挂起的事件，侦听器就会被转移。例如，如果游戏结束，它可以请求终止应用。为了以编程方式离开应用，NDK 应用编程接口提供了`AnativeActivity_finish()`方法来请求活动终止。终止不会立即发生，而是在处理完最后几个事件(暂停、停止等)后发生。

# 行动时间–处理活动事件

我们还没有完成。让我们继续我们的示例来处理活动事件，并将它们记录到**日志文件**视图中:

1.  继续编辑`jni/EventLoop.cpp`。执行`activate()``deactivate()`。在通知侦听器之前检查两种活动状态(以避免过早触发)。只有当显示窗口可用时，我们才认为活动已激活:

    ```cpp
    ...
    void EventLoop::activate() {
        // Enables activity only if a window is available.
        if ((!mEnabled) && (mApplication->window != NULL)) {
            mQuit = false; mEnabled = true;
            if (mActivityHandler.onActivate() != STATUS_OK) {
                goto ERROR;
            }
        }
        return;

    ERROR:
        mQuit = true;
        deactivate();
        ANativeActivity_finish(mApplication->activity);
    }

    void EventLoop::deactivate() {
        if (mEnabled) {
            mActivityHandler.onDeactivate();
            mEnabled = false;
        }
    }
    ...
    ```

    *   将活动事件从静态回调`callback_appEvent()`路由到成员方法`processAppEvent()`。
    *   为此，通过`userData`指针检索`EventLoop`实例(这在静态方法中是不可用的)。有效的事件处理然后被委托给`processAppEvent()`，这将我们带回面向对象的世界。同时传递由本机粘附给出的命令，即活动事件。

        ```cpp
        ...
        void EventLoop::callback_appEvent(android_app* pApplication,
            int32_t pCommand) {
            EventLoop& eventLoop = *(EventLoop*) pApplication->userData;
            eventLoop.processAppEvent(pCommand);
        }
        ...
        ```

2.  Process the forwarded events in `processAppEvent()`. The `pCommand` parameter contains an enumeration value (`APP_CMD_*`), which describes the occurring event (`APP_CMD_START, APP_CMD_GAINED_FOCUS`, and so on).

    根据事件，激活或停用事件循环并通知侦听器:

    当活动获得焦点时，激活发生。此事件始终是活动恢复并创建窗口后发生的最后一个事件。获得焦点意味着活动可以接收输入事件。

    当窗口失去焦点或应用暂停时(这两种情况都可能首先发生)，就会发生停用。为了安全起见，当窗口被破坏时，也执行去激活，尽管这应该总是在焦点丢失后发生。失去焦点意味着应用不再接收输入事件。

    ```cpp
    ...
    void EventLoop::processAppEvent(int32_t pCommand) {
        switch (pCommand) {
        case APP_CMD_CONFIG_CHANGED:
            mActivityHandler.onConfigurationChanged();
            break;
        case APP_CMD_INIT_WINDOW:
            mActivityHandler.onCreateWindow();
            break;
        case APP_CMD_DESTROY:
            mActivityHandler.onDestroy();
            break;
        case APP_CMD_GAINED_FOCUS:
            activate();
            mActivityHandler.onGainFocus();
            break;
        case APP_CMD_LOST_FOCUS:
            mActivityHandler.onLostFocus();
            deactivate();
            break;
        case APP_CMD_LOW_MEMORY:
            mActivityHandler.onLowMemory();
            break;
        case APP_CMD_PAUSE:
            mActivityHandler.onPause();
            deactivate();
            break;
        case APP_CMD_RESUME:
            mActivityHandler.onResume();
            break;
        case APP_CMD_SAVE_STATE:
            mActivityHandler.onSaveInstanceState(
               &mApplication->savedState, &mApplication->savedStateSize);
              break;
        case APP_CMD_START:
            mActivityHandler.onStart();
            break;
        case APP_CMD_STOP:
            mActivityHandler.onStop();
            break;
        case APP_CMD_TERM_WINDOW:
            mActivityHandler.onDestroyWindow();
            deactivate();
            break;
        default:
            break;
        }
    }
    ```

    ### 类型

    少数事件，如`APP_CMD_WINDOW_RESIZED`，可用但从未触发。除非你准备好把手伸进胶水里，否则不要听他们的。

3.  创建`jni/DroidBlaster.hpp`，实现`ActivityHandler`接口及其所有方法(为了简洁起见，这里省略了一些)。这个类将运行如下的游戏逻辑:

    ```cpp
    #ifndef _PACKT_DROIDBLASTER_HPP_
    #define _PACKT_DROIDBLASTER_HPP_

    #include "ActivityHandler.hpp"
    #include "EventLoop.hpp"
    #include "Types.hpp"

    class DroidBlaster : public ActivityHandler {
    public:
        DroidBlaster(android_app* pApplication);
        void run();

    protected:
        status onActivate();
        void onDeactivate();
        status onStep();

        void onStart();
        ...

    private:
        EventLoop mEventLoop;
    };
    #endif
    ```

4.  Implement `jni/DroidBlaster.cpp` with all the required handlers. To keep this introduction to the activity lifecycle simple, we are just going to log each event that occurs. Use `onStart()` as a model for all the handlers that have been skipped in the following code.

    步骤仅限于简单的线程休眠(避免淹没安卓日志)，这需要包含`unistd.h`。

    请注意，事件循环现在直接由`DroidBlaster`类运行:

    ```cpp
    #include "DroidBlaster.hpp"
    #include "Log.hpp"

    #include <unistd.h>

    DroidBlaster::DroidBlaster(android_app* pApplication):
        mEventLoop(pApplication, *this) {
        Log::info("Creating DroidBlaster");
    }

    void DroidBlaster::run() {
        mEventLoop.run();
    }

    status DroidBlaster::onActivate() {
        Log::info("Activating DroidBlaster");
        return STATUS_OK;
    }

    void DroidBlaster::onDeactivate() {
        Log::info("Deactivating DroidBlaster");
    }

    status DroidBlaster::onStep() {
        Log::info("Starting step");
        usleep(300000);
        Log::info("Stepping done");
        return STATUS_OK;
    }

    void DroidBlaster::onStart() {
        Log::info("onStart");
    }
    ...
    ```

5.  最后，初始化并在`android_main()`入口点

    ```cpp
    #include "DroidBlaster.hpp"
    #include "EventLoop.hpp"
    #include "Log.hpp"

    void android_main(android_app* pApplication) {
        DroidBlaster(pApplication).run();
    }
    ```

    运行`DroidBlaster`游戏

## *刚刚发生了什么？*

如果你喜欢黑屏，就有人招待你！同样，这一次，一切都发生在 Eclipse **LogCat** 视图中。此处显示了响应应用事件而发出的所有消息，如下图所示:

![What just happened?](graphics/9645_05_02.jpg)

我们创建了一个极简框架，它使用事件驱动的方法在本机线程中处理应用事件。事件(被命名为命令)被重定向到一个侦听器对象，该对象执行自己的特定计算。

本机活动事件大多对应于经典的 Java 活动事件。事件是任何应用都需要处理的一个关键且相当棘手的问题。它们一般成对出现，如`start/stop`、`resume/pause`、`create/destroy`、`create window/destroy window`或`gain/lose focus`。尽管大多数情况下，它们都是以预定的顺序发生的，但某些特定情况可能会导致不同的行为，例如:

*   使用后退按钮离开应用会破坏活动和本机线程。
*   使用主页按钮离开应用会停止活动并释放窗口。本机线程保持挂起状态。
*   长时间按下设备的主页按钮，然后返回，只会导致焦点的丢失和增加。本机线程保持挂起状态。
*   关闭电话屏幕并将其切换回应该会在活动恢复后立即终止并重新初始化窗口。本机线程保持挂起状态。
*   当改变屏幕方向时(此处不适用)，整个活动可能不会失去焦点，尽管重新创建的活动会重新获得焦点。

了解活动生命周期对于开发安卓应用至关重要。详见安卓官方文档。

### 类型

原生应用胶水通过触发`APP_CMD_SAVE_STATE`，让你有机会在活动状态被破坏之前保存活动状态。状态必须保存在`savedState`中的`android_app`结构中，这是指向要保存的内存缓冲区的指针，在`savedStateSize`中，这是要保存的内存缓冲区的大小。缓冲区必须由我们自己分配，使用`malloc()`(解除分配是自动的)，并且不能包含指针，只能包含“原始”数据。

# 原生访问窗口表面

应用事件是必不可少的了解，但不是很刺激。安卓 NDK 的一个有趣的特性是能够本地访问显示窗口。有了这种特权访问，应用可以在屏幕上绘制他们想要的任何图形。

我们现在将利用这个特性在我们的应用中获得一个图形反馈:屏幕上的一个红色方块。这个方块将代表用户在游戏中控制的宇宙飞船。

### 注

由此产生的项目以`DroidBlaster_Part3`的名称提供本书。

# 行动时间-显示原始图形

让我们用一些图形和游戏组件让 `DroidBlaster`更具互动性。

1.  编辑`jni/Types.hpp`并创建一个新的结构`Location`来保持实体位置。此外，定义一个宏来生成请求范围内的随机值，如下所示:

    ```cpp
    #ifndef _PACKT_TYPES_HPP_
    #define _PACKT_TYPES_HPP_
    ...
    struct Location {
     Location(): x(0.0f), y(0.0f) {};

        float x; float y;
    };

    #define RAND(pMax) (float(pMax) * float(rand()) / float(RAND_MAX))
    #endif
    ```

2.  Create a new file, `jni/GraphicsManager.hpp`. Define a structure `GraphicsElement`, which contains the location and dimensions of the graphical element to display:

    ```cpp
    #ifndef _PACKT_GRAPHICSMANAGER_HPP_
    #define _PACKT_GRAPHICSMANAGER_HPP_

    #include "Types.hpp"

    #include <android_native_app_glue.h>

    struct GraphicsElement {
        GraphicsElement(int32_t pWidth, int32_t pHeight):
            location(),
            width(pWidth), height(pHeight) {
        }

        Location location;
        int32_t width;  int32_t height;
    };
    ...
    ```

    然后，在同一文件中，定义一个`GraphicsManager`类，如下所示:

    *   `getRenderWidth()`和`getRenderHeight()`返回显示尺寸
    *   `registerElement()`是一个`GraphicsElement`工厂方法，告诉经理绘制什么元素
    *   `start()`和`update()initialize`分别管理和渲染每一帧的屏幕

    需要几个成员变量:

    *   `mApplication`存储访问显示窗口所需的应用上下文
    *   `mRenderWidth` 和`mRenderHeight`为显示尺寸
    *   `mElements` 和`mElementCount`为一张表格中所有要绘制的元素

        ```cpp
        ...
        class GraphicsManager {
        public:
            GraphicsManager(android_app* pApplication);
            ~GraphicsManager();

            int32_t getRenderWidth() { return mRenderWidth; }
            int32_t getRenderHeight() { return mRenderHeight; }

            GraphicsElement* registerElement(int32_t pHeight, int32_t pWidth);

            status start();
            status update();

        private:
            android_app* mApplication;

            int32_t mRenderWidth; int32_t mRenderHeight;
            GraphicsElement* mElements[1024]; int32_t mElementCount;
        };
        #endif
        ```

3.  实现`jni/GraphicsManager.cpp`，从构造函数、析构函数、注册方法开始。他们管理着`GraphicsElement`要更新的名单:

    ```cpp
    #include "GraphicsManager.hpp"
    #include "Log.hpp"

    GraphicsManager::GraphicsManager(android_app* pApplication) :
        mApplication(pApplication),
        mRenderWidth(0), mRenderHeight(0),
        mElements(), mElementCount(0) {
        Log::info("Creating GraphicsManager.");
    }

    GraphicsManager::~GraphicsManager() {
        Log::info("Destroying GraphicsManager.");
        for (int32_t i = 0; i < mElementCount; ++ i) {
            delete mElements[i];
        }
    }

    GraphicsElement* GraphicsManager::registerElement(int32_t pHeight,
            int32_t pWidth) {
        mElements[mElementCount] = new GraphicsElement(pHeight, pWidth);
        return mElements[mElementCount++ ];
    }
    ...
    ```

4.  Implement the `start()` method to initialize the manager.

    首先，使用`ANativeWindow_setBuffersGeometry()` API 方法强制窗口深度格式为 32 位。参数中传递的两个零是所需的窗口宽度和高度。除非用正值初始化，否则它们将被忽略。在这种情况下，由宽度和高度定义的请求窗口区域被缩放以匹配屏幕尺寸。

    然后，在`ANativeWindow_Buffer`结构中检索所有必要的窗口尺寸。要填充这个结构，必须先用`ANativeWindow_lock()`锁住窗户，完成后再用`AnativeWindow_unlockAndPost()`解锁。

    ```cpp
    ...
    status GraphicsManager::start() {
        Log::info("Starting GraphicsManager.");

        // Forces 32 bits format.
        ANativeWindow_Buffer windowBuffer;
        if (ANativeWindow_setBuffersGeometry(mApplication->window, 0, 0,
            WINDOW_FORMAT_RGBX_8888) < 0) {
            Log::error("Error while setting buffer geometry.");
            return STATUS_KO;
        }

        // Needs to lock the window buffer to get its properties.
        if (ANativeWindow_lock(mApplication->window,
                &windowBuffer, NULL) >= 0) {
            mRenderWidth = windowBuffer.width;
            mRenderHeight = windowBuffer.height;
            ANativeWindow_unlockAndPost(mApplication->window);
        } else {
            Log::error("Error while locking window.");
            return STATUS_KO;
        }
        return STATUS_OK;
    }
    ...
    ```

5.  Write the `update()`method, which renders raw graphics each time an application is stepped.

    在使用`AnativeWindow_lock()`进行任何绘制操作之前，必须锁定窗口表面。同样，`AnativeWindow_Buffer`结构充满了宽度和高度的窗口信息，但更重要的是，`stride`和`bits`指针。

    `stride`给出窗口中两个连续像素行之间的距离，单位为“像素”。

    `bits`指针提供了对窗口表面的直接访问，与位图应用编程接口的方式非常相似，如前一章所示。

    有了这两条信息，任何基于像素的操作都可以在本地执行。

    例如，用`0`清除窗口记忆区，得到黑色背景。使用 `memset()`的强力方法可以应用于该目的。

    ```cpp
    ...
    status GraphicsManager::update() {
        // Locks the window buffer and draws on it.
        ANativeWindow_Buffer windowBuffer;
        if (ANativeWindow_lock(mApplication->window,
                &windowBuffer, NULL) < 0) {
            Log::error("Error while starting GraphicsManager");
            return STATUS_KO;
        }

        // Clears the window.
        memset(windowBuffer.bits, 0, windowBuffer.stride *
                windowBuffer.height * sizeof(uint32_t*));
    ...
    ```

    *   清除后，绘制所有注册为`GraphicsManager`的元素。每个元素在屏幕上都显示为一个红色方块。
    *   首先，计算要绘制的元素的坐标(左上角和右下角)。
    *   然后，裁剪它们的坐标，以避免在窗口内存区域之外绘图。该操作相当重要，因为超出窗口限制可能会导致分割错误:

        ```cpp
        ...
            // Renders graphic elements.
            int32_t maxX = windowBuffer.width - 1;
            int32_t maxY = windowBuffer.height - 1;
            for (int32_t i = 0; i < mElementCount; ++ i) {
                GraphicsElement* element = mElements[i];

                // Computes coordinates.
                int32_t leftX = element->location.x - element->width / 2;
                int32_t rightX = element->location.x + element->width / 2;
                int32_t leftY = windowBuffer.height - element->location.y
                                    - element->height / 2;
                int32_t rightY = windowBuffer.height - element->location.y
                                    + element->height / 2;

                // Clips coordinates.
                if (rightX < 0 || leftX > maxX
                 || rightY < 0 || leftY > maxY) continue;

                if (leftX < 0) leftX = 0;
                else if (rightX > maxX) rightX = maxX;
                if (leftY < 0) leftY = 0;
                else if (rightY > maxY) rightY = maxY;
        ...
        ```

6.  After that, draw each pixel of the element on screen. The `line` variable points to the beginning of the first line of pixels on which the element is drawn. This pointer is computed using the stride (distance between two lines of pixels) and the top `Y` coordinate of the element.

    然后，我们可以在窗口像素上循环绘制一个代表元素的红色方块。从元素的左侧`X`坐标开始到右侧`X`坐标，当到达每条线的终点时，从一条像素线切换到另一条像素线(即在`Y`轴上)。

    ```cpp
    ...
            // Draws a rectangle.
            uint32_t* line = (uint32_t*) (windowBuffer.bits)
                            + (windowBuffer.stride * leftY);
            for (int iY = leftY; iY <= rightY; iY++) {
                for (int iX = leftX; iX <= rightX; iX++) {
                    line[iX] = 0X000000FF; // Red color
                }
                line = line + windowBuffer.stride;
            }
        }
    ...
    ```

    用`ANativeWindow_unlockAndPost()`完成绘图操作，并挂起对`pendANativeWindow_lock()`的调用。这些必须总是成对调用:

    ```cpp
    ...
        // Finshed drawing.
        ANativeWindow_unlockAndPost(mApplication->window);
        return STATUS_OK;
    }
    ```

7.  Create a new component `jni/Ship.hpp` that represents our spaceship.

    我们现在只为处理初始化，使用`initialize()`。

    `Ship`用工厂法`registerShip()`创建。

    需要`GraphicsManager`和`GraphicsElement`来正确初始化船只。

    ```cpp
    #ifndef _PACKT_SHIP_HPP_
    #define _PACKT_SHIP_HPP_

    #include "GraphicsManager.hpp"

    class Ship {
    public:
        Ship(android_app* pApplication,
             GraphicsManager& pGraphicsManager);

        void registerShip(GraphicsElement* pGraphics);

        void initialize();

    private:
        GraphicsManager& mGraphicsManager;

        GraphicsElement* mGraphics;
    };
    #endif
    ```

8.  执行`jni/Ship.cpp`。重要的部分是`initialize()`，它将船只定位在屏幕的下四分之一处，如下代码所示:

    ```cpp
    #include "Log.hpp"
    #include "Ship.hpp"
    #include "Types.hpp"

    static const float INITAL_X = 0.5f;
    static const float INITAL_Y = 0.25f;

    Ship::Ship(android_app* pApplication,
            GraphicsManager& pGraphicsManager) :
      mGraphicsManager(pGraphicsManager),
      mGraphics(NULL) {
    }

    void Ship::registerShip(GraphicsElement* pGraphics) {
        mGraphics = pGraphics;
    }

    void Ship::initialize() {
        mGraphics->location.x = INITAL_X
                * mGraphicsManager.getRenderWidth();
        mGraphics->location.y = INITAL_Y
                * mGraphicsManager.getRenderHeight();
    }
    ```

9.  将新创建的管理器和组件追加到`jni/DroidBlaster.hpp` :

    ```cpp
    ...
    #include "ActivityHandler.hpp"
    #include "EventLoop.hpp"
    #include "GraphicsManager.hpp"
    #include "Ship.hpp"
    #include "Types.hpp"

    class DroidBlaster : public ActivityHandler {
        ...
    private:
        ...

        GraphicsManager mGraphicsManager;
        EventLoop mEventLoop;

        Ship mShip;
    };
    #endif
    ```

10.  最后，更新的`jni/DroidBlaster.cpp`构造函数:

    ```cpp
    ...
    static const int32_t SHIP_SIZE = 64;

    DroidBlaster::DroidBlaster(android_app* pApplication):
     mGraphicsManager(pApplication),
     mEventLoop(pApplication, *this),

     mShip(pApplication, mGraphicsManager) {
        Log::info("Creating DroidBlaster");

        GraphicsElement* shipGraphics = mGraphicsManager.registerElement(
     SHIP_SIZE, SHIP_SIZE);
     mShip.registerShip(shipGraphics);
    }
    ...
    ```

11.  初始化 `GraphicsManager`和`onActivate()`中的`Ship`组件:

    ```cpp
    ...
    status DroidBlaster::onActivate() {
        Log::info("Activating DroidBlaster");

        if (mGraphicsManager.start() != STATUS_OK) return     STATUS_KO;

     mShip.initialize();

        return STATUS_OK;
    }
    ...
    ```

12.  最后在`onStep()`更新经理:

    ```cpp
    ...
    status DroidBlaster::onStep() {
        return mGraphicsManager.update();
    }
    ```

## *刚刚发生了什么？*

编译运行`DroidBlaster`。结果应该是一个简单的红色方块，在屏幕的第一个季度代表我们的飞船，如下所示:

![What just happened?](graphics/9645_05_04.jpg)

图形反馈通过`ANativeWindow`应用编程接口提供，该接口提供对显示窗口的本地访问。它允许像位图一样操纵它的表面。同样，访问窗口表面需要在处理前后进行锁定和解锁。

`AnativeWindow` API 定义在`android/native_window.h` 和`android/native_window_jni.h`中。它提供了以下内容:

`ANativeWindow_setBuffersGeometry()`初始化窗口缓冲区的像素格式(或深度格式)和大小。可能的像素格式有:

*   `WINDOW_FORMAT_RGBA_8888`对于每个像素 32 位颜色，红、绿、蓝和阿尔法(透明)通道各 8 位。
*   `WINDOW_FORMAT_RGBX_8888`与上一个相同，只是忽略了 Alpha 通道。
*   `WINDOW_FORMAT_RGB_565`表示每像素 16 位颜色(红色和蓝色 5 位，绿色通道 6 位)。

如果提供的尺寸为`0`，则使用窗口尺寸。如果不为零，则窗口缓冲区在屏幕上显示时会缩放以匹配窗口尺寸:

```cpp
int32_t ANativeWindow_setBuffersGeometry(ANativeWindow* window, int32_t width, int32_t height, int32_t format);
```

*   执行任何绘图操作前必须调用`ANativeWindow_lock()`:

    ```cpp
    int32_t ANativeWindow_lock(ANativeWindow* window, ANativeWindow_Buffer* outBuffer,
            ARect* inOutDirtyBounds);
    ```

*   `ANativeWindow_unlockAndPost()`画图操作完成后释放窗口，并发送到显示器。必须与`ANativeWindow_lock()`成对调用:

    ```cpp
    int32_t ANativeWindow_unlockAndPost(ANativeWindow* window);
    ```

*   `ANativeWindow_acquire()`以 Java 方式获取指定窗口上的引用，以防止潜在的删除。如果您对表面生命周期没有精细的控制，这可能是必要的:

    ```cpp
    void ANativeWindow_acquire(ANativeWindow* window);
    ```

*   `ANativeWindow_fromSurface()`将窗口与给定的 Java `android.view.Surface`相关联。此方法自动获取对给定曲面的引用。它必须与`ANativeWindow_release()`一起发布，以避免内存泄漏:

    ```cpp
    ANativeWindow* ANativeWindow_fromSurface(JNIEnv* env, jobject surface);
    ```

*   `ANativeWindow_release()`移除获取的引用以允许释放窗口资源:

    ```cpp
    void ANativeWindow_release(ANativeWindow* window);
    ```

*   以下方法返回窗口表面的宽度、高度(以像素为单位)和格式。如果发生错误，返回值为负。请注意，这些方法很难使用，因为它们的行为有点不一致。安卓 4 之前，最好锁定表面一次，获取可靠信息(已经由`ANativeWindow_lock()`提供):

    ```cpp
    int32_t ANativeWindow_getWidth(ANativeWindow* window);
    int32_t ANativeWindow_getHeight(ANativeWindow* window);
    int32_t ANativeWindow_getFormat(ANativeWindow* window);
    ```

我们现在知道如何画画了。然而，我们如何将绘制的内容制作成动画呢？为此需要一把钥匙:*时间*。

# 原生测量时间

那些谈论图形的人也需要谈论时机。事实上，安卓设备有不同的功能，动画应该适应它们的速度。为了帮助我们完成这项任务，安卓提供了对时间原语的访问，这要归功于它对 Posix APIs 的良好支持。

为了试验这些能力，我们将使用计时器根据时间在屏幕上移动小行星。

### 注

由此产生的项目以`DroidBlaster_Part4`的名称提供本书。

# 行动时间-用计时器制作图形动画

让我们来制作游戏动画。

1.  Create `jni/TimeManager.hpp` with the `time.h` manager and define the following methods:
    *   `reset()`初始化管理器。
    *   `update()`测量游戏步骤持续时间。
    *   `elapsed()`和`elapsedTotal()`获取游戏步骤时长和游戏时长。他们将允许应用行为适应设备速度。
    *   `now()`是重新计算当前时间的实用方法。

    定义以下成员变量:

    *   `mFirstTime`和`mLastTime`保存时间检查点，以便计算`elapsed()`和`elapsedTotal()`
    *   `mElapsed`和`mElapsedTotal`保存计算的时间措施

        ```cpp
        #ifndef _PACKT_TIMEMANAGER_HPP_
        #define _PACKT_TIMEMANAGER_HPP_

        #include "Types.hpp"

        #include <ctime>

        class TimeManager {
        public:
            TimeManager();

            void reset();
            void update();

            double now();
            float elapsed() { return mElapsed; };
            float elapsedTotal() { return mElapsedTotal; };

        private:
            double mFirstTime;
            double mLastTime;
            float mElapsed;
            float mElapsedTotal;
        };
        #endif
        ```

2.  执行`jni/TimeManager.cpp`。重置时，`TimeManager`保存通过`now()`方法计算的当前时间。

    ```cpp
    #include "Log.hpp"
    #include "TimeManager.hpp"

    #include <cstdlib>
    #include <time.h>

    TimeManager::TimeManager():
        mFirstTime(0.0f),
        mLastTime(0.0f),
        mElapsed(0.0f),
        mElapsedTotal(0.0f) {
        srand(time(NULL));
    }

    void TimeManager::reset() {
        Log::info("Resetting TimeManager.");
        mElapsed = 0.0f;
        mFirstTime = now();
        mLastTime = mFirstTime;
    }
    ...
    ```

3.  执行`update()`检查:
    *   `mElapsed`中最后一帧后经过的时间
    *   elapsed time since the very first frame in `mElapsedTotal`

        ### 注

        请注意，在处理当前时间时，使用双重类型很重要，以避免失去准确性。然后，由于两个帧之间的时间差很小，因此产生的延迟可以在经过的时间内转换回浮点。

        ```cpp
        ...
        void TimeManager::update() {
        	double currentTime = now();
        	mElapsed = (currentTime - mLastTime);
        	mElapsedTotal = (currentTime - mFirstTime);
        	mLastTime = currentTime;
        }
        ...
        ```

4.  用`now()`方法计算当前时间。使用 Posix 原语`clock_gettime()`检索当前时间。单调时钟对于确保时间始终向前并且不受系统变化的影响(例如，如果用户在世界各地旅行):

    ```cpp
    ...
    double TimeManager::now() {
        timespec timeVal;
        clock_gettime(CLOCK_MONOTONIC, &timeVal);
        return timeVal.tv_sec + (timeVal.tv_nsec * 1.0e-9);
    }
    ```

5.  创建新文件，`jni/PhysicsManager.hpp`。定义一个结构`PhysicsBody`来保存小行星的位置、尺寸和速度:

    ```cpp
    #ifndef PACKT_PHYSICSMANAGER_HPP
    #define PACKT_PHYSICSMANAGER_HPP

    #include "GraphicsManager.hpp"
    #include "TimeManager.hpp"
    #include "Types.hpp"

    struct PhysicsBody {
        PhysicsBody(Location* pLocation, int32_t pWidth, int32_t pHeight):
            location(pLocation),
            width(pWidth), height(pHeight),
            velocityX(0.0f), velocityY(0.0f) {
        }

        Location* location;
        int32_t width; int32_t height;
        float velocityX; float velocityY;
    };
    ...
    ```

6.  Define a basic `PhysicsManager`. We need a reference to `TimeManager` to adapt bodies of movements to time.

    定义一个方法`update()`在每个游戏步骤中移动小行星。`PhysicsManager`存储要在`mPhysicsBodies`和`mPhysicsBodyCount`更新的小行星:

    ```cpp
    ...
    class PhysicsManager {
    public:
        PhysicsManager(TimeManager& pTimeManager,
                GraphicsManager& pGraphicsManager);
        ~PhysicsManager();

        PhysicsBody* loadBody(Location& pLocation, int32_t pWidth,
                int32_t pHeight);
        void update();

    private:
        TimeManager& mTimeManager;
        GraphicsManager& mGraphicsManager;

        PhysicsBody* mPhysicsBodies[1024]; int32_t mPhysicsBodyCount;
    };
    #endif
    ```

7.  实现`jni/PhysicsManager.cpp`，从构造函数、析构函数、注册方法开始:

    ```cpp
    #include "PhysicsManager.hpp"
    #include "Log.hpp"

    PhysicsManager::PhysicsManager(TimeManager& pTimeManager,
            GraphicsManager& pGraphicsManager) :
      mTimeManager(pTimeManager), mGraphicsManager(pGraphicsManager),
      mPhysicsBodies(), mPhysicsBodyCount(0) {
        Log::info("Creating PhysicsManager.");
    }

    PhysicsManager::~PhysicsManager() {
        Log::info("Destroying PhysicsManager.");
        for (int32_t i = 0; i < mPhysicsBodyCount; ++ i) {
            delete mPhysicsBodies[i];
        }
    }

    PhysicsBody* PhysicsManager::loadBody(Location& pLocation,
            int32_t pSizeX, int32_t pSizeY) {
        PhysicsBody* body = new PhysicsBody(&pLocation, pSizeX, pSizeY);
        mPhysicsBodies[mPhysicsBodyCount++ ] = body;
        return body;
    }
    ...
    ```

8.  根据小行星的速度在`update()`中移动小行星。计算是根据两个游戏步骤之间的时间量执行的:

    ```cpp
    ...
    void PhysicsManager::update() {
        float timeStep = mTimeManager.elapsed();
        for (int32_t i = 0; i < mPhysicsBodyCount; ++ i) {
            PhysicsBody* body = mPhysicsBodies[i];
            body->location->x += (timeStep * body->velocityX);
            body->location->y += (timeStep * body->velocityY);
        }
    }
    ```

9.  Create the `jni/Asteroid.hpp` component with the following methods:
    *   `initialize()`游戏开始时设置具有随机属性的小行星
    *   `update()`探测超出游戏边界的小行星
    *   `spawn()`被`initialize()`和`update()`用来建立一个单独的小行星

    我们还需要以下成员:

    *   `mBodies`和`mBodyCount`存储需要管理的小行星列表
    *   几个整数成员来存储游戏边界

        ```cpp
        #ifndef _PACKT_ASTEROID_HPP_
        #define _PACKT_ASTEROID_HPP_

        #include "GraphicsManager.hpp"
        #include "PhysicsManager.hpp"
        #include "TimeManager.hpp"
        #include "Types.hpp"

        class Asteroid {
        public:
            Asteroid(android_app* pApplication,
                TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,
                PhysicsManager& pPhysicsManager);

            void registerAsteroid(Location& pLocation, int32_t pSizeX,
                    int32_t pSizeY);

            void initialize();
            void update();

        private:
            void spawn(PhysicsBody* pBody);

            TimeManager& mTimeManager;
            GraphicsManager& mGraphicsManager;
            PhysicsManager& mPhysicsManager;

            PhysicsBody* mBodies[1024]; int32_t mBodyCount;
            float mMinBound;
            float mUpperBound; float mLowerBound;
            float mLeftBound; float mRightBound;
        };
        #endif
        ```

10.  写这个`jni/Asteroid.cpp`实现。从几个常量开始，以及构造函数和注册方法，如下:

    ```cpp
    #include "Asteroid.hpp"
    #include "Log.hpp"

    static const float BOUNDS_MARGIN = 128;
    static const float MIN_VELOCITY = 150.0f, VELOCITY_RANGE = 600.0f;

    Asteroid::Asteroid(android_app* pApplication,
            TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,
            PhysicsManager& pPhysicsManager) :
        mTimeManager(pTimeManager),
        mGraphicsManager(pGraphicsManager),
        mPhysicsManager(pPhysicsManager),
        mBodies(), mBodyCount(0),
        mMinBound(0.0f),
        mUpperBound(0.0f), mLowerBound(0.0f),
        mLeftBound(0.0f), mRightBound(0.0f) {
    }

    void Asteroid::registerAsteroid(Location& pLocation,
            int32_t pSizeX, int32_t pSizeY) {
        mBodies[mBodyCount++ ] = mPhysicsManager.loadBody(pLocation,
                pSizeX, pSizeY);
    }
    ...
    ```

11.  Set up boundaries in `initialize()`. Asteroids are generated above the top of screen (in `mMinBound`, the maximum boundary `mUpperBound` is twice the height of the screen). They move from the top to the bottom of the screen. Other boundaries correspond to screen edges padded with a margin (representing twice the size of an asteroid).

    然后，使用`spawn()`初始化所有小行星:

    ```cpp
    ...
    void Asteroid::initialize() {
        mMinBound = mGraphicsManager.getRenderHeight();
        mUpperBound = mMinBound * 2;
        mLowerBound = -BOUNDS_MARGIN;
        mLeftBound = -BOUNDS_MARGIN;
        mRightBound = (mGraphicsManager.getRenderWidth() + BOUNDS_MARGIN);

        for (int32_t i = 0; i < mBodyCount; ++ i) {
            spawn(mBodies[i]);
        }
    }
    ...
    ```

12.  在每个游戏步骤中，检查出界的小行星并重新初始化:

    ```cpp
    ...
    void Asteroid::update() {
        for (int32_t i = 0; i < mBodyCount; ++ i) {
            PhysicsBody* body = mBodies[i];
            if ((body->location->x < mLeftBound)
             || (body->location->x > mRightBound)
             || (body->location->y < mLowerBound)
             || (body->location->y > mUpperBound)) {
                spawn(body);
            }
        }
    }
    ...
    ```

13.  最后，初始化`spawn()`中的每个小行星，速度和位置随机生成:

    ```cpp
    ...
    void Asteroid::spawn(PhysicsBody* pBody) {
        float velocity = -(RAND(VELOCITY_RANGE) + MIN_VELOCITY);
        float posX = RAND(mGraphicsManager.getRenderWidth());
        float posY = RAND(mGraphicsManager.getRenderHeight())
                      + mGraphicsManager.getRenderHeight();

        pBody->velocityX = 0.0f;
        pBody->velocityY = velocity;
        pBody->location->x = posX;
        pBody->location->y = posY;
    }
    ```

14.  将新创建的管理器和组件添加到`jni/DroidBlaster.hpp` :

    ```cpp
    #ifndef _PACKT_DROIDBLASTER_HPP_
    #define _PACKT_DROIDBLASTER_HPP_

    #include "ActivityHandler.hpp"
    #include "Asteroid.hpp"
    #include "EventLoop.hpp"
    #include "GraphicsManager.hpp"
    #include "PhysicsManager.hpp"
    #include "Ship.hpp"
    #include "TimeManager.hpp"
    #include "Types.hpp"

    class DroidBlaster : public ActivityHandler {
        ...
    private:
        TimeManager     mTimeManager;
        GraphicsManager mGraphicsManager;
        PhysicsManager  mPhysicsManager;
        EventLoop mEventLoop;

        Asteroid mAsteroids;
        Ship mShip;
    };
    #endif
    ```

15.  在`jni/DroidBlaster.cpp`构造器中用`GraphicsManager`和`PhysicsManager`注册小行星:

    ```cpp
    ...
    static const int32_t SHIP_SIZE = 64;
    static const int32_t ASTEROID_COUNT = 16;
    static const int32_t ASTEROID_SIZE = 64;

    DroidBlaster::DroidBlaster(android_app* pApplication):
        mTimeManager(),
        mGraphicsManager(pApplication),
        mPhysicsManager(mTimeManager, mGraphicsManager),
        mEventLoop(pApplication, *this),

        mAsteroids(pApplication, mTimeManager, mGraphicsManager,
     mPhysicsManager),
        mShip(pApplication, mGraphicsManager) {
        Log::info("Creating DroidBlaster");

        GraphicsElement* shipGraphics = mGraphicsManager.registerElement(
                SHIP_SIZE, SHIP_SIZE);
        mShip.registerShip(shipGraphics);

        for (int32_t i = 0; i < ASTEROID_COUNT; ++ i) {
     GraphicsElement* asteroidGraphics =
     mGraphicsManager.registerElement(ASTEROID_SIZE,
     ASTEROID_SIZE);
     mAsteroids.registerAsteroid(
     asteroidGraphics->location, ASTEROID_SIZE,
     ASTEROID_SIZE);
        }
    }
    ...
    ```

16.  正确初始化`onActivate()`中新增的类:

    ```cpp
    ...
    status DroidBlaster::onActivate() {
        Log::info("Activating DroidBlaster");

        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;

        mAsteroids.initialize();
        mShip.initialize();

        mTimeManager.reset();
        return STATUS_OK;
    }
    ...
    Finally, update managers and components for each game step:
    ...
    status DroidBlaster::onStep() {
        mTimeManager.update();
        mPhysicsManager.update();

        mAsteroids.update();

        return mGraphicsManager.update();
    }
    ...
    ```

## *刚刚发生了什么？*

编译并运行应用。这次应该会更有生气一点！代表小行星的红色方块以恒定的节奏穿过屏幕。`TimeManger`有助于设定速度。

![What just happened?](graphics/9645_05_05.jpg)

计时器对于以正确的速度显示动画和动作至关重要。它们可以用 POSIX 方法`clock_gettime()`实现，该方法以高精度检索时间，理论上精确到纳秒。

在本教程中，我们使用`CLOCK_MONOTONIC`标志来设置计时器。单调时钟给出过去从任意起点开始经过的时钟时间。它不受潜在系统日期变化的影响，因此不能像其他选项一样回到过去。`CLOCK_MONOTONIC`的缺点是它是特定于系统的，不能保证得到支持。希望安卓支持它，但是在将安卓代码移植到其他平台时要小心。安卓需要注意的另一点是，当系统暂停时，单调时钟会停止。

另一种不太精确且受系统时间变化影响的选择是`gettimeofday()`，也在`ctime`中提供。用法类似，但精度是以微秒而不是纳秒为单位。以下可能是一个使用示例，可以取代当前在`TimeManager`中的`now()`实现:

```cpp
double TimeManager::now() {
    timeval lTimeVal;
    gettimeofday(&lTimeVal, NULL);
    return (lTimeVal.tv_sec * 1000.0) + (lTimeVal.tv_usec / 1000.0);
}
```

欲了解更多信息，请查看 http://man7.org/linux/man-pages/man2/clock_gettime.2.html T2 的手册页。

# 总结

安卓 NDK 允许我们编写完全原生的应用，而不需要一行 Java 代码。`NativeActivity`提供一个框架来实现处理应用事件的事件循环。与 Posix 时间管理 API 相关联，NDK 提供了构建复杂多媒体应用或游戏所需的基础。

总之，我们创建了`NativeActivity`，轮询活动事件以相应地启动或停止本机代码。我们像位图一样访问显示窗口，以显示原始图形。最后，我们检索时间，使用单调时钟使应用适应设备速度。

这里启动的基本框架将构成我们将在本书中开发的 2D/3D 游戏的基础。然而，虽然平面设计现在很流行，但我们需要比红色方块更花哨的东西！

在下一章中，我们将发现如何使用 OpenGL ES 2 为 Android 渲染高级图形。