# 第七章。360 度画廊

360 度照片和视频是虚拟现实的不同方式。你不是用 OpenGL 实时渲染三维几何图形，而是让用户环视预先渲染或拍摄的场景。360 度视角是向消费者介绍 VR 的绝佳方式，因为它给人一种非常自然的体验，而且易于制作。拍摄照片比实时渲染物体的真实感场景要容易得多。使用新一代 360 度相机或谷歌相机应用程序中的光球功能，可以轻松记录图像。观看预先录制的图像比渲染完整的 3D 场景需要更少的计算机能力，这在移动纸板观众上运行良好。电池电量应该也不是什么大问题。

非 VR 360 度媒体已经变得相当普遍。例如，多年来，房地产上市网站已经提供了基于网络播放器的全景漫游，让您可以交互式地查看空间。同样，YouTube 支持 360 度视频的上传和回放，并为播放器提供了在回放过程中四处查看的交互式控件。谷歌地图允许你上传 360 度静止光球图像，很像他们的街景工具，你可以用安卓或 iOS 应用程序(更多信息，请访问[https://www.google.com/maps/about/contribute/photosphere/](https://www.google.com/maps/about/contribute/photosphere/))或消费者 360 相机创建。互联网充斥着 360 度媒体！

在虚拟现实中观看 360 度媒体令人惊讶地身临其境，即使是静态照片(甚至没有一对立体图像)。你站在一个球体的中心，一幅图像投射在球体的内表面，但你感觉自己真的在捕捉到的场景中。只需转过头四处看看。

在这个项目中，我们将建立一个照片库，让您在手机上浏览照片。常规的平面图片和全景图会出现在你左边的大屏幕上。但是 360 度光球会让你完全沉浸在球形投影中。我们将通过执行以下步骤来完成该项目:

*   设置新项目
*   观看 360 度光球
*   在大型虚拟投影屏幕上查看普通照片
*   给照片添加边框
*   从设备的相机文件夹加载和显示照片图像
*   调整照片的方向和纵横比
*   创建带有缩略图网格的用户界面，用于选择要滚动查看的照片
*   通过线程安全操作，确保良好、响应迅速的虚拟现实体验
*   启动安卓图像查看意图应用

这个项目的源代码可以在 Packt Publishing 网站上找到，也可以在 https://github.com/cardbookvr/gallery360 的 GitHub 上找到(每个主题都有一个单独的提交)。

# 建立新项目

为了构建这个项目，我们将使用在[第 5 章](05.html "Chapter 5. RenderBox Engine")*渲染盒引擎*中创建的`RenderBox`库。您可以使用您的，或者从本书或我们的 GitHub repo 提供的下载文件中获取一份副本(使用提交标记的`after-ch6`—[https://GitHub . com/cardbookr/renderboxlib/releases/tag/after-ch6](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch6))。关于如何导入`RenderBox`库的更详细的描述，请参考[第 5 章](05.html "Chapter 5. RenderBox Engine")、 *RenderBox 引擎*中的最后一节*在未来项目中使用 render box*。为此，请执行以下步骤:

1.  安卓工作室打开后，创建一个新项目。让我们将其命名为`Gallery360`，并以**空活动**为目标**安卓 4.4 KitKat (API 19)** 。
2.  使用**文件** | **新模块** | **导入为`renderbox`、`common`和`core`包创建新模块。JAR/。AAR 包装**。
3.  使用**文件** | **项目结构**，将模块设置为应用程序的依赖项。
4.  按照[第 2 章](02.html "Chapter 2. The Skeleton Cardboard Project")、*骨架纸板项目*中的说明编辑`build.gradle`文件，根据 SDK 22 进行编译。
5.  更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，如前几章所述。
6.  将`MainActivity`编辑为`class MainActivity extends CardboardActivity implements IRenderBox`，实现接口方法存根( *Ctrl* + *I* )。

我们可以在`MainActivity`中定义`onCreate`方法。该类现在具有以下代码:

```java
public class MainActivity extends CardboardActivity implements IRenderBox {
    private static final String TAG = "Gallery360";
    CardboardView cardboardView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        cardboardView = (CardboardView) findViewById(R.id.cardboard_view);
        cardboardView.setRenderer(new RenderBox(this, this));
        setCardboardView(cardboardView);
    }
    @Override
    public void setup() {

    }
    @Override
    public void preDraw() {
        // code run beginning each frame
    }
    @Override
    public void postDraw() {
        // code run end of each frame
    }
}
```

当我们实施这个项目时，我们将创建新的类，这些类可能是`RenderBoxLib`的良好扩展。在这个项目中，我们首先会让他们成为常规班级。然后，在这一章的最后，我们将帮助您将它们移入`RenderBoxLib`项目并重建库。请执行以下步骤:

1.  右键点击`gallery360`文件夹(`com.cardbookvr.gallery360`)进入**新建** | **包**，命名包`RenderBoxExt`。
2.  在`RenderBoxExt`内，创建名为`components`和`materials`的包子文件夹。

没有真正的技术需求使它成为一个单独的包，但这有助于组织我们的文件，因为`RenderBoxExt`中的文件将在本章结束时被移动到我们的可重用库中。

您可以暂时向场景中添加一个立方体，以帮助确保一切设置正确。将其添加到`setup`方法中，如下所示:

```java
    public void setup() {
        new Transform()
            .setLocalPosition(0,0,-7)
            .setLocalRotation(45,60,0)
            .addComponent(new Cube(true));
    }
```

如果你记得的话，立方体是一个添加到变换中的组件。立方体定义其几何形状(例如顶点)。变换定义了它在三维空间中的位置、旋转和缩放。

你应该可以在没有编译错误的情况下点击**运行‘app’**，并在你的安卓设备上看到立方体和纸板的分屏视图。

# 观看 360 度照片

自从发现地球是圆的以来，制图员和水手们一直在努力研究如何将球形地球投影到二维图表上。其结果是全球某些地区不可避免的扭曲。

### 注

要了解更多关于地图投影和球面扭曲的信息，请访问[http://en.wikipedia.org/wiki/Map_projection](http://en.wikipedia.org/wiki/Map_projection)。

对于 360 度媒体，我们通常使用等矩形(或子午线)投影，其中球体被分解成圆柱形投影，当您向北极和南极前进时拉伸纹理，同时保持子午线为等距的垂直直线。为了说明这一点，考虑天梭的指示图(访问[http://en.wikipedia.org/wiki/Tissot%27s_indicatrix](http://en.wikipedia.org/wiki/Tissot%27s_indicatrix)了解更多信息)，它显示了一个带有战略性排列的相同圆圈的地球仪(斯特凡·库恩的插图):

![Viewing a 360-degree photo](graphics/B05144_07_01.jpg)

下图显示了用等矩形投影([https://en.wikipedia.org/wiki/Equirectangular_projection](https://en.wikipedia.org/wiki/Equirectangular_projection))展开的地球仪:

![Viewing a 360-degree photo](graphics/B05144_07_02.jpg)

我们将使用一个等矩形网格作为我们的光球，使用一个适当投影(扭曲)的图像作为它的纹理贴图。为了查看，我们将相机视点放置在球体的中心，并将图像渲染到内表面上。

你可能已经注意到我们的地球和其他星球的纹理有同样的扭曲。将球面图像映射到平面图像是一种非常常见的方法，事实上，自从我们在[第 6 章](06.html "Chapter 6. Solar System")、*太阳系*中为我们的球体创建 UV 以来，我们就一直在“计算”这个问题！你必须聪明地使用紫外线偏移来防止它们看起来拉伸，但是你也应该能够以同样的方式在球体上显示全景照片。

## 查看光球样本

您可以为这个主题选择任意 360 度等矩形图像。我们在这本名叫`sample360.jpg`的书中加入了以下海滩照片:

![Viewing a sample photosphere](graphics/B05144_07_03.jpg)

将其添加到您的项目中。

将您想要查看的图像复制到项目的`res/drawable/`文件夹中。现在将以下代码添加到`MainActivity.java`文件中:

```java
    final int DEFAULT_BACKGROUND = R.drawable.sample360;

    Sphere photosphere;

    @Override
    public void setup() {
        setupBackground();
    }

    void setupBackground() {
        photosphere = new Sphere(DEFAULT_BACKGROUND, false);
        new Transform()
            .setLocalScale(Camera.Z_FAR * 0.99f, -Camera.Z_FAR * 0.99f, Camera.Z_FAR * 0.99f)
            .addComponent(photosphere);
    }
```

请注意，将比例乘以 0.99 可以避免由于某些手机上的浮点精度错误而对背景图像进行不必要的裁剪。使用负比例 *y* 轴补偿纹理着色器的反转渲染(或者，您可以修改着色器代码)。

您可以将可绘制的文件名`R.drawable.sample360`替换为您在`DEFAULT_BACKGROUND`变量中定义的文件名。这个变量必须是最终的，这是安卓资源系统所要求的。

在`setup`方法中，我们创建一个`Sphere`组件，就像我们一直在做的那样。从一个新的转换开始，缩放它，然后用我们的资源标识添加一个新的`Sphere`组件到转换中。我们将对象命名为`background`，因为稍后，该对象将成为应用程序的默认背景。

运行应用程序，将手机插入纸板浏览器。瞧啊。你在玛格丽塔维尔！！如果这看起来很容易，你是对的；是的。真的，这项艰苦的工作是由 photosphere 应用程序或其他工具为我们完成的，它们将图像转换成了等矩形投影。剩下的就是我们一直在做的标准 UV 投影数学！

![Viewing a sample photosphere](graphics/B05144_07_04.jpg)

## 使用背景图像

我们将制作一个图库，让用户从大量图片中进行选择。如果用户在第一次启动应用时看到一些更中性的东西，那就太好了。本书的可下载文件中包含了更合适的背景图片。它被命名为`bg.png`，包含一个规则的网格。复制到你的`res/drawable/`文件夹。然后，将`DEFAULT_BACKGROUND`改为`R.drawable.bg`。

![Using the background image](graphics/B05144_07_05.jpg)

重新运行应用，应该是这样的:

![Using the background image](graphics/B05144_07_06.jpg)

# 查看常规照片

现在已经完成了，让我们准备我们的应用程序，以便也能够查看常规的平面照片。我们将通过将它们渲染到一个平面上来实现这一点。所以首先我们需要定义一个`Plane`分量。

## 定义平面组件并分配缓冲区

`Plane`组件理所当然属于`RenderBox`库，但是暂时我们直接添加到 app 中。

在`RenderBoxExt/components/`文件夹新建一个 Java 类文件，命名为`Plane`。将其定义为`extends RenderObject`，如下:

```java
public class Plane extends RenderObject {
}
```

与`RenderBox`库中的其他几何图形一样，我们将使用三角形定义平面。只需两个相邻三角形，共六个索引。以下数据数组定义了我们默认平面的三维坐标、紫外线纹理坐标、顶点颜色(中间灰色)、法向量和相应的索引。在类的顶部添加以下代码:

```java
    public static final float[] COORDS = new float[] {
            -1.0f, 1.0f, 0.0f,
            1.0f, 1.0f, 0.0f,
            -1.0f, -1.0f, 0.0f,
            1.0f, -1.0f, 0.0f
    };
    public static final float[] TEX_COORDS = new float[] {
            0.0f, 1.0f,
            1.0f, 1.0f,
            0f, 0f,
            1.0f, 0f,
    };
    public static final float[] COLORS = new float[] {
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f
    };
    public static final float[] NORMALS = new float[] {
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f
    };
    public static final short[] INDICES = new short[] {
            0, 1, 2,
            1, 3, 2
    };
```

现在，我们可以定义`Plane`构造函数，它调用`allocateBuffers`辅助方法，为顶点、法线、纹理和索引分配缓冲区。让我们在类的顶部声明这些变量，并编写方法:

```java
    public static FloatBuffer vertexBuffer;
    public static FloatBuffer colorBuffer;
    public static FloatBuffer normalBuffer;
    public static FloatBuffer texCoordBuffer;
    public static ShortBuffer indexBuffer;
    public static final int numIndices = 6;

    public Plane(){
        super();
        allocateBuffers();
    }

    public static void allocateBuffers(){
        //Already allocated?
        if (vertexBuffer != null) return;
        vertexBuffer   = allocateFloatBuffer(COORDS);
        texCoordBuffer = allocateFloatBuffer(TEX_COORDS);
        colorBuffer    = allocateFloatBuffer(COLORS);
        normalBuffer   = allocateFloatBuffer(NORMALS);
        indexBuffer    = allocateShortBuffer(INDICES);
    }
```

再次，我们通过检查`vertexBuffer`是否为空来确保`allocateBuffers`只运行一次。(注意，我们已经决定声明缓冲区`public`，以提供未来为对象创建任意纹理材质的灵活性。)

## 向平面组件添加材料

接下来，我们可以给`Plane`添加一个合适的材质，一个使用纹理图像的材质。使用与第 6 章、*太阳系*中内置的`Sphere`组件一致的构造函数应用编程接口模式，我们将添加调用新的`Plane`的能力，该新的【】具有图像纹理标识和可选的照明布尔标志。然后，我们将添加辅助方法来分配相应的`Material`对象并设置它们的缓冲区:

```java
    public Plane(int textureId, boolean lighting) {
        super();
        allocateBuffers();
        if (lighting) {
            createDiffuseMaterial(textureId);
        } else {
            createUnlitTexMaterial(textureId);
        }
    }

    public Plane createDiffuseMaterial(int textureId) {
        DiffuseLightingMaterial mat = new DiffuseLightingMaterial(textureId);
        mat.setBuffers(vertexBuffer, normalBuffer, texCoordBuffer, indexBuffer, numIndices);
        material = mat;
        return this;
    }

    public Plane createUnlitTexMaterial(int textureId) {
        UnlitTexMaterial mat = new UnlitTexMaterial(textureId);
        mat.setBuffers(vertexBuffer, texCoordBuffer, indexBuffer, numIndices);
        material = mat;
        return this;
    }
```

## 向场景添加图像屏幕

我们现在可以在`MainActivity`中为场景添加一个图像。很快，我们将查看手机的照片文件夹中的图片，但此时，您可以使用我们之前使用的相同(光球)文件夹(或将另一个放在您的`res/drawable`文件夹中)。请注意，对于手机的图形处理器来说，显示太大的图像可能会有问题。我们将在稍后讨论这个问题，所以请尽量在任一维度上保持小于 4，096 像素。

命名对象`screen`，因为稍后，我们将使用它来投影用户从图库中选择的任何照片。

在`MainActivity.java`中，更新`setup`功能，将图像添加到场景中，如下所示:

```java
    Plane screen;

    public void setup() {
        setupBackground();
        setupScreen();
    }

    void setupScreen() {
        screen = new Plane(R.drawable.sample360, false);
        new Transform()
                .setLocalScale(4, 4, 1)
                .setLocalPosition(0, 0, -5)
                .setLocalRotation(0, 0, 180)
                .addComponent(screen);
    }
```

屏幕缩放至 4 个单位(X 和 Y 方向)，并在摄像机前放置 5 个单位。这就像坐在离 8 米宽的电影屏幕 5 米(15 英尺)的地方！

另外，请注意，我们将平面在 *z* 轴上旋转 180 度；否则，图像会出现颠倒。我们的世界坐标系沿着正 *y* 轴向上。但是，UV 空间(用于渲染纹理)的原点通常在左上角，正的是向下的。(如果你还记得，在前一章，这就是为什么我们也不得不翻转地球)。在本章的后面，当我们实现一个`Image`类时，我们将从图像文件中读取实际的方向，并相应地设置旋转。这是我们的屏幕平面图(从一个角度看):

![Adding an image screen to the scene](graphics/B05144_07_07.jpg)

将屏幕平面(及其图像纹理)与屏幕的位置和大小分开会很方便。我们稍后会看到为什么这很重要，但这与基于图像参数的缩放和旋转有关。让我们重构代码，使屏幕由`screenRoot`转换作为父级，如下所示:

```java
    void setupScreen() {
        Transform screenRoot = new Transform()
                .setLocalScale(4, 4, 1)
                .setLocalRotation(0, 0, 180)
                .setLocalPosition(0, 0, -5);

        screen = new Plane(R.drawable.sample360, false);

        new Transform()
                .setParent(screenRoot, false)
                .addComponent(screen);
    }
```

# 在图像上放置边框

图片在一帧中看起来最好。现在再加一个。有许多方法可以实现这一点，但是我们将使用着色器。该框架还将用于缩略图，并使我们能够在用户选择图像时更改颜色以突出显示。此外，它有助于定义对比度区域，确保您可以在任何背景上看到任何图像的边缘。

## 边框着色器

我们可以通过编写着色器程序来启动，其中包括从使用它的`Material`对象中定义它们需要的变量。

如有必要，为着色器`res/raw/`创建资源目录。然后，创建`border_vertex.shader`和`border_fragment.shader`文件。定义如下。

`border_vertex`着色器与我们使用的`unlit_tex_vertex`着色器相同。

文件:`res/raw/border_vertex.shader`

```java
uniform mat4 u_MVP;

attribute vec4 a_Position;
attribute vec2 a_TexCoordinate;

varying vec3 v_Position;
varying vec2 v_TexCoordinate;

void main() {
   // pass through the texture coordinate
   v_TexCoordinate = a_TexCoordinate;

   // final point in normalized screen coordinates
   gl_Position = u_MVP * a_Position;
}
```

对于`border_fragement`着色器，我们为边框颜色(`u_Color`)和宽度(`u_Width`)添加变量。然后，添加一点逻辑来决定当前渲染的坐标是在边界上还是在纹理图像中:

文件:`res/raw/border_fragment.shader`

```java
precision mediump float;
uniform sampler2D u_Texture; 

varying vec3 v_Position; 
varying vec2 v_TexCoordinate;
uniform vec4 u_Color;
uniform float u_Width;

void main() {
    // send the color from the texture straight out unless in // border area
    if(
        v_TexCoordinate.x > u_Width
        && v_TexCoordinate.x < 1.0 - u_Width
        && v_TexCoordinate.y > u_Width
        && v_TexCoordinate.y < 1.0 - u_Width
    ){
        gl_FragColor = texture2D(u_Texture, v_TexCoordinate);
    } else {
        gl_FragColor = u_Color;
    }
}
```

请注意，这种技术会切断图像的边缘。我们发现这是可以接受的，但是如果你真的想看到整个图像，你可以在`texture2D`采样器调用内偏移 UV 坐标。它看起来像这样:

```java
float scale = 1.0 / (1 - u_Width * 2);
Vec2 offset = vec(
    v_TexCoordinate.x * scale – u_Width,
    v_TexCoordinate.x * scale – u_Width);
gl_FragColor = texture2D(u_Texture, offset);
```

最后，观察力敏锐的读者可能会注意到，当平面被非均匀缩放(使其成为矩形)时，边框将被缩放，这样垂直边框可能比水平边框更厚或更薄。有很多方法可以解决这个问题，但这只是留给(过度成功的)读者的一个练习。

## 边框材质

接下来，我们为边界着色器定义材质。在`RenderBoxExt/materials/`中创建新的名为`BorderMaterial`的 Java 类，定义如下:

```java
public class BorderMaterial extends Material {
    private static final String TAG = "bordermaterial";

}
```

为纹理标识、边框宽度和颜色添加材质变量。然后，为着色器程序引用和缓冲区添加变量，如以下代码所示:

```java
    int textureId;
    public float borderWidth = 0.1f;
    public float[] borderColor = new float[]{0, 0, 0, 1}; // black
    static int program = -1; //Initialize to a totally invalid value for setup state
    static int positionParam;
    static int texCoordParam;
    static int textureParam;
    static int MVPParam;
    static int colorParam;
    static int widthParam;

    FloatBuffer vertexBuffer;
    FloatBuffer texCoordBuffer;
    ShortBuffer indexBuffer;
    int numIndices;
```

现在我们可以添加一个构造函数。正如我们之前看到的，它调用一个`setupProgram`辅助方法来创建着色器程序并获取对其参数的引用:

```java
    public BorderMaterial() {
        super();
        setupProgram();
    }

    public static void setupProgram() {
        //Already setup?
        if (program > -1) return;
        //Create shader program
        program = createProgram(R.raw.border_vertex, R.raw.border_fragment);

        //Get vertex attribute parameters
        positionParam = GLES20.glGetAttribLocation(program, "a_Position");
        texCoordParam = GLES20.glGetAttribLocation(program, "a_TexCoordinate");

        //Enable them (turns out this is kind of a big deal ;)
        GLES20.glEnableVertexAttribArray(positionParam);
        GLES20.glEnableVertexAttribArray(texCoordParam);

        //Shader-specific parameters
        textureParam = GLES20.glGetUniformLocation(program, "u_Texture");
        MVPParam = GLES20.glGetUniformLocation(program, "u_MVP");
        colorParam = GLES20.glGetUniformLocation(program, "u_Color");
        widthParam = GLES20.glGetUniformLocation(program, "u_Width");
        RenderBox.checkGLError("Border params");
    }
```

同样地，我们添加一个`setBuffers`方法，由`RenderObject`组件(`Plane`)调用:

```java
public void setBuffers(FloatBuffer vertexBuffer, FloatBuffer texCoordBuffer, ShortBuffer indexBuffer, int numIndices){
        //Associate VBO data with this instance of the material
        this.vertexBuffer = vertexBuffer;
        this.texCoordBuffer = texCoordBuffer;
        this.indexBuffer = indexBuffer;
        this.numIndices = numIndices;
    }
```

为纹理标识提供设置方法:

```java
    public void setTexture(int textureHandle) {
        textureId = textureHandle;
    }
```

添加将从`Camera`组件调用的绘制代码，以渲染缓冲区中准备的几何图形(通过`setBuffer`)。绘制方法如下所示:

```java
    @Override
    public void draw(float[] view, float[] perspective) {
        GLES20.glUseProgram(program);

        // Set the active texture unit to texture unit 0.
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);

        // Bind the texture to this unit.
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);

        // Tell the texture uniform sampler to use this texture in // the shader by binding to texture unit 0.
        GLES20.glUniform1i(textureParam, 0);

        Matrix.multiplyMM(modelView, 0, view, 0, RenderObject.model, 0);
        Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);
        // Set the ModelViewProjection matrix for eye position.
        GLES20.glUniformMatrix4fv(MVPParam, 1, false, modelViewProjection, 0);

        GLES20.glUniform4fv(colorParam, 1, borderColor, 0);
        GLES20.glUniform1f(widthParam, borderWidth);

        //Set vertex attributes
        GLES20.glVertexAttribPointer(positionParam, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer);
        GLES20.glVertexAttribPointer(texCoordParam, 2, GLES20.GL_FLOAT, false, 0, texCoordBuffer);

        GLES20.glDrawElements(GLES20.GL_TRIANGLES, numIndices, GLES20.GL_UNSIGNED_SHORT, indexBuffer);

        RenderBox.checkGLError("Border material draw");
    }
```

还有一件事；让我们提供一种销毁现有材料的方法:

```java
    public static void destroy(){
        program = -1;
    }
```

## 使用边框材质

要使用类而不是默认的`UnlitTexMaterial`类，我们之前在`Plane`类中写过，我们可以将其添加到`Plane` Java 类中，如下所示。我们计划在`Plane`类之外(在`MainActivity`中)创建素材，所以我们只需要设置它。在`Plane.java`中，添加以下代码:

```java
    public void setupBorderMaterial(BorderMaterial material){
        this.material = material;
        material.setBuffers(vertexBuffer, texCoordBuffer,         indexBuffer, numIndices);
    }
```

在`MainActivity`中，修改`setupScreen`方法以使用该材料而不是默认材料，如下所示。我们首先创建材质，并将纹理设置为样本图像。我们不需要设置颜色，默认为黑色。然后我们创建屏幕平面并设置其材质。然后创建转换并添加屏幕组件:

```java
    void setupScreen() {
        //...
        Screen = new Plane();
        BorderMaterial screenMaterial = new BorderMaterial();
        screenMaterial.setTexture(RenderBox.loadTexture( R.drawable.sample360));
        screen.setupBorderMaterial(screenMaterial);
        //...

}
```

当您现在运行它时，它应该看起来像这样:

![Using the border material](graphics/B05144_07_08.jpg)

# 加载并显示照片图像

到目前为止，我们已经在项目的`drawable`资源文件夹中使用了图像。下一步是从手机上读取照片图像，并在我们的虚拟屏幕上显示一张。

## 定义图像类别

让我们做一个占位`Image`类。稍后，我们将构建属性和方法。定义如下:

```java
public class Image {
    final static String TAG = "image";
    String path;
    public Image(String path) {
        this.path = path;
    }
    public static boolean isValidImage(String path){
        String extension = getExtension(path);
        if(extension == null)
            return false;
        switch (extension){
            case "jpg":
                return true;
            case "jpeg":
                return true;
            case "png":
                return true;
        }
        return false;
    }
    static String getExtension(String path){
        String[] split = path.split("\\.");
        if(split== null || split.length < 2)
            return null;
        return split[split.length - 1].toLowerCase();
    }
}
```

我们定义了一个构造函数，它采用图像的完整路径。我们还提供了一种验证方法，根据文件扩展名检查路径是否是图像的路径。我们不想在构建时加载和绑定图像数据，因为我们不想一次加载所有图像；正如您将看到的，我们将使用工作线程智能地管理这些。

## 将图像读入应用程序

现在进入`MainActivity`，进入手机上的照片文件夹，在我们的 app 里建立一个图片列表。下面的`getImageList`助手方法查看给定的文件夹路径，并为找到的每个文件实例化一个新的`Image`对象:

```java
    final List<Image> images = new ArrayList<>();

    int loadImageList(String path) {
        File f = new File(path);
        File[] file = f.listFiles();
        if (file==null)
            return 0;
        for (int i = 0; i < file.length; i++) {
            if (Image.isValidImage(file[i].getName())) {
                Image img = new Image(path + "/" + file[i].getName());
                images.add(img);
            }
        }
        return file.length;
    }
```

在`setup`方法中使用此方法，传入相机图像文件夹路径的名称，如下所示(您的路径可能会有所不同):

```java
    final String imagesPath = "/storage/emulated/0/DCIM/Camera";

    public void setup() {
        …

        loadImageList(imagesPath);
    }
```

此外，确保以下行包含在您的`AndroidManifest.xml`文件中，给予应用程序读取设备外部存储的权限。从技术上来说，在使用纸板软件开发工具包时，您应该已经拥有此权限:

```java
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
```

您可以向`getImageList`循环添加一条日志消息，并运行它来验证它正在查找文件。如果没有，您可能需要找到照片文件夹的实际路径。

这是第一个我们需要非常小心权限的项目。到目前为止，纸板软件开发工具包本身是唯一需要访问文件系统的东西，但是现在我们需要它来让应用程序本身运行。如果你使用的是带有 Andriod 6.0 的设备，并且你没有确保根据 SDK 22 编译应用程序，你将无法加载图像文件，应用程序要么什么都不做，要么崩溃。

如果您正在根据 SDK 22 编译，并且您在清单中正确设置了权限，但您仍然得到一个空的文件列表，请尝试使用文件浏览器在您的设备上查找正确的路径。很可能我们提供的路径不存在或者是空的。当然，要确保你已经用那个设备拍了一张照片！

## 图像加载纹理

如果你还记得，在[第 6 章](06.html "Chapter 6. Solar System")、*太阳系、*中，我们写了一个`loadTexture`方法，将项目`res/drawable`文件夹中的静态图像读入内存位图，并将其绑定到 OpenGL 中的纹理。在这里，我们将做一些类似的事情，但是从手机的相机路径获取图像，并提供额外处理的方法，例如调整其大小和旋转其方向。

在`Image`类的顶部，添加一个变量来保持当前的纹理手柄:

```java
    int textureHandle;
```

给定图像文件的路径，图像的`loadTexture`方法会将图像文件加载到位图中，然后将其转换为纹理。(这个方法将从`MainActivity`用 app 的`CardboardView`类调用。)写如下:

```java
    public void loadTexture(CardboardView cardboardView) {
        if (textureHandle != 0)
            return;
        final Bitmap bitmap = BitmapFactory.decodeFile(path);
        if (bitmap == null){
            throw new RuntimeException("Error loading bitmap.");
        }
        textureHandle = bitmapToTexture(bitmap);
    }
```

我们添加了一个小的(但重要的)优化，检查纹理是否已经加载；如果不需要，就不要再做了。

我们对`bitmapToTexture`的实现如下代码所示。给定一个位图，它将位图绑定到一个 OpenGL ES 纹理(带有一些错误检查)。将以下代码添加到`Image`:

```java
    public static int bitmapToTexture(Bitmap bitmap){
        final int[] textureHandle = new int[1];

        GLES20.glGenTextures(1, textureHandle, 0);
        RenderBox.checkGLError("Bitmap GenTexture");

        if (textureHandle[0] != 0) {
            // Bind to the texture in OpenGL
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureHandle[0]);

            // Set filtering
            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST);
            GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_NEAREST);

            // Load the bitmap into the bound texture.
            GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);
        }
        if (textureHandle[0] == 0){
            throw new RuntimeException("Error loading texture.");
        }

        return textureHandle[0];
    }
```

## 在屏幕上显示图像

让我们在应用程序中显示我们的一个相机图像，比如说，第一个。

为了在虚拟屏幕上显示图像，我们可以编写一个`show`方法，将当前的`CardboardView`对象和`Plane`屏幕结合起来。它将加载和绑定图像纹理，并将其句柄传递给材质。在`Image`类中，执行如下`show`方法:

```java
    public void show(CardboardView cardboardView, Plane screen) {
        loadTexture(cardboardView);
        BorderMaterial material = (BorderMaterial) screen.getMaterial();
        material.setTexture(textureHandle);
    }
```

现在让我们用这些东西！转到`MainActivity`并编写单独的`showImage`方法加载图像纹理。暂时用我们找到的第一张图片从`setup`调用它(您的相机文件夹中至少需要一张图片):

```java
    public void setup() {
        setupBackground();
        setupScreen();
        loadImageList(imagesPath);
        showImage(images.get(0));
    }

    void showImage(Image image) {
        image.show(cardboardView, screen);
    }
```

现在修改`setupScreen,`也是有意义的，这样它可以创建屏幕，但不会加载图像纹理。取消对里面`screenMaterial.setTexture`的调用。

现在运行该应用程序，您将在屏幕上看到自己的图像。这是我的:

![Showing an image on the screen](graphics/B05144_07_09.jpg)

## 旋转到正确的方向

某些图像文件类型会跟踪其图像方向，尤其是 JPG 文件(`.jpg`或`.jpeg`)。我们可以从相机应用程序编写的文件中包含的 EXIF 元数据获得方向值。(例如参考[http://sylvana.net/jpegcrop/exif_orientation.html](http://sylvana.net/jpegcrop/exif_orientation.html)。请注意，某些设备可能不兼容或包含不同的结果。)

如果图像不是 JPG，我们将跳过这一步。

在`Image`类的顶部，声明一个变量来保存当前的图像旋转:

```java
    Quaternion rotation;
```

`rotation`值存储为一个`Quaternion`实例，如我们的 RenderBox 数学库中所定义的。如果你还记得[第 5 章](05.html "Chapter 5. RenderBox Engine")、 *RenderBox Engine* 的话，四元数代表了三维空间中的旋转方向，比欧拉角更精确，也更不模糊。但是欧拉角更人性化，为每个 *x* 、 *y* 和 *z* 轴指定一个角度。因此，我们将根据图像方向使用欧拉角设置四元数。最终，我们在这里使用了`Quaternion`，因为它是`Transform.rotation`的基础类型:

```java
    void calcRotation(Plane screen){
        rotation = new Quaternion();

        // use Exif tags to determine orientation, only available // in jpg (and jpeg)
        String ext = getExtension(path);
        if (ext.equals("jpg") || ext.equals("jpeg")) {

            try {
                ExifInterface exif = new ExifInterface(path);
                switch (exif.getAttribute(ExifInterface.TAG_ORIENTATION)) {
                    // Correct orientation, but flipped on the // horizontal axis
                    case "2":
                        rotation = new Quaternion().setEulerAngles(180, 0, 0);
                        break;
                    // Upside-down
                    case "3":
                        rotation = new Quaternion().setEulerAngles(0, 0, 180);
                        break;
                    // Upside-Down & Flipped along horizontal axis
                    case "4":
                        rotation = new Quaternion().setEulerAngles(180, 0, 180);
                        break;
                    // Turned 90 deg to the left and flipped
                    case "5":
                        rotation = new Quaternion().setEulerAngles(0, 180, 90);
                        break;
                    // Turned 90 deg to the left
                    case "6":
                        rotation = new Quaternion().setEulerAngles(0, 0, -90);
                        break;
                    // Turned 90 deg to the right and flipped
                    case "7":
                        rotation = new Quaternion().setEulerAngles(0, 180, 90);
                        break;
                    // Turned 90 deg to the right
                    case "8":
                        rotation = new Quaternion().setEulerAngles(0, 0, 90);
                        break;
                    //Correct orientation--do nothing
                    default:
                        break;
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        screen.transform.setLocalRotation(rotation);
    }
```

现在我们在`Image`类的`show`方法中设置屏幕的旋转，如下所示:

```java
    public void show(CardboardView cardboardView, Plane screen) {
        loadTexture(cardboardView);
        BorderMaterial material = (BorderMaterial) screen.getMaterial();
        material.setTexture(textureHandle);
        calcRotation(screen);
    }
```

再次运行您的项目。图像应该正确定位。请注意，您的原始图像可能一直很好。一旦我们开始缩略图网格，检查您的旋转代码是否工作将变得更加容易。

![Rotating to the correct orientation](graphics/B05144_07_10.jpg)

## 校正宽度和高度的尺寸

正方形图像很容易。但通常，照片是矩形的。我们可以获得图像的实际宽度和高度，并相应地缩放屏幕，这样显示就不会失真。

在`Image`类的顶部，声明变量来保存当前图像的宽度和高度:

```java
    int height, width;
```

然后，使用`decodeFile`方法中的位图选项在`loadTexture`中设置它们，如下所示:

```java
    public void loadTexture(CardboardView cardboardView) {
        if (textureHandle != 0)
            return;
        BitmapFactory.Options options = new BitmapFactory.Options();
        final Bitmap bitmap = BitmapFactory.decodeFile(path, options);
        if (bitmap == null){
            throw new RuntimeException("Error loading bitmap.");
        }
        width = options.outWidth;
        height = options.outHeight;
        textureHandle = bitmapToTexture(bitmap);
    }
```

`decodeFile`调用返回选项中图像的宽度和高度(以及其他信息)(参考[http://developer . Android . com/reference/Android/graphics/BitmapFactory。Options.html](http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html)。

现在我们可以在`Image`类的`show`方法中设置屏幕大小。我们将标准化比例，使长边的尺寸为 1.0，短边的尺寸计算为图像纵横比:

```java
    public void show(CardboardView cardboardView, Plane screen) {
        loadTexture(cardboardView);
        BorderMaterial material = (BorderMaterial) screen.getMaterial();
        material.setTexture(textureHandle);
        calcRotation(screen);
        calcScale(screen);
    }

    void calcScale(Plane screen) {
        if (width > 0 && width > height) {
            screen.transform.setLocalScale(1, (float) height / width, 1);
        } else if(height > 0) {
            screen.transform.setLocalScale((float) width / height, 1, 1);
        }
    }
```

如果您现在运行它，屏幕将具有图像的正确纵横比:

![Dimensions to correct the width and height](graphics/B05144_07_11.jpg)

## 将图像缩小至样本大小

你手机里的摄像头大概很牛逼吧！可能真的超级棒！当打印或进行大量裁剪时，数百万像素的图像非常重要。但是在我们的应用程序中查看时，我们不需要全分辨率图像。事实上，如果图像大小生成的纹理对于设备硬件来说太大，您可能已经无法运行该项目。

当加载纹理时，我们可以通过限制最大尺寸和缩放位图来适应这个问题。我们将要求 OpenGL ES 给我们它当前的最大纹理大小。我们将在`MainActivity,`中这样做，所以它通常是可用的(和/或将其移到您的`RenderBox`库项目中的`RenderBox`类中)。在`MainActivity`中增加以下内容:

```java
    static int MAX_TEXTURE_SIZE = 2048;

    void setupMaxTextureSize() {
        //get max texture size
        int[] maxTextureSize = new int[1];
        GLES20.glGetIntegerv(GLES20.GL_MAX_TEXTURE_SIZE, maxTextureSize, 0);
        MAX_TEXTURE_SIZE = maxTextureSize[0];
        Log.i(TAG, "Max texture size = " + MAX_TEXTURE_SIZE);
    }
```

我们称之为`MainActivity`类的`setup`方法的第一行。

至于缩放图片，遗憾的是，安卓的`BitmapFactory`并没有让你直接请求一个新尺寸的采样图片。相反，给定任意图像，您可以指定采样率，例如每隔一个像素(2)，每隔四个像素(4)，等等。一定是 2 的幂。

回到`Image`班。首先，我们将在`loadTexture`中添加一个`sampleSize`参数，可以作为`decodeFile`的参数，如下所示:

```java
    public void loadTexture(CardboardView cardboardView, int sampleSize) {
        if (textureHandle != 0)
            return;
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inSampleSize = sampleSize;
        final Bitmap bitmap = BitmapFactory.decodeFile(path, options);
        if(bitmap == null){
            throw new RuntimeException("Error loading bitmap.");
        }
        width = options.outWidth;
        height = options.outHeight;
        textureHandle = bitmapToTexture(bitmap);
    }
```

为了确定一个合适的图像样本大小，我们需要首先找出它的全部尺寸，然后计算出什么样的样本大小最接近它，但小于我们要使用的最大纹理大小。数学并不太难，但是我们将使用一种程序方法来搜索最佳尺寸值，而不是去经历它。

幸运的是，`decodeFile`的输入选项之一是只检索图像边界，不实际加载图像。编写一个名为`loadFullTexture`的新加载纹理方法，如下所示:

```java
    public void loadFullTexture(CardboardView cardboardView) {
        // search for best size
        int sampleSize = 1;
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        do {
            options.inSampleSize = sampleSize;
            BitmapFactory.decodeFile(path, options);
            sampleSize *= 2;
        } while (options.outWidth > MainActivity.MAX_TEXTURE_SIZE || options.outHeight > MainActivity.MAX_TEXTURE_SIZE);
        sampleSize /= 2;
        loadTexture(cardboardView, sampleSize);
    }
```

我们不断增加样本量，直到找到一个在`MAX_TEXTURE_SIZE`范围内产生位图的样本，然后调用`loadTexture`。

使用`show`方法中的`loadFullTexture`代替另一个`loadTexture`方法:

```java
    public void show(CardboardView cardboardView, Plane screen) {
        loadFullTexture(cardboardView);
        BorderMaterial material = (BorderMaterial) screen.getMaterial();
        ...
```

运行项目。它看起来应该和前面的一样。但是如果你的相机太好了，也许它不会像以前那样崩溃了。

这种采样对于在用户界面中显示图像的缩略图版本也很有用。没有必要为缩略图视图加载全尺寸位图。

# 加载并显示光球图像

到目前为止，我们已经用同样的方式处理了所有的图像。但其中一些可能是 360 度图像。这些应该显示在光球上，而不是虚拟屏幕上。

如果您的设备的相机文件夹中还没有任何 360 度照片，您可以使用谷歌相机应用程序创建它们。

### 注

如果你手机上的默认相机应用不包括 **光球**模式，你可能需要从 Play Store 下载谷歌相机应用。第三方摄像头可能会使用不同的名称。例如，三星称他们的光球功能为**环绕拍摄**。

一些图像包括 XMP 元数据，该元数据将包括图像对于等矩形投影是否失真的信息。这有助于区分球形图像和平面图像。然而，安卓应用编程接口不包括 XMP 接口，所以集成 XMP 头部解析超出了本书的范围。

现在，我们只检查文件名是否以`PANO_`为前缀。将以下变量添加到`Image`类，并在构造函数方法中设置它:

```java
    public boolean isPhotosphere;

    public Image(String path) {
        this.path = path;
        isPhotosphere = path.toLowerCase().contains("pano");
    }
```

我们现在可以建立`MainActivity`显示方法来处理普通照片(显示在虚拟屏幕上)和照片球(显示在背景球上)。此外，它应该处理在虚拟屏幕上显示的平面图像和渲染光球之间的切换，反之亦然。

我们要记住背景光球纹理的纹理句柄 ID。在`MainActivity`类顶部增加一个`bgTextureHandle`手柄:

```java
    int bgTextureHandle;
```

然后通过调用`getTexture`将其设置在`setupBackground`中:

```java
    void setupBackground() {
        photosphere = new Sphere(DEFAULT_BACKGROUND, false);
        new Transform()
                .setLocalScale(Camera.Z_FAR * 0.99f,-Camera.Z_FAR * 0.99f, Camera.Z_FAR * 0.99f)
                .addComponent(photosphere);
        UnlitTexMaterial mat = (UnlitTexMaterial) photosphere.getMaterial();
        bgTextureHandle = mat.getTexture();
    }
```

现在我们可以更新`showImage`方法，如下:

```java
    void showImage(Image image) {
        UnlitTexMaterial bgMaterial = (UnlitTexMaterial) photosphere.getMaterial();
        image.loadFullTexture(cardboardView);
        if (image.isPhotosphere) {
            bgMaterial.setTexture(image.textureHandle);
            screen.enabled = false;
        } else {
            bgMaterial.setTexture(bgTextureHandle);
            screen.enabled = true;
            image.show(cardboardView, screen);
        }
    }
```

当图像是光球时，我们为图像设置背景光球纹理，隐藏屏幕平面。当图像是普通照片时，我们将背景纹理设置回默认纹理，并在虚拟屏幕上显示图像。

在我们实现用户界面(下一步)来测试之前，您需要知道图像列表中的哪个图像是光球。如果你现在制作一个新的光球，它将是列表中的最后一个，你可以改变`setup`方法在上面调用`showImage`。例如，运行以下代码:

```java
         showImage(images.get(images.size()-1));
```

重新运行项目，开心就好！

# 图库用户界面

在我们继续为这个项目实现一个用户界面之前，让我们谈谈我们希望它如何工作。

这个项目的目的是允许用户从他们手机的存储器中选择一张照片，并在虚拟现实中查看它。手机的照片收藏将呈现在缩略图的可滚动网格中。如果一张照片是普通的 2D 照片，它将显示在我们刚刚制作的虚拟屏幕平面上。如果是光球，我们会把它看成是完全沉浸式的 360 度球面投影。

下图显示了我们建议的场景布局草图。用户相机以原点为中心，光球由围绕用户的灰色圆圈表示。在用户面前(由启动时的校准决定)，将有一个 5 x 3 网格的缩略图图像，来自手机的照片库。这将是一个可滚动的列表。在用户的左边，是图像投影屏幕。

![The image gallery user interface](graphics/B05144_07_12.jpg)

具体来说，UI 将实现以下功能:

*   在一个 5 x 3 的网格中最多显示 15 个缩略图。
*   允许用户通过查看缩略图，然后单击纸板触发器来选择其中一个缩略图。缩略图在视线中时会高亮显示。
*   选择一张普通照片将在场景中的虚拟投影屏幕上显示它(并清除背景图像的光球)。
*   选择光球将隐藏虚拟投影屏幕，并将图像载入光球投影。
*   允许用户通过选择向上/向下箭头滚动缩略图。

我们的一些用户界面考虑是虚拟现实独有的。最重要的是，所有的用户界面元素和控件都在世界坐标空间中，也就是说，它们像任何其他组件一样，作为具有位置、旋转和缩放的几何对象集成到场景中。这与大多数手机游戏形成对比，在大多数手机游戏中，用户界面被实现为屏幕空间覆盖。

为什么呢？因为在虚拟现实中，为了创造立体效果，每只眼睛都有一个单独的视点，由瞳距抵消。这可以在屏幕空间中通过水平偏移屏幕空间对象的位置来模拟，因此它们看起来有视差(这是我们在[第 4 章](04.html "Chapter 4. Launcher Lobby")、*发射器大厅*中使用的技术)。但是，当与三维几何、相机、照明和渲染混合在一起时，这种技术被证明是不够的。有效的用户体验和沉浸感需要世界空间用户界面。

另一个虚拟现实独有的功能是基于凝视的选择。在这种情况下，你看的地方会突出显示一个图像缩略图，然后你点击纸板触发器打开图像。

最后，如前所述，由于我们在世界空间中工作，并根据我们正在看的地方进行选择，因此我们的 3D 空间的布局是一个重要的考虑因素。请记住，我们在虚拟现实中，不受手机屏幕矩形边缘的限制。场景中的对象可以放在你的周围。另一方面，你不希望用户一直扭曲和转动(除非这是体验的预期部分)。我们将关注舒适区来放置我们的用户界面控件和图像屏幕。

此外，谷歌和其他地方的研究人员已经开始开发用户界面设计的最佳实践，包括菜单和用户界面控件与摄像头的最佳距离，约为 5 至 15 英尺(1.5 至 5 米)。这个距离足够近，可以享受 3D 视差效果，但不会太近，让你看起来像对眼一样专注于物体。

好了，让我们从 UI 实现开始。

## 将照片屏幕定位在左侧

首先让我们将屏幕从前面移到侧面，也就是向左旋转 90 度。我们的变换数学计算旋转后的位置，所以我们现在沿着 *x* 轴偏移它。修改`MainActivity`类的`setupScreen`方法，如下:

```java
    void setupScreen() {
        Transform screenRoot = new Transform()
                .setLocalScale(4, 4, 1)
                .setLocalRotation(0, -90, 0)
                .setLocalPosition(-5, 0, 0);
                ...
```

# 在网格中显示缩略图

缩略图是完整图像的迷你版本。因此，我们不需要加载全尺寸纹理位图。为了简单起见，让我们总是以 4 为单位(原始尺寸的 1/16)对其进行采样。

## 缩略图

在`Image`类中，`show`方法加载完整纹理。让我们写一个类似的`showThumbnail`方法，使用一个较小的采样。在`Image`类中，添加以下代码:

```java
    public void showThumbnail(CardboardView cardboardView, Plane thumb) {
        loadTexture(cardboardView, 4);
        BorderMaterial material = (BorderMaterial) thumb.getMaterial();
        material.setTexture(textureHandle);
        calcRotation(thumb);
        calcScale(thumb);
    }
```

## 缩略图类

为项目创建一个新的类，该类将包含一个小的`Plane`对象和一个要在其上显示的`Image`对象。它还获得当前的`cardboardView`实例，`Image`将要求:

```java
public class Thumbnail {
    final static String TAG = "Thumbnail";

    public Plane plane;
    public Image image;
    CardboardView cardboardView;

    public Thumbnail(CardboardView cardboardView) {
        this.cardboardView = cardboardView;
    }
}
```

定义加载图像纹理并将其显示为缩略图的`setImage`方法:

```java
    public void setImage(Image image) {
        this.image = image;
        // Turn the image into a GPU texture
        image.loadTexture(cardboardView, 4);
        // TODO: wait until texture binding is done
        // show it
        image.showThumbnail(cardboardView, plane);
    }
```

最后，快速切换缩略图的可见性:

```java
    public void setVisible(boolean visible) {
        plane.enabled = visible;
    }
```

## 缩略图网格

计划是在一个 5×3 的缩略图网格中显示手机照片。在`MainActivity`类的顶部，声明一个`thumbnails`变量来保存缩略图列表:

```java
    final int GRID_X = 5;
    final int GRID_Y = 3;

    final List<Thumbnail> thumbnails = new ArrayList<>();
```

用名为`setupThumbnailGrid`的新方法建立列表。第一个缩略图位于页面的左上角(-4，3，-5)，每个缩略图在 *x* 中间隔 2.1 个单位，在 *y* 中间隔 3 个单位，如下所示:

```java
    void setupThumbnailGrid() {
        int count = 0;
        for (int i = 0; i < GRID_Y; i++) {
            for (int j = 0; j < GRID_X; j++) {
                if (count < images.size()) {
                    Thumbnail thumb = new 
                        Thumbnail(cardboardView);
                    thumbnails.add(thumb);

                    Transform image = new Transform();
                    image.setLocalPosition(-4 + j * 2.1f, 3 - i * 3, -5);
                    Plane imgPlane = new Plane();
                    thumb.plane = imgPlane;
                    imgPlane.enabled = false;
                    BorderMaterial material = new BorderMaterial();
                    imgPlane.setupBorderMaterial(material);
                    image.addComponent(imgPlane);
                }
                count++;
            }
        }
    }
```

现在我们需要向平面添加图像纹理。我们再写一个方法，`updateThumbnails`，如下。它将显示网格中的前 15 个图像(如果没有那么多，则显示较少):

```java
    void updateThumbnails() {
        int count = 0;
        for (Thumbnail thumb : thumbnails) {
            if (count < images.size()) {
                thumb.setImage(images.get(count));
                thumb.setVisible(true);
            } else {
                thumb.setVisible(false);
            }
            count++;
        }
    }
```

将这些新的方法添加到`setup`中:

```java
    public void setup() {
        setupMaxTextureSize();
        setupBackground();
        setupScreen();
        loadImageList(imagesPath);
        setupThumbnailGrid();
        updateThumbnails();
    }
```

当您运行项目时，它应该如下所示:

![The thumbnail grid](graphics/B05144_07_13.jpg)

请注意，缩略图的大小被调整以匹配图像纵横比，并且被适当地定向，因为我们在前面的`Image`类中实现了这些特征。

### 类型

如果您的手机中已经没有超过 15 张照片，请在`loadImageList`中添加一个循环来加载副本。例如，运行以下代码:

```java
for(int j = 0; j < 3; j++) { //Repeat image list
    for (int i = 0; i < file.length; i++) {
        if (Image.isValidImage(file[i].getName())) {
            ...
```

# 凝视负载

我们希望检测用户何时查看缩略图，并通过更改图像的边框颜色来突出显示图像。如果用户将视线从缩略图移开，缩略图将会变暗。当用户点击纸板触发器时，该图像被加载。

## 基于凝视的高光

幸运的是，我们在[第五章](05.html "Chapter 5. RenderBox Engine")、 *RenderBox 引擎*末尾的`RenderBox`库中实现了`isLooking`检测。如果您还记得，该技术通过检查摄像机和平面位置之间的矢量是否与摄像机的观察方向相同，在公差阈值内，来确定用户是否正在观察平面。

我们可以在`MainActivity`中使用这个。我们将编写一个`selectObject`助手方法，检查场景中是否有任何对象被选中并高亮显示。首先，让我们在`MainActivity`类的顶部声明一些变量。`selectedThumbnail`对象保存当前选择的缩略图索引。我们为正常状态和选定状态定义边框颜色:

```java
    final float[] selectedColor = new float[]{0, 0.5f, 0.5f, 1};
    final float[] invalidColor = new float[]{0.5f, 0, 0, 1};
    final float[] normalColor = new float[]{0, 0, 0, 1};
    Thumbnail selectedThumbnail = null;
```

现在`selectObject`方法遍历每个缩略图，检查是否是`isLooking`，并相应地高亮显示(或取消高亮显示):

```java
    void selectObject() {
        selectedThumbnail = null;
        for (Thumbnail thumb : thumbnails) {
            if (thumb.image == null)
                return;
            Plane plane = thumb.plane;
            BorderMaterial material = (BorderMaterial) plane.getMaterial();
            if (plane.isLooking) {
                selectedThumbnail = thumb;
                material.borderColor = selectedColor;
            } else {
                material.borderColor = normalColor;
            }
        }
    }
```

`RenderBox`提供钩子，包括`postDraw`，我们将在这里检查选定的对象。我们想使用`postDraw`，因为我们需要等到`draw`在整个`RenderObjects`上被调用，才能知道用户在看哪一个。在`MainActivity`中，添加对`selectObject`方法的调用，如下所示:

```java
    @Override
    public void postDraw() {
        selectObject();
    }
```

运行项目。当你凝视一个缩略图时，它应该会高亮显示！

## 选择并显示照片

嗯，现在我们可以从缩略图网格中选择一个图像，我们需要一种方法来点击它并显示该图像。这将发生在`MainActivity`使用纸板 SDK 钩，`onCardboardTrigger`。

通过我们到目前为止所做的所有工作，实现这一点不需要太多时间:

```java
    @Override
    public void onCardboardTrigger() {
        if (selectedThumbnail != null) {
            showImage(selectedThumbnail.image);
        }
    }
```

试着运行它。现在突出显示一个图像并扣动扳机。如果你幸运的话，它会工作的…我的崩溃。

## 队列事件

怎么回事？我们遇到了线程安全问题。到目前为止，我们已经从渲染线程中执行了所有的代码，渲染线程是由`GLSurfaceView` / `CardboardView`类通过 Cardboard SDK 启动的。这个线程拥有对图形处理器和我们正在渲染的特定表面的访问权。对`onCardboardTrigger`的调用源自一个不是渲染线程的线程。这意味着我们不能从这里进行任何 OpenGL 调用。幸运的是，`GLSurfaceView`提供了一种通过名为`queueEvent`的方法在渲染线程上执行任意代码的巧妙方法。`queueEvent`方法采用单个`Runnable`参数，这是一个 Java 类，旨在创建类似这样的一次性过程(参见[http://developer . Android . com/reference/Android/OpenGL/glsurface view . html # queueEvent(Java . lang . runnable)](http://developer.android.com/reference/android/opengl/GLSurfaceView.html#queueEvent(java.lang.Runnable))。

修改`showImage`将其包装在`Runnable`参数中，如下所示:

```java
    void showImage(final Image image) {
        cardboardView.queueEvent(new Runnable() {
            @Override
            public void run() {

                UnlitTexMaterial bgMaterial = (UnlitTexMaterial) photosphere.getMaterial();
                image.loadFullTexture(cardboardView);
                if (image.isPhotosphere) {
                    Log.d(TAG, "!!! is photosphere");
                    bgMaterial.setTexture(image.textureHandle);
                    screen.enabled = false;
                } else {
                    bgMaterial.setTexture(bgTextureHandle);
                    screen.enabled = true;
                    image.show(cardboardView, screen);
                }

            }
        });
    }
```

请注意，传递给匿名类的任何数据，比如我们的图像，都必须声明`final`才能从新过程中访问。

请尝试再次运行该项目。应该有用。你可以凝视一个缩略图，点击触发器，那个图像就会显示出来，要么在虚拟屏幕上，要么在背景光球里。

## 使用振动器

不用担心，我们会保持干净。我们希望在选择图像时，使用手机的振动器向用户提供一些触觉反馈。幸运的是，在安卓系统中，这很简单。

首先，确保您的`AndroidManifest.xml`文件包含以下代码行:

```java
    <uses-permission android:name="android.permission.VIBRATE" />
```

在`MainActivity`类的顶部，声明一个`vibrator`变量:

```java
    private Vibrator vibrator;
```

然后，在`onCreate`中，添加以下代码进行初始化:

```java
    vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
```

然后，在`onCardboardTrigger`中使用，如下所示:

```java
       vibrator.vibrate(25);
```

再运行一次。点击它，你会感觉到它。*啊啊！*但是不要得意忘形，不是那种振动器。

# 启用滚动

我们的缩略图网格有 15 张图片。如果你的手机有超过 15 张照片，你需要在列表中滚动。对于这个项目，我们将实现一个简单的机制，使用三角形滚动按钮上下滚动列表。

## 创建三角形组件

像我们的`RenderBox`中的和其他`RenderObjects`一样，`Triangle`组件定义了坐标、法线、指数和其他描述三角形的数据。我们创建一个分配缓冲区的构造方法。像`Plane`组件一样，我们希望使用`BorderMaterial`类，以便在选择它时可以高亮显示。和`Plane`组件一样，它会决定用户什么时候看。不用多说，下面是代码。

在`RenderBoxExt/components`文件夹中创建新的 Java 类文件`Triangle.java`。我们首先声明它`extends RenderObject`并声明以下变量:

```java
public class Triangle extends RenderObject {

    /*
    Special triangle for border shader

    *   0/3 (0,1,0)/(0,1,0) (0,1)/(1,1)
              /|\
             / | \
            *--*--*
            1  2  4
     */

    private static final float YAW_LIMIT = 0.15f;
    private static final float PITCH_LIMIT = 0.15f;
    public static final float[] COORDS = new float[] {
            0f, 1.0f, 0.0f,
            -1.0f, -1.0f, 0.0f,
            0.0f, -1.0f, 0.0f,
            0f, 1.0f, 0.0f,
            1.0f, -1.0f, 0.0f,
    };
    public static final float[] TEX_COORDS = new float[] {
            0f, 1f,
            0f, 0f,
            0.5f, 0f,
            1f, 1f,
            1f, 0f
    };
    public static final float[] COLORS = new float[] {
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f,
            0.5f, 0.5f, 0.5f, 1.0f
    };
    public static final float[] NORMALS = new float[] {
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f,
            0.0f, 0.0f, -1.0f
    };
    public static final short[] INDICES = new short[] {
            1, 0, 2,
            2, 3, 4
    };

    private static FloatBuffer vertexBuffer;
    private static FloatBuffer colorBuffer;
    private static FloatBuffer normalBuffer;
    private static FloatBuffer texCoordBuffer;
    private static ShortBuffer indexBuffer;
    static final int numIndices = 6;

    static boolean setup;
}
```

万一我们不清楚为什么需要这个 2-三角三角形，那就要看紫外线是如何工作的了。你不可能只用一个三角形就得到一个完整的边框，至少不是我们编写边框着色器的方式。

添加一个构造函数和一个`allocateBuffers`助手:

```java
    public Triangle(){
        super();
        allocateBuffers();
    }

    public static void allocateBuffers(){
        //Already allocated?
        if (vertexBuffer != null) return;
        vertexBuffer = allocateFloatBuffer(COORDS);
        texCoordBuffer = allocateFloatBuffer(TEX_COORDS);
        colorBuffer = allocateFloatBuffer(COLORS);
        normalBuffer = allocateFloatBuffer(NORMALS);
        indexBuffer = allocateShortBuffer(INDICES);
    }
```

我们可以创建各种材质，但是我们真的只打算使用`BorderMaterial`，所以让我们像支持`Plane`一样支持这个:

```java
    public void setupBorderMaterial(BorderMaterial material){
        this.material = material;
        material.setBuffers(vertexBuffer, texCoordBuffer, indexBuffer, numIndices);
    }
```

## 向用户界面添加三角形

在`MainActivity`中，我们可以添加`up`和`down`三角形按钮来滚动缩略图。在`MainActivity`类的顶部，声明三角形及其材质的变量:

```java
    Triangle up, down;
    BorderMaterial upMaterial, downMaterial;
    boolean upSelected, downSelected;
```

如下定义`setupScrollButtons`助手:

```java
    void setupScrollButtons() {
        up = new Triangle();
        upMaterial = new BorderMaterial();
        up.setupBorderMaterial(upMaterial);
        new Transform()
            .setLocalPosition(0,6,-5)
            .addComponent(up);

        down = new Triangle();
        downMaterial = new BorderMaterial();
        down.setupBorderMaterial(downMaterial);
        new Transform()
            .setLocalPosition(0,-6,-5)
            .setLocalRotation(0,0,180)
            .addComponent(down);
    }
```

然后，从`setup`法调用它:

```java
    public void setup() {
        setupMaxTextureSize();
        setupBackground();
        setupScreen();
        loadImageList(imagesPath);
        setupThumbnailGrid();
        setupScrollButtons();
        updateThumbnails();
    }
```

当你运行项目时，你会看到箭头:

![Adding triangles to the UI](graphics/B05144_07_14.jpg)

## 与滚动按钮交互

现在我们将通过使用`selectObject`中的`isLooking`(从`postDraw`钩子调用)来检测用户何时在看三角形:

```java
    void selectObject() {
        ...

        if (up.isLooking) {
            upSelected = true;
            upMaterial.borderColor = selectedColor;
        } else {
            upSelected = false;
            upMaterial.borderColor = normalColor;
        }

        if (down.isLooking) {
            downSelected = true;
            downMaterial.borderColor = selectedColor;
        } else {
            downSelected = false;
            downMaterial.borderColor = normalColor;
        }
    }
```

## 实现滚动方法

为了实现缩略图的滚动，我们将保持网格平面在适当的位置，只滚动纹理。使用偏移变量保存网格中第一个图像的索引:

```java
    static int thumbOffset = 0;
```

现在，修改`updateThumbnails`方法，使用拇指偏移作为图像纹理的起始索引来填充平面纹理:

```java
    void updateThumbnails() {
        int count = thumbOffset;
        for (Thumbnail thumb : thumbnails) {
        . . .
```

我们可以通过一次移动一行`thumbOffset`变量(`GRID_X`)在`onCardboardTrigger`中按下向上或向下箭头时执行滚动:

```java
    public void onCardboardTrigger() {
        if (selectedThumbnail != null) {
            vibrator.vibrate(25);
            showImage(selectedThumbnail.image);
        }
        if (upSelected) {
            // scroll up
            thumbOffset -= GRID_X;
            if (thumbOffset < 0) {
                thumbOffset = images.size() - GRID_X;
            }
            vibrator.vibrate(25);
            updateThumbnails();
        }
        if (downSelected) {
            // scroll down
            if (thumbOffset < images.size()) {
                thumbOffset += GRID_X;
            } else {
                thumbOffset = 0;
            }
            vibrator.vibrate(25);
            updateThumbnails();
        }
    }
```

与`showImage`一样，`updateThumbnails`方法需要在渲染线程上运行:

```java
    void updateThumbnails() {
        cardboardView.queueEvent(new Runnable() {
            @Override
            public void run() {
                ...
```

运行项目。现在，您可以点击向上和向下箭头来滚动浏览您的照片。

# 保持响应并使用线程

我们的加载和滚动代码有一些问题，都与加载图像和转换位图是计算密集型的这一事实有关。尝试一次对 15 张图片执行此操作会导致应用程序显示为冻结状态。您可能还注意到，自从我们添加缩略图网格以来，该应用程序的启动时间明显更长。

在传统应用程序中，等待数据加载时锁定应用程序可能会令人讨厌，但在某种程度上是可以接受的。但是在虚拟现实中，应用程序需要保持活力。应用程序需要继续响应头部移动，并用对应于当前视图方向的视图更新每帧的显示。如果加载文件的时候 app 被锁定了，会有卡住的感觉，也就是卡到你脸上了！在完全沉浸式的体验中，在绑着 HMD 的桌面上，视觉锁定是最严重的恶心原因。

解决方案是一个工作线程。成功的多线程支持的关键是为过程提供用信号量(布尔标志)相互发信号的能力。我们将使用以下内容:

*   `Image.loadLock`:这是真的在等待 GPU 生成纹理的时候
*   `MainActivity.cancelUpdate`:当线程由于用户事件而应该停止时，此为真
*   `MainActivity gridUpdateLock`:此在电网更新时为真；忽略其他用户事件

让我们申报这些。在`Image`类的顶部，添加以下代码:

```java
        public static boolean loadLock = false;
```

在`MainActivity`类的顶部，添加以下内容:

```java
    public static boolean cancelUpdate = false;
    static boolean gridUpdateLock = false;
```

首先，让我们确定代码中计算密集型的部分。随便你自己调查，但是我们假设`BitmapFactory.decodeFile`是罪魁祸首。理想情况下，任何与渲染没有直接关系的代码都应该在工作线程上完成，但是要注意预优化。我们正在做这项工作，因为我们已经注意到一个问题，所以我们应该能够识别导致它的新代码。一个有根据的猜测指出了将任意图像加载到纹理中的业务。

我们在哪里做这个手术？嗯，对`BitmapFactory.decodeFile`的实际调用来自`Image.loadTexture`，但更一般地说，这一切都是在`MainActivity.updateGridTextures`和`MainActivity.showImage`拉开序幕的。现在让我们更新最后两个函数。

幸运的是，`showImage`已经被包装在`Runnable`中，目的是将其执行重定向到渲染线程。现在我们想要确保它总是在渲染线程之外发生。我们将在不同的地方使用`queueEvent`来避免我们之前遇到的错误。我们将之前的`Runnable`代码替换为`Thread`。例如，`showImage`现在看起来是这样的:

```java
    void showImage(final Image image) {
        new Thread() {
            @Override
            public void run() {
              UnlitTexMaterial bgMaterial = (UnlitTexMaterial) photosphere.getMaterial();
                ...
            }
        }.start();
    }
```

对`updateThumbnails`也这样做。当我们在这里时，添加运行时保持设置的`gridUpdateLock`标志，并处理`cancelUpdate`标志，这样循环可以被中断:

```java
    void updateThumbnails() {
 gridUpdateLock = true;
 new Thread() {
 @Override
 public void run() {
                int count = thumbOffset;
                for (Thumbnail thumb : thumbnails) {
 if (cancelUpdate)
 return;
                    if (count < images.size()) {
                        thumb.setImage(images.get(count));
                        thumb.setVisible(true);
                    } else {
                        thumb.setVisible(false);
                    }
                    count++;
                }
 cancelUpdate = false;
 gridUpdateLock = false;
 }
 }.start();
    }
```

关注`Image`类的`loadTexture`方法，我们需要用`queueEvent`将 GPU 调用重定向回渲染线程。如果你现在尝试运行这个应用程序，它将会崩溃。这是因为`showImage`现在总是在自己的线程中运行，当我们最终调用 OpenGL 来生成纹理时，我们会得到之前添加触发器输入时得到的无效操作错误。要解决此问题，请修改`loadTexture`如下:

```java
    public void loadTexture(CardboardView cardboardView, int sampleSize) {
        if (textureHandle != 0)
            return;
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inSampleSize = sampleSize;
        final Bitmap bitmap = BitmapFactory.decodeFile(path, options);
        if(bitmap == null){
            throw new RuntimeException("Error loading bitmap.");
        }
        width = options.outWidth;
        height = options.outHeight;

 loadLock = true;
 cardboardView.queueEvent(new Runnable() {
 @Override
 public void run() {
 if (MainActivity.cancelUpdate)
 return;
                             textureHandle = bitmapToTexture(bitmap);
                             bitmap.recycle();
 loadLock = false;
 }
 }
        });
 while (loadLock){
 try {
 Thread.sleep(100);
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
 }
    }
```

我们改变了使`bitmapToTexture`现在在 GPU 线程上被调用。我们使用`loadLock`标志来指示装载正忙。完成后，标志会重置。同时，`loadTexture`等待它完成后再返回，因为我们需要这个`textureHandle`值以备后用。但是由于我们总是从一个工作线程调用它，应用程序不会挂起等待。这一变化也将改善启动时间。

同样，我们在`Thumbnail`班也做同样的事情；其`setImage`方法也加载了图像纹理。修改它，使它看起来像这样:

```java
    public void setImage(Image image) {
        this.image = image;
        // Turn the image into a GPU texture
        image.loadTexture(cardboardView, 4);
 // wait until texture binding is done
 try {
 while (Image.loadLock) {
 if (MainActivity.cancelUpdate)
 return;
 Thread.sleep(10);
 }
 } catch (InterruptedException e) {
 e.printStackTrace();
 }
        // show it
        . . .
    }
```

你可能已经注意到了所有这些中一个更微妙的问题。如果我们试图在这些工作线程操作中关闭应用程序，它将崩溃。潜在的问题是线程仍然存在，但是图形上下文已经被破坏，即使你只是切换应用程序。试图用无效的图形上下文生成纹理会导致崩溃，并且用户很少得到通知。坏消息。我们想做的是在应用程序关闭时停止工作线程。这就是`cancelUpdate`发挥作用的地方。在`MainActivity`中，我们将在`onCreate`方法中设置其值，并将这些方法添加到`onStart`、`onResume`和`onPause`钩子方法中，如下所示:

```java
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        cancelUpdate = false;
        //...
    }

    @Override
    protected void onStart(){
        super.onStart();
        cancelUpdate = true;
    }
    @Override
    protected void onResume(){
        super.onResume();
        cancelUpdate = false;
    }
    @Override
    protected void onPause(){
        super.onPause();
        cancelUpdate = true;
    }
```

如果你试图在网格更新的时候点击某个东西，它不应该让你这么做。在`onCardboardTrigger`顶部添加以下代码:

```java
        if (gridUpdateLock) {
            vibrator.vibrate(new long[]{0,50,30,50}, -1);
            return;
        }
```

这个新的`long[]{0,50,30,50}`业务是将序列编程到振动器中的一种方式。在这种情况下，连续两个短脉冲(50 毫秒)用于指示 nuh-uh 反应。

我们甚至可以更进一步，在`gridUpdateLock`期间用禁用的颜色突出显示`selectObject`中的可选对象，如下所示:

```java
            if (plane.isLooking) {
                selectedThumbnail = thumb;
                if(gridUpdateLock)
                    material.borderColor = invalidColor;
                else
                    material.borderColor = selectedColor;

           ...
```

您的项目应该像以前一样运行。但是现在它响应更快，表现更好，而且不会在等待图像加载时卡住。

# 线程和虚拟现实的解释

OpenGL不是线程安全的。这听起来像是一个设计缺陷。实际上，这更像是一种设计需求。您希望图形应用编程接口尽可能快速、频繁地绘制框架。你可能知道，或者很快就会知道，等待是线程最终会花费大量时间去做的事情。如果您将多线程访问引入到图形硬件中，那么您就引入了这样一个时期，在这个时期，硬件可能会等待中央处理器，只是为了弄清楚它的线程调度以及当时谁需要访问。说“只有一个线程可以访问 GPU”要简单快捷得多从技术上讲，随着图形 API 变得更加高级(DirectX 12 和 Vulkan)，严格来说这并不是真的，但在本书中我们不会进入多线程渲染。

让我们先退一步问一个问题，“为什么我们需要使用线程？”对于一些更有经验的应用程序开发人员来说，答案应该是显而易见的。但是并不是所有的程序员都需要使用线程，更糟糕的是，许多程序员不恰当地使用线程，或者在一开始不需要线程的时候使用线程。对于那些仍然蒙在鼓里的人来说，线程是“一种同时运行两个过程的方法”的奇特术语。在实际层面上，操作系统控制调度线程一个接一个地运行，或者在不同的 CPU 内核上运行，但是作为程序员，我们假设所有线程都在“同时”运行

顺便说一下，虽然我们只允许一个中央处理器线程控制图形处理器，但图形处理器的全部意义在于它是大规模多线程的。移动 GPU 仍在进步，但高端 Tegra 芯片有数百个内核(目前，X1 为 256 个内核)，落后于拥有数千个内核的台式机同类产品(Titan Black @ 2880 个内核)。一个图形处理器被设置成在一个单独的线程上处理每个像素(或其他类似的小数据)，并且有一些硬件魔法在进行，以零开销自动调度所有像素。把你的渲染线程想象成一个缓慢的工头，指示一小群 CPU 执行你的命令，并报告结果，或者在大多数情况下，直接把它们画到屏幕上。这意味着中央处理器已经代表图形处理器进行了大量的等待，释放您的其他工作线程来完成它们的任务，然后在有更多的中央处理器渲染工作要做时等待。

当您想要运行一个需要一段时间的进程，并且想要避免阻塞程序的执行或主线程时，线程通常是有用的。出现这种情况最常见的地方是启动后台进程，并允许用户界面继续更新。如果您正在创建媒体编码器程序，您不希望它在解码视频时无响应 30 分钟。相反，您希望程序正常运行，允许用户点击按钮并查看后台工作的进度更新。在这种情况下，您必须让用户界面和后台线程偶尔休息一下，以发送和检查两者之间传递的消息。调整中断长度或睡眠时间以及线程优先级值，可以避免一个线程占用过多的 CPU 时间。

回到 OpenGL 和图形编程。在游戏引擎中，将作品分成几个不同的线程(渲染、物理、音频、输入等)是很常见的。然而，渲染线程始终是一种*编曲者*，因为渲染仍然是对时间最敏感的工作，并且必须每秒至少发生 30 次。在虚拟现实中，这种约束更加重要。也许我们并不担心物理和音频，但我们仍然需要确保我们的渲染器能够尽快绘制东西，否则存在感就会丧失。此外，我们永远不能停止渲染，只要这个人在看屏幕。我们需要线程来避免“打嗝”或渲染帧之间不可接受的长时间。

头部跟踪对于虚拟现实体验至关重要。一个人在移动他们的头，只看着一个固定的图像，将会开始体验恶心，或*西姆病*。即使是黑色背景上的一些文字，如果没有某种固定的视界补偿，最终也会引起不适。有时，我们确实必须在相当长的时间内阻止渲染线程，最好的选择是首先将图像淡化为纯色，或者是空白。这在短时间内可能是舒适的。在虚拟现实中可能发生的最糟糕的事情是由于渲染线程上的大量工作而导致的周期性打嗝或帧率下降。如果不保持恒定、流畅的帧率，你的 VR 体验就一文不值。

在我们的例子中，我们需要解码一系列相当大的位图，并将它们加载到 GPU 纹理中。不幸的是，解码步骤需要几百毫秒，导致我们刚才谈到的打嗝。然而，由于这不是 GPU 的工作，它不必发生在渲染线程上！如果我们想避免在我们的`setup()`、`preDraw()`和`postDraw()`函数中有任何繁重的工作，我们应该在任何时候创建一个线程来解码位图。在更新预览网格的情况下，我们可能应该只创建一个线程，它可以运行整个更新过程，在每个位图之间等待。在 CPU 领域，操作系统需要使用一些资源来调度线程并分配它们的资源。只创建一个线程来运行整个作业比为每个位图创建一个线程更有效。

当然，我们需要利用我们的老朋友`queueEvent`来做任何图形工作，在这种情况下，生成和加载纹理。事实证明，更新图像的显示不是图形工作，因为它只是涉及到改变我们材料上的一个值。然而，我们确实需要等待图形工作，以获得这个新的价值。作为这些优化和约束的结果，我们需要一个锁定系统，以便允许一个线程等待其他线程完成其工作，并防止用户在完成之前中断或重新启动该过程。这就是我们在上一个主题中刚刚实现的。

# 有目的地发射

如果你可以在任何时候用手机观看图像，尤其是 360 度的照片，都可以启动这个应用，那不是很酷吗？

安卓操作系统更强大的功能之一是能够在应用程序之间进行有意图的通信。一个 **意图**是任何应用程序都可以发送到安卓系统的消息，它声明它打算为某个目的使用另一个应用程序。意图对象包含许多成员来描述需要执行什么类型的操作，以及需要对其执行的数据(如果有的话)。作为用户，您可能熟悉默认的动作选择器，它显示许多应用程序图标和选项，**仅一次**或**始终**。你看到的是你刚刚使用的应用程序向系统广播新意图的结果。当你选择一个应用程序时，安卓会从该应用程序启动一个新的活动，该活动已经注册以响应该类型的意图。

在您的`AndroidManifest.xml`文件中，向活动块添加一个意图过滤器。让安卓知道该应用可以作为图像查看器。添加以下 XML 代码:

```java
<intent-filter>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <data android:mimeType="image/*" />
</intent-filter>
```

我们只需要处理这种情况，所以一个意图图像是应用程序启动时加载的默认图像。在`MainActivity`中，我们将编写一个新的函数，显示给定 URI 的图像，如下所示。该方法获取 URI 路径并将其转换为文件路径名，在该路径上调用新的`Image`对象，然后调用`showImage`方法。(参考访问[http://developer . Android . com/guide/topics/providers/content-provider-basics . html](http://developer.android.com/guide/topics/providers/content-provider-basics.html)):

```java
    void showUriImage(final Uri uri) {
        Log.d(TAG, "intent data " + uri.getPath());
        File file = new File(uri.getPath());
        if(file.exists()){
            Image img = new Image(uri.getPath());
            showImage(img);
        } else {
            String[] filePathColumn = {MediaStore.Images.Media.DATA};
            Cursor cursor = getContentResolver().query(uri, filePathColumn, null, null, null);
            if (cursor == null)
                return;
            if (cursor.moveToFirst()) {
                int columnIndex = cursor.getColumnIndex(filePathColumn[0]);
                String yourRealPath = cursor.getString(columnIndex);
                Image img = new Image(yourRealPath);
                showImage(img);
           }
           // else report image not found error?
           cursor.close();

    }
```

然后，添加从`setup`到`showUriImage`的呼叫，如下所示:

```java
    public void setup() {
        BorderMaterial.destroy();
        setupMaxTextureSize();
        setupBackground();
        setupScreen();
        loadImageList(imagesPath);
        setupThumbnailGrid();
        setupScrollButtons();
        Uri intentUri = getIntent().getData();
        if (intentUri != null) {
            showUriImage(intentUri);
        }
        updateThumbnails();
    }
```

我们还添加了对`BorderMaterial.destroy()`的调用，因为意图启动了活动的第二个实例。如果我们不销毁材质，新的活动实例(它有自己的图形上下文)将在尝试使用在第一个活动的图形上下文上编译的着色器时抛出错误。

现在，项目已经在手机上构建和安装，当您选择图像文件时，例如，从文件夹浏览器应用程序(如**【我的文件】**(三星))中选择图像文件时，您可以选择旨在查看图像的应用程序。您的 Gallery360 应用程序(或您实际命名的任何应用程序)将是选择之一，如下图所示。选择它，它将作为默认的图像文件视图启动。

![Launch with an intent](graphics/B05144_07_15.jpg)

# 用向上倾斜的手势显示/隐藏网格

回到在纸板的早期，你有一个按钮。仅此而已。一个按钮和头部跟踪是用户与应用程序交互的唯一方式。因为按钮是一个漂亮的磁铁，你甚至不能按住一个按钮。有了 Cardboard 2.0，屏幕变成了按钮，我们也意识到我们可以短暂地把盒子从脸上拿下来，把手机向上倾斜，再放回去，并把它解释为一种姿态。于是，第二次输入诞生了！在写这篇文章的时候，示例纸板应用程序使用这个作为一个后退手势。

我们将使用向上倾斜来显示和隐藏网格和箭头，以便您可以完全沉浸在所选的光球中。由于工作量较少，我们也将让用户随时这样做，而不仅仅是看照片。与振动反馈一样，这实际上是一个相当无痛的添加功能。大部分艰苦的工作是由一个`OrientationEventListener`班完成的。

在`MainActivity`类的顶部，为网格状态、方向事件监听器和倾斜检测计时器添加一个变量，如下所示:

```java
      static boolean setupComplete = false;

      boolean interfaceVisible = true;
      OrientationEventListener orientationEventListener;
      int orientThreshold = 10;
      boolean orientFlip = false;
      long tiltTime;
      int tiltDamper = 250;
```

首先，我们可以写一个打开/关闭缩略图网格菜单的方法。检查图像是否比飞机少，因为空的图像已经在`updateThumbnails`中被禁用:

```java
    void toggleGridMenu() {
        interfaceVisible = !interfaceVisible;
        if (up != null)
            up.enabled = !up.enabled;
        if (down != null)
            down.enabled = !down.enabled;
        int texCount = thumbOffset;
        for (Thumbnail thumb : thumbnails) {
            if (texCount < images.size() && thumb != null) {
                thumb.setVisible(interfaceVisible);
            }
            texCount++;
        }
    }
```

接下来，编写一个`setupOrientationListener`助手方法，在设备方向发生变化时提供回调函数。如果处于横向模式后方向接近垂直，我们可以调用我们的切换功能，一旦设备返回横向并再次垂直，我们将再次切换:

```java
    void setupOrientationListener() {
        orientationEventListener = new OrientationEventListener(this, SensorManager.SENSOR_DELAY_NORMAL) {
            @Override
            public void onOrientationChanged(int orientation) {
                if(gridUpdateLock || !setupComplete)
                    return;
           if(System.currentTimeMillis() - tiltTime > tiltDamper) {
                    if(Math.abs(orientation) < orientThreshold || Math.abs(orientation - 180) < orientThreshold){   //"close enough" to portrait mode
                        if(!orientFlip) {
                            Log.d(TAG, "tilt up! " + orientation);
                            vibrator.vibrate(25);
                            toggleGridMenu();
                        }
                        orientFlip = true;
                    }
                    if(Math.abs(orientation - 90) < orientThreshold || Math.abs(orientation - 270) < orientThreshold) {    //"close enough" to landscape mode
                        orientFlip = false;
                    }
                          tiltTime = System.currentTimeMillis();
                }
            }
        };
        if(orientationEventListener.canDetectOrientation())
            orientationEventListener.enable();
    }
```

然后，将其添加到`onCreate`:

```java
    protected void onCreate(Bundle savedInstanceState) {
        ...
        setupOrientationListener();
    }
```

`setupComplete`标志防止网格在创建过程中被切换。让我们在`updateThumbnails`之后重置完成标志:

```java
    void updateThumbnails() {
        . . .
                cancelUpdate = false;
                gridUpdateLock = false;
 setupComplete = true;

```

`onDestroy`销毁比较谨慎:

```java
    @Override
    protected void onDestroy(){
        super.onDestroy();
        orientationEventListener.disable();
    }
```

每当手机改变方向时，`onOrientationChanged`回拨就会触发。我们只会对它从横向变为纵向的时间感兴趣，我们还想确保它不会发生得太频繁，因此有了 **倾斜阻尼器**功能。您可能想根据自己的喜好调整该值(目前为 250 毫秒)。太短了，你可能会连续两次错误地注册。时间过长，用户可能会在截止时间内尝试倾斜两次。

# 球形缩略图

球形 360 度图像应该比普通的 ol' paint-chip 缩略图图像更好，你不觉得吗？我建议我们把它们展示成小球。也许我们应该叫它们拇指尖或拇指弹珠。无论如何，让我们做一点黑客来实现这一点。

## 给缩略图类添加一个球体

在的`Thumbnail`类中，添加一个`sphere`变量:

```java
    public Sphere sphere;
```

修改`setImage`识别光球图像:

```java
    public void setImage(Image image) {
        // ...
        // show it
        if (image.isPhotosphere) {
            UnlitTexMaterial material = (UnlitTexMaterial) sphere.getMaterial();
            material.setTexture(image.textureHandle);
        } else {
            image.showThumbnail(cardboardView, plane);
        }
    }
```

我们还必须改变`setVisible`来处理`plane`和`sphere`变量，如下所示:

```java
    public void setVisible(boolean visible) {
        if(visible) {
            if(image.isPhotosphere){
                plane.enabled = false;
                sphere.enabled = true;
            } else{
                plane.enabled = true;
                sphere.enabled = false;
            }
        } else {
            plane.enabled = false;
            sphere.enabled = false;
        }
    }
```

接下来，在`MainActivity`类的`setupThumbnailGrid`中，除了一个`Plane`对象之外，初始化一个`Sphere`对象(在`GRID_Y`和`GRID_X`循环中):

```java
                    . . . 
                    image.addComponent(imgPlane);

                    Transform sphere = new Transform();
                    sphere.setLocalPosition(-4 + j * 2.1f, 3 - i * 3, -5);
                    sphere.setLocalRotation(180, 0, 0);
                    sphere.setLocalScale(normalScale, normalScale, normalScale);
                    Sphere imgSphere = new Sphere(R.drawable.bg, false);
                    thumb.sphere = imgSphere;
                    imgSphere.enabled = false;
                    sphere.addComponent(imgSphere);
```

现在缩略图有一个平面和一个球体，我们可以根据图像类型进行填充。

最后，我们只需要修改`selectObject`方法，看看我们如何突出显示一个球体缩略图。我们通过改变边框颜色来突出显示矩形。我们的领域没有边界；作为替代，我们将改变它们的尺寸。

在`MainActivity`的顶部，将变量添加到正常和选定的刻度中:

```java
    final float selectedScale = 1.25f;
    final float normalScale = 0.85f;
```

现在，将`selectObject`更改为当图像是光球时的不同行为:

```java
    void selectObject() {
        float deltaTime = Time.getDeltaTime();
        selectedThumbnail = null;
        for (Thumbnail thumb : thumbnails) {
            if (thumb.image == null)
                return;
            if(thumb.image.isPhotosphere) {
                Sphere sphere = thumb.sphere;
                if (sphere.isLooking) {
                    selectedThumbnail = thumb;
                    if (!gridUpdateLock)
                        sphere.transform.setLocalScale(selectedScale, selectedScale, selectedScale);
                } else {
                    sphere.transform.setLocalScale(normalScale, normalScale, normalScale);
                }
                sphere.transform.rotate(0, 10 * deltaTime, 0);
            } else {
                Plane plane = thumb.plane;
                //...
            }
        }
        //. . .
```

喔呼！我们甚至让球体旋转，所以你可以看到它的 360 度的辉煌！这太好玩了，应该是违法的。

![Add a sphere to the Thumbnail class](graphics/B05144_07_16.jpg)

给你。一个漂亮的照片查看器应用程序，支持常规相机图像以及 360 度照片球。

# 更新渲染盒库

随着Gallery 360 项目的实现和我们代码的稳定，您可能会意识到我们已经构建了一些不一定特定于该应用程序的代码，这些代码可以在其他项目中重用，并且应该会返回到`RenderBox`库。

我们在[第六章](06.html "Chapter 6. Solar System")、*太阳系*的上一个项目结束时做了这个。有关详细信息，您可以参考该主题。按照以下步骤更新`RenderBoxLib`项目:

1.  将`Plane`和`Triangle`部件从`RenderBoxExt/components`移开。
2.  将`BorderMaterial`组件从`RenderBoxExt/materials`移开。
3.  从`res/raw`移动边框着色器文件。
4.  重构任何无效的引用以更正包名。
5.  点击**建立** | **制作项目**重建库。

# 进一步可能的增强

咻，那是一个很大的工作量！这个事情肯定是办成了，不是吗？*绝不！*以下是一些亟待实施的改进:

*   更好地检测手机图像:
    *   不是每个人都把自己所有的形象都保持在一个特定的路径上。其实有些相机软件用的是完全不同的路径！介绍一个合适的文件浏览器。
*   更好地检测光球图像:
    *   There is a `Projection Type` attribute in the XMP header, another piece of metadata in some JPG files. Unfortunately, the Android API doesn't have a specific class to read this data, and integrating a third-party library is beyond the scope of this project. Feel free to try the following links:

        [https://github . com/dragon 66/pixymeta-Android](https://github.com/dragon66/pixymeta-android)

        [https://github.com/drewnoakes/metadata-extractor](https://github.com/drewnoakes/metadata-extractor)

        不要使用全景技术，因为它会拾取常规全景。允许用户在显示不正确的图像上标记或修复光球或旋转元数据。

*   动画用户界面动作—选择时缩放/平移，平滑网格滚动。
*   一种防止网格块出现在向上/向下箭头后面的巧妙技术被称为 **深度掩蔽**。你也可以在世界空间中引入一个最大和最小的 Y 值，超过这个值，瓷砖将无法绘制。但是深度面具更酷。
*   响应`GALLERY`的意图，从另一个应用程序中选择图像来覆盖网格。
*   在`VIEW`意图中接受来自网络的图像网址。
*   你需要先下载镜像，然后从下载路径加载。

# 总结

我希望你和我一样对我们在这里取得的成就感到兴奋！我们构建了一个真正实用的纸板虚拟现实应用程序来查看常规照片和 360 度照片球的图库。该项目使用`RenderBox`库，如[第 5 章](05.html "Chapter 5. RenderBox Engine")、*渲染箱引擎*所述。

首先，我们演示了感光球是如何工作的，并使用`RenderBox`库在纸板上查看了一个，没有任何自定义更改。然后，为了查看常规照片，我们创建了一个`Plane`组件，用作虚拟投影屏幕。我们编写了新的材质和着色器来渲染带有边框的图像。

接下来，我们定义了一个新的`Image`类，并将手机相机文件夹中的图像加载到一个列表中，并编写了一个在屏幕`Plane`上显示图像的方法，校正其方向和纵横比。然后，我们构建了一个显示缩略图网格的用户界面，让您通过凝视它并单击纸板触发器来显示图像来选择一个。网格是可滚动的，这要求我们添加线程，这样当文件加载时，应用程序就不会出现锁定。最后，我们添加了几个铃铛和哨子来启动具有图像查看意图的应用程序，通过垂直倾斜手机来切换菜单网格，并为照片球添加球形拇指纹。

在下一章中，我们将构建另一种查看器；这次要查看 OBJ 文件中的完整 3D 模型。