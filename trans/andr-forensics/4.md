# 第四章

# 安卓文件系统和数据结构

### 本章中的信息

[外壳中的数据](#S0015)

[记忆类型](#S0090)

[文件系统](#S0105)

[挂载的文件系统和目录结构](#S0145)

## 介绍

虽然驱动安卓设备的底层硬件和软件非常吸引人，但法医分析师和安全工程师的主要重点是获取、分析和理解存储在设备上的数据。与讨论的其他主题一样，有许多细微差别对于理解有效分析很重要，包括存储什么类型的数据、存储在哪里、如何存储以及存储它们的物理介质的特性。所有这些因素在可以恢复哪些数据以及如何分析这些数据方面都起着重要作用。

## 外壳中的数据

法医分析师主要关注可以从他们调查的设备中恢复的数据工件。安卓是众所周知的人工产物(如 Linux 中的人工产物)和全新人工产物(如 Dalvik VM 和 YAFFS2 文件系统)的结合。增加复杂性的是不同制造商采用的不同架构。

虽然没有一本书或审查员能够详尽无遗地涵盖这个主题，但安卓设备有一些共同的基本概念。文件系统、文件和其他工件是法医分析师必须了解的安卓系统的核心，以最大限度地提高他们调查的有效性。

### 存储了哪些数据

安卓设备存储了大量数据，通常将个人和工作数据结合在一起。应用程序是这些数据的主要来源，应用程序有许多来源，包括:

搭载安卓系统的应用

制造商安装的应用程序

无线运营商安装的应用程序

其他谷歌/安卓应用

用户安装的应用程序，通常来自安卓市场

[第 7 章](7.html)《安卓应用与取证分析》将详细考察其中的一些应用，尽管涵盖所有可能性肯定超出了本书的范围。安卓设备上的数据示例包括以下内容:

短信(短信/彩信)

联系人

通话记录

电子邮件(Gmail、雅虎、交易所)

即时信使/聊天

全球定位系统坐标

照片/视频

网络历史

搜索历史

行驶方向

脸书、推特和其他社交媒体客户端

存储在设备上的文件

音乐收藏

日历约会

财务信息

购物历史

文件共享

### 应用程序数据存储目录结构

安卓应用程序主要将数据存储在两个位置，内部存储和外部存储，这两个位置将在本章后面更详细地介绍。然而，对数据存储目录结构有一个高层次的理解是有帮助的。

在外部数据存储区(SD 卡和模拟 SD 卡)，应用程序可以将数据存储在他们想要的任何位置。然而，内部数据存储由安卓应用编程接口控制。安装应用程序时(通过市场或在交付给消费者的版本中)，内部数据存储保存在/data/data/的子目录中，该子目录以包名命名。例如，默认的安卓浏览器有一个名为 com.android.browser 的包，因此数据文件存储在/data/data/com.android.browser 中，虽然应用程序不需要存储数据文件，但大多数都需要。

在应用程序/数据/数据子目录中，有许多标准目录，以及开发人员控制的目录。最常见的标准子目录列于[表 4.1](#T0010) 。

表 4.1 常用/数据/数据/ <packagename>子目录</packagename>

| shared_prefs | 以 XML 格式存储共享首选项的目录 |
| --- | --- |
| 解放运动 | 应用程序需要的自定义库文件 |
| 文件 | 开发人员保存到内部存储的文件 |
| 隐藏物 | 由应用程序缓存的文件，通常缓存来自 web 浏览器或使用 WebKit 引擎的其他应用程序的文件 |
| 数据库 | SQLite 数据库和日志文件 |

[表 4.1](#T0010) 仅显示了应用程序/数据/数据文件中最常见的子目录。随着我们在本书中更仔细地检查数据，我们将对许多额外的文件夹和数据文件进行编目。

### 数据是如何存储的

安卓为开发人员提供了五种将数据存储到设备的方法。法医鉴定人员可以发现五种格式中至少四种格式的数据。因此，详细了解每一个很重要。

持久数据存储在 NAND 闪存、SD 卡或网络中。具体来说，这五种方法是:

1.共享偏好

2.内部存储

3.外部存储

4\. SQLite

5.网络

除了应用程序开发人员存储的数据之外，Linux 内核和安卓堆栈还通过日志、调试和其他标准信息服务提供信息。

#### 共享首选项

共享首选项允许开发人员以轻量级的 XML 格式存储原始数据类型的键值对。可以存储在首选项文件中的基本数据类型包括:

1.布尔值:真或假

2.浮点:单精度 32 位 IEEE 754 浮点

3\. int: 32 位带符号二进制补码整数

4.长:64 位带符号二进制补码整数

5.字符串:字符串值，通常为 UTF-8

有了这些基本类型，开发人员可以创建和保存简单的值来支持他们的应用程序。

共享首选项文件通常存储在 shared_pref 文件夹中应用程序的数据目录中，并以. xml 结尾。在我们的参考 HTC envelocity 上，Android 手机共享首选项目录有五个 XML 文件:

![image](../images/F100044u04-01-9781597496513.jpg)

com . Android . phone _ preferences . XML 首选项文件中有 int、boolean 和 string 首选项的示例:

![image](../images/F100044u04-02-9781597496513.jpg)

可以看出，XML 文件描述了文件开头的字符串编码类型，在本例中是 UTF-8。有三个首选项可以保存各种设置和特征。从取证的角度来看，最有趣的可能是 updateAreaCode.xml:

![image](../images/F100044u04-03-9781597496513.jpg)

查询移动电话号码(MDN)，并将设备的区号存储在该文件中，大概是为了在支持该功能的区域允许七位拨号选项。

由于许多应用程序利用轻量级共享首选项方法来存储键值对，因此它可以成为取证数据的丰富来源。当审查员可以恢复旧版本或已删除版本的 XML 首选项文件时，尤其如此。

#### 内部存储器上的文件

文件允许开发人员存储更复杂的数据结构，并保存在文件内部存储器的几个地方。文件存储在应用程序的/data/data 子目录中，开发人员可以控制文件类型、名称和位置。默认情况下，文件只能由应用程序读取，即使设备所有者也无法查看文件，除非他们拥有 root 访问权限。开发人员可以覆盖安全设置，以允许其他进程读取甚至更新文件。

小费

### 识别自定义文件

确定应用程序子目录中哪些文件属于这一类别的最佳方法是消除过程。基本上，应用程序的/data/data/子目录中的任何文件，如果是 shared_prefs、lib、cache 或数据库子目录中的*而不是*，都是开发人员创建和控制的文件。

让我们来看看 com.google.android.apps.maps，它提供了一个保存在内部存储上的文件的好例子:

![image](../images/F100044u04-04-9781597496513.jpg)

该应用程序使用大多数可用的存储机制，并将文件存储在 app_ 和 files 目录的内部存储中。app_ directory 有几个子目录和一个不是已知文件格式的 cache_r.m 文件:

![image](../images/F100044u04-05-9781597496513.jpg)

文件目录存储了应用程序显示和更新谷歌地图所需的许多数据文件:

![image](../images/F100044u04-06a-9781597496513.jpg)

![image](../images/F100044u04-06b-9781597496513.jpg)

这些文件清楚地表明了法医分析师或安全工程师可能感兴趣的数据。对应用程序及其存储的数据进行更全面的数据分析将在[第 7 章](7.html)中介绍，安卓应用程序和取证分析。

#### 外部存储器上的文件

虽然存储在内部设备存储器上的文件具有严格的安全性和位置参数，但是各种外部存储设备上的文件具有少得多的约束。

首先，使用可移动 SD 卡的一个重要动机(超出成本)是数据可以在其他设备上使用，可能是升级的安卓设备。如果一个消费者购买了一个新的安卓设备，插入了他们以前的包含他或她的所有家庭照片和视频的 SD 卡，发现他们无法访问它们，他们会非常沮丧。

为了便于将 SD 卡安装在台式电脑上共享文件，SD 卡通常采用微软的 FAT32 文件系统进行格式化。虽然文件系统得到了广泛支持，但它缺乏 ext3、ext4、yaffs2、hfsplus 等文件系统内置的细粒度安全机制。因此，默认情况下，文件不能强制执行权限。

例如，前面提到的 com.google.android.apps.maps 应用程序也将 SD 卡上的数据存储在 Android/data 子目录中。以下是参考 HTC 不可思议 SD 卡的文件和目录列表，安装在/mnt/sd 卡:

![image](../images/F100044u04-07-9781597496513.jpg)

同样，宏达不可思议附带了一个模拟 SD 卡，直接存储在 NAND 闪存上。仿真 SD 卡安装在/mnt/emmc。下面是一个子目录的列表，其中存储了相册 jif 缩略图文件:

![image](../images/F100044u04-08-9781597496513.jpg)

如您所知，开发人员可以很好地控制外部和模拟 SD 卡上文件的名称、格式和位置。

#### SQLite

开发人员利用的另一种基于 NAND/SD 卡的存储是一种特定类型的文件 SQLite 数据库。数据库用于结构化数据存储，SQLite 是一种流行的数据库格式，出现在许多移动系统和传统操作系统中。

SQLite 受欢迎有很多原因。值得注意的是，整个代码库都是高质量的、开源的，并向公共领域发布。文件格式和程序本身非常紧凑，并且在不到几百千字节的时间内就包含了重要的功能。与更传统的关系数据库管理系统(RDBMS)不同，如甲骨文、MySQL 和微软的 SQL Server，使用 SQLite，整个数据库包含在一个跨平台的文件中。

安卓软件开发工具包提供了专用的应用编程接口，允许开发人员在他们的应用程序中使用 SQLite 数据库。SQLite 文件一般存储在/data/data/<packagename>/数据库下的内部存储器中。但是，在其他地方创建数据库没有限制。</packagename>

SQLite 数据库是取证数据的丰富来源。基于 WebKit 开源项目([http://webkit.org/](http://webkit.org/))的内置安卓浏览器提供了一个很好的例子。在我们引用的 HTC Extrend 中，有 28 个 SQLite 数据库位于/data/data/com.android.webkit 的子目录中。

app_icons: 1 个网页图标数据库

app_cache: 1 个包含 web 应用程序数据缓存的数据库

app_geolocation: 2 个与全球定位系统位置和权限相关的数据库

app_databases: 21 个数据库，为支持网站提供本地数据库存储

数据库:3 个用于浏览器和浏览器缓存的数据库

从这些文件中恢复有法律价值的数据的可能性非常大。

#### 网络

开发人员可以使用的最后一种数据存储机制是网络，这是设计用于网络感知的设备的主要优势。最初，很少有应用程序利用网络作为存储选项。然而，随着软件开发工具包、应用程序和设备的成熟，网络存储选项得到了更多的利用。

安卓开发者网站为那些对网络存储感兴趣的人提供了非常少的细节。他们的整个文档只有两句话长([数据存储，n.d.](#BIB3) )。

您可以使用网络(如果可用的话)在自己的基于 web 的服务上存储和检索数据。要进行网络操作，请使用以下包中的类:

Java . net .

Android . net .

文档中引用的包本质上为开发人员提供了与网络、web 服务器等交互所需的低级 API。利用网络的应用程序需要更多的自定义编码，虽然所有感兴趣的数据可能不会存储在设备上，但重要的配置和数据库文件通常是可恢复的。

例如(作为[第 7 章](7.html)、安卓应用和取证分析的潜在高峰)，Dropbox 是一个流行的文件共享网站，它有安卓、黑莓和 iOS 设备的移动应用。他们目前的安卓应用(1.0.3.0 版本)已经从安卓市场下载了超过 25 万次，拥有超过 35，000 个用户评级，大多数都相当高。安装应用程序后，您可以在/data/data/com.dropbox.android 上找到应用程序文件夹，其中包含四个标准目录:

![image](../images/F100044u04-09-9781597496513.jpg)

log.txt 是详细的活动日志，提供了几行供参考:

![image](../images/F100044u04-10-9781597496513.jpg)

上述清单中强调了一些潜在的利益项目，特别是:

1.所有动作都有时间戳

2.成功认证用户，提供用户名

3.从图库导入的图片

4.上传 SD 卡上的具体文件

5\. Dropbox 服务被电话中断

该应用程序还有一个共享的首选项文件:

![image](../images/F100044u04-11-9781597496513.jpg)

使用 sqlite3 命令行程序快速检查 db.db 会产生以下数据(您也可以使用图形化的 sqlite 浏览器来查看数据库):

![image](../images/F100044u04-12-9781597496513.jpg)

该数据库提供了关于 Dropbox 应用程序、设备以及最终可能与之交互的用户和人员的重要取证和安全数据。当安卓应用程序安装并登录时，“安卓简介. pdf”文件被 Dropbox 自动同步到 Dropbox 帐户。当共享的 PDF 文件被查看时，它被缓存在 SD 卡上。关于文件及其使用的附加元数据包含在数据库中。尽管 Dropbox 在应用中广泛使用网络数据存储，但我们仍然可以恢复有用的信息。

#### 内核、系统和应用程序日志

法医分析师和安全工程师可以找到与调查或审计相关的文件和信息的另一个领域是标准的 Linux 文件系统。不幸的是，这是相当广泛和压倒性的，但我们至少可以提供一个寻找相关信息的起点。

日志文件和调试是开发人员和管理员维护系统和应用程序的两种常见而有效的方式。它提供了对应用程序以及运行它们的系统的洞察。虽然并非在所有情况下都是如此，但通过简单地检查各种日志和调试文件，就可以从安卓设备中收集重要信息。

##### Linux 内核日志记录

Linux 内核是 Linux 操作系统的低级抽象接口，提供对设备硬件的访问。由于内核的角色是设备上所有功能的核心，因此记录关键事件和活动的能力得到了高度利用。内核日志可以通过命令 dmesg 在 Linux(也就是安卓)设备上访问。这将打印出所有可用的内核消息，其中一部分显示在这里:

![image](../images/F100044u04-13a-9781597496513.jpg)

![image](../images/F100044u04-13b-9781597496513.jpg)

正如您可能注意到的，数据相当冗长和低级。但是，它可以提供重要的时间戳和活动，以及启动时关于设备的大量信息。但是，如果设备最近没有重新启动，启动时的初始日志将不再可用。

除了必须启用 USB 调试之外，此命令不需要设备上的任何特殊权限。如果您在设备或模拟器上运行此命令，您会注意到屏幕上显示了太多数据。您可以通过将 dmesg 的内容传送(或发送)到一个名为 wc(表示字数)的程序并指示它计算行数来确定日志中可用的总行数:

![image](../images/F100044u04-14-9781597496513.jpg)

所以，在参考 HTC 不可思议上，我们在内核日志中有 1859 行。如果您需要更仔细地检查信息，或者将其包含在报告中，您可以将 dmesg 的输出重定向到具有以下内容的文件:

![image](../images/F100044u04-15-9781597496513.jpg)

现在，您可以通过在文本编辑器或显示程序中打开 dmesg.log 来检查可用内核日志的内容。

##### 日志猫

安卓有几种额外的调试技术可用。一个名为 logcat 的程序显示系统和应用程序调试消息的持续更新列表。

![image](../images/F100044u04-16a-9781597496513.jpg)

![image](../images/F100044u04-16b-9781597496513.jpg)

快速浏览一下上面的小日志片段就会发现

经纬度数据

日期/时间信息

应用详情

日志记录非常冗长，这里提供的示例只是可用内容的一小部分。每个日志消息都以消息类型指示器开始，如[表 4.2](#T0015) 所述。

表 4.2 日志方法类型

| 消息类型 | 描述 |
| --- | --- |
| V | 冗长的 |
| D | 调试 |
| 我 | 信息 |
| W | 警告 |
| E | 错误 |
| F | 致命的 |
| S | 沉默的 |

logcat 程序还提供完整蜂窝无线电调试的日志，可以使用以下命令查看(仅包括无线电日志的选定部分):

![image](../images/F100044u04-17-9781597496513.jpg)

虽然日志记录冗长且通常含糊不清，但扫描上面的日志可以提供以下信息:

事件时间(在 Unix 纪元中，例如，t=1296218163)

蜂窝调制解调器用来通信的 AT 命令

接收人、大小、时间和编码短信

设备的蜂窝 IP 地址、网络和位置信息

无线载波信息

这些信息的水平很低。但是，如果恢复此类日志，它们可能会泄露有关设备的重要信息。

注意

### Unix 纪元

Unix Epoch 时间是基于 Unix/Linux 的系统中时间戳的常见格式。时间戳是一个整数值，表示自 1970 年 1 月 1 日以来的秒数(或毫秒数)。使用秒的典型时间戳将有 10 位数，而使用毫秒的时间戳将有 13 位数。时间戳在[第 7 章](7.html)中有更详细的介绍。

logcat 的最后一个功能是事件日志显示:

![image](../images/F100044u04-18-9781597496513.jpg)

同样，该日志非常冗长。但是，当系统中发生不同的事件时，它们会在这里记录大量的信息。在前面的日志片段中，我们可以看到用于存储文本消息的 mmssms.db 上的 INSERT 和 SELECT 语句。

##### 倾印系统

下一个日志机制是通过一个名为 dumpsys 的命令来访问的。

Dumpsys 提供服务、内存和其他系统详细信息，这些信息可以提供有用的信息。提供的一些信息类型包括

当前运行的服务

每个服务的转储

当前活动管理器状态下的服务、广播、待定意向、活动和流程

过程信息，包括内存、过程标识、数据库等

接下来列出了参考 HTC Encrystal dumpsys 的示例部分，每个部分都包括对数据如何对法医分析师或安全工程师有价值的简要解释。

首先，按如下方式运行 dumpsys 命令:

![image](../images/F100044u04-19-9781597496513.jpg)

转储服务“帐户”的详细信息部分包含有关设备上使用的各种帐户的有价值的信息。

![image](../images/F100044u04-20-9781597496513.jpg)

您不仅可以看到使用的程序，有时还可以看到特定于用户的帐户名。例如，上面揭示了:

用户名为[book@viaforensics.com](mailto:book@viaforensics.com)的谷歌账户

用用户名[book@viaforensics.com](mailto:book@viaforensics.com)交换动态同步(EAS)账户(与上面的谷歌账户分开)

安德鲁·霍格的脸书账户

【viaforensics 的推特账户

personal@emailaddress.com 的谷歌账户(设备上的第二个)

日志中还类似地提供了最近 10 次同步的实际时间戳:

![image](../images/F100044u04-21-9781597496513.jpg)

另一项服务幽默地命名为“iphonesubinfo”，尽管名称相似，但显然与苹果的 iPhone 无关。

![image](../images/F100044u04-22-9781597496513.jpg)

电话类型和设备标识(已更改)均可从该部分获得。设备标识不是设备的序列号，而是移动设备标识符(MEID)，它在码分多址网络中唯一标识设备。

另一个很好的信息来源是显示最后已知位置信息和时间的位置服务。

![image](../images/F100044u04-23-9781597496513.jpg)

安卓系统中的大多数时间戳是自 1970 年 1 月 1 日以来的毫秒数，这是 Unix Epoch 时间——然而，以毫秒而不是秒为单位。由于大多数工具根据秒来转换 Unix Epoch，所以您可以将数字除以 1000，然后使用标准公式。如果您构建了 Ubuntu 工作站，您可以使用以下命令行进行转换:

![image](../images/F100044u04-24-9781597496513.jpg)

这将在工作站的时区输出。您可以使用命令上的各种开关来控制时区、格式和许多其他参数。要查看全部可能性，运行“约会帮助”或“男人约会”

检查上面的三个缓存位置，我们可以看到系统在以下时间从 GPS 卫星和蜂窝塔缓存的位置:

1\. GPS:从而在 2011 年 1 月 27 日 13:51:13 CST

2.小区:Fri 时间 2011 年 1 月 28 日 09:56:48

位置对于记录的时间是准确的，因此提供了关于设备位置的极好的历史信息。

网络状态部分提供了更多信息，包括有关手机信号塔的更详细信息:

![image](../images/F100044u04-25a-9781597496513.jpg)

![image](../images/F100044u04-25b-9781597496513.jpg)

最后要指出的一个部分是内存信息部分，它是为每个 PID 输出的:

![image](../images/F100044u04-26-9781597496513.jpg)

这不仅有助于确定哪些进程正在运行，而且有助于确定它们访问的数据库。例如，一个案例可能需要调查人员更好地了解在收到电子邮件时更新了哪些信息。在上面的清单中，您可以看到电子邮件应用程序(com.htc.android.mail)不仅更新了 mail.db，还更新了两个附加到 people_db 的 web 相关数据库。当解释安卓设备上的数据如何相互关联时，这些信息非常有用。

##### 转储状态

另一个调试命令是 dumpstate，它将以前调试的部分与系统信息结合在一起。与其他命令类似，您可以使用以下命令运行该命令:

![image](../images/F100044u04-27-9781597496513.jpg)

adbd 以 root 身份运行的仿真器或设备上显示的第一部分是应用程序的堆栈跟踪。但是，在参考 HTC 设备上，dumpstate 返回一个被拒绝的权限。紧接着是关于设备、构建、无线电、网络和内核细节的基本信息。其余日志包含[表 4.3](#T0020) 中概述的部分。

表 4.3 转储状态部分

| 部分 | 文件或命令 |
| --- | --- |
| 堆栈跟踪 | 不适用的 |
| 设备信息 | 不适用的 |
| 系统 | 不适用的 |
| 记忆信息 | /proc/meminfo |
| 处理器信息 | top -n 1 -d 1 -m 30 -t |
| 普罗克兰克 | (普罗克兰克) |
| 虚拟内存统计 | /proc/vmstat |
| vmalloc 关于 | /proc/vmallcinfo |
| 平板信息 | /proc/slabinfo |
| Zoneinfo | /proc/zoneinfo |
| 系统记录 | logcat -v time -d <sup>∗</sup> ：v |
| 事件日志 | logcat -b 事件-v 时间-d<sup>∫</sup>:v |
| 放射学 | logcat -b 无线电-v 时间-d<sup>:v</sup> |
| 网络接口 | netcfg |
| 网络路由 | /proc/net/route |
| Arp 缓存 | /proc/net/arp |
| 转储无线固件日志 | su root dhdutil -i eth0 上传/数据/本地/tmp/wlan_crash.dump |
| 系统属性 | 不适用的 |
| 内核日志 | dmesg-一般信息 |
| 内核唤醒锁 | /proc/wake lock |
| 内核 cpufreq | /sys/devices/system/CPU/CPU 0/cpufreq/stats/time _ in _ state |
| 暴力转储 | vdc 转储 |
| 安全容器 | vdc asec 列表 |
| 处理 | ps -p |
| 进程和线程 | ps -t -p -p |
| 天秤座 | 天秤座 |
| 绑定失败的事务日志 | /proc/binder/failed _ transaction _ log |
| 活页夹事务日志 | /proc/binder/事务日志 |
| 绑定交易记录 | /proc/binder/transactions |
| 活页夹统计 | /proc/binder/stats |
| 粘合剂工艺状态 | sh-c cat/proc/binder/proc/<sup>∫</sup>-p |
| 文件系统和可用空间 | df |
| 包设置 | /data/system/packages . XML:2011-01-26 09:18:02 |
| 包 uid 错误 | /data/system/uid errors . txt:2010-11-14 22:52:26 |
| 最后一个 kmsg | /proc/last_kmsg |
| 上次无线电日志 | parse _ radio _ log/proc/last _ radio _ log |
| 最后一个紧急控制台 | /data/dontpanic/apanic_console |
| 最后一个紧急线程 | /data/dontpanic/apanic_threads |
| 阻塞的进程等待通道 | 不适用的 |
| 背光 | 不适用的 |
| 倾印系统 | 倾印系统 |

##### 错误报告

最终调试命令进一步建立在前面的命令之上，将 logcat、dumpsys 和 dumpstate 调试输出合并到一个命令中，并显示在屏幕上，以便提交错误报告。该命令按如下方式运行:

![image](../images/F100044u04-28-9781597496513.jpg)

它从运行 dumpstate 开始。当对参考 HTC 不可思议运行时，输出被保存到一个文件中，然后执行行计数:

![image](../images/F100044u04-29-9781597496513.jpg)

如您所见，该报告生成了 42，000 多行调试信息，其中包含大量时间戳、应用程序数据和系统信息。分析这些数据将产生有用的信息。然而，如果手动处理数据，任务是艰巨的。

## 存储器类型

正如[第 2 章](2.html)所讨论的，安卓设备有两种主要的内存类型，易失性(RAM)和非易失性(NAND flash)内存。每种方法都提供了对设备数据的不同见解。

### 随机存取存储

系统使用内存来加载、执行和操作操作系统、应用程序或数据的关键部分，并且不会在重新启动时保存。像传统计算机一样，内存可以包含应用程序用来处理数据的非常重要的信息。一些例子包括:

密码

加密密钥

用户名

应用数据

来自系统流程和服务的数据

最近出现了检查安卓内存的解决方案。安全研究员托马斯·坎农在他的博客上记录了一种技术，我们将详细介绍这种技术。

安卓提供了一种机制，通过向应用程序发送特殊信号(SIGUSR1)，将应用程序的内存转储到文件中。要发送信号，您需要一个应用程序的 PID，可以通过 ps 命令找到:

![image](../images/F100044u04-30-9781597496513.jpg)

ps 命令列出所有系统和应用程序进程以及父进程 id、内存信息和名称。由于一个典型的设备有许多正在运行的进程，上面的列表只显示了输出的一部分。

接下来，我们需要在具有 root 权限的设备上运行一个交互式 shell，并且 set /data/misc 具有足够的权限来写入然后读取内存转储:

![image](../images/F100044u04-31-9781597496513.jpg)

警告

### 更改文件夹权限

chmod 命令更改/data/misc 文件夹的权限，授予对系统上所有用户帐户的读、写和执行权限。此更改对于成功的内存转储是必要的。然而，这是一个由法医分析师公开做出的系统改变。如果这种分析是合理的，那么应该在您的报告中注明更改，理想情况下，文件夹权限应该在内存转储后恢复到默认设置。

从这里，我们可以发送转储内存和显示目录内容所需的信号:

![image](../images/F100044u04-32-9781597496513.jpg)

文件堆转储-tm1296350817-pid1294.hprof 包含内存转储，我们可以退出交互式 adb shell，将文件拉到本地工作站进行分析:

![image](../images/F100044u04-33-9781597496513.jpg)

从那里开始，使用你所掌握的任何记忆分析技术。例如，您可以使用命令字符串提取 ASCII 字符串:

![image](../images/F100044u04-34-9781597496513.jpg)

然后查看文件的内容。对 Gmail 内存的快速扫描提供了关于该应用程序引用的各种加密库以及 HTTP 流量的信息:

![image](../images/F100044u04-35-9781597496513.jpg)

脸书应用程序使用一种称为 JSON 的文件格式来编码和传输数据，产生了以下结果:

![image](../images/F100044u04-36-9781597496513.jpg)

这些例子在被收入本书之前已经过净化。但是，您可以看到时间戳、个人资料更新、朋友信息、签到等。

对安卓设备的内存分析可以深入了解设备的内部结构以及设备所有者的关键信息。随着时间的推移，预计市场上会有更多的解决方案来解决安卓内存的分析问题。

#### 资料储存型闪存

与随机存取存储器不同，与非门闪存是非易失性的，因此即使设备断电或重新启动，数据也会保留下来。NAND 闪存不仅用于存储系统文件，还用于存储用户数据的重要部分。

NAND 闪存具有与现代硬盘中的磁介质非常不同的特性。这些特性使 NAND 闪存成为移动设备的理想存储，同时也给程序员带来了许多挑战，给法医分析师带来了许多机会。

首先，NAND 闪存没有像传统磁性硬盘驱动器中的旋转盘片和臂那样的机械运动部件。这提高了耐用性，并减小了设备的尺寸和功耗。内存以一个或多个芯片的形式分布，通常同时集成 NAND 闪存和 RAM (MCP，参见[第 2 章](2.html))并直接集成到器件的电路板中。

NAND 闪存也具有非常高的密度，并且制造成本低。这当然让它很受厂商欢迎。总的来说，制造工艺和技术的一个副作用是，NAND 闪存实际上直接从制造商那里运送坏块。制造商通常将测试存储器作为制造过程的一部分，并在 NAND 闪存的特定结构中标记坏块，这在他们的文档中有所描述。然后直接与 NAND 闪存交互的软件可以读取制造商的坏块标记，并且通常会实现一个坏块表，该表可以逻辑地跟踪系统上的坏块，并将其从操作中移除。这大大加快了坏块的检测和管理。因此，虽然 NAND 闪存在物理上比旋转盘片更耐用，但其错误率要高得多，必须在开发和使用中加以考虑。

与非门闪存的另一个显著限制是，在块不再能够存储数据之前，它的写/擦除寿命非常有限。寿命因器件而异，并在很大程度上受每个 NAND 闪存单元存储的数据量的影响，NAND 闪存单元是存储 1 位或 0 位的核心构建模块。如果该单元仅存储单个位(单级单元或 SLC)，则 NAND 闪存的额定写/擦除周期约为 100k，数据保留期为一年。然而，NAND 闪存很少使用 SLC，因为制造商(和消费者)要求在类似大小或更小的设备中存储更多数据。该技术已经发展到多级单元(MLC)，其中一个单元可以为每个单元存储两个、三个甚至更多的位。然而，这不仅使制造过程变得复杂并减慢写入/擦除周期，而且还显著降低了器件的耐久性。典型的每单元存储两位的多层与非闪存在大约 10k 个写入/擦除周期的情况下，耐久性(以一年的数据保持率衡量)降低了 10 倍。随着每个单元的比特密度增加，耐久性继续下降，这显然必须由控制设备来解决。

与随机存取存储器和非易失性存储器不同，非易失性存储器也是闪存，通常用于计算机的基本输入输出系统或基本输入输出系统等系统，因此不能随机访问。相反，对数据的访问是通过称为页面或块的分配单元来实现的，该分配单元通常在 512 到 2048 字节之间，但是通常随着 NAND 闪存的整体大小的增加而增加。即使与非门闪存不像随机存取存储器那样提供快速随机存取，存取时间仍然相当快，因为它不需要传统旋转硬盘中使用的机械盘片和手臂运动。

注意

### 页面对区块

在本书中，我们将使用单词 page 和 chunk 同义词来指代 NAND 闪存中引用的低级数据分配单元。虽然分配单元通常被称为页面，但作为安卓关键组件的 YAFFS2 文件系统通常将分配单元称为块。

然后，块被组织成一个更大的逻辑单元，称为块，它通常比传统的 512B 硬盘驱动器扇区大得多。在大多数安卓设备中，NAND 闪存块包含 64 个数据块，每个数据块为 2048 字节。取 64 × 2 KB 产生 128 KB 的块大小。当然，这可以而且将随着时间的推移而改变，并且由 n and 闪存制造商控制。当一个块被分配用于写入时，块内的块被顺序写入。

NAND 闪存的另一个非常重要的特性是可用于读写的操作:

阅读(第页)

写(页)

擦除(块)

虽然可以读取或写入单个块，但擦除操作仅在块级别起作用。当一个块被擦除时，整个块用 1 或 0xFF(十六进制)重写。

注意

### 与非门闪存擦除操作

*擦除操作是 NAND 闪存中唯一可以将 0 变为 1 的机制。*这一点值得强调。在传统的硬盘驱动器中，如果一个值从 0 变为 1(反之亦然)，程序将简单地寻找硬盘驱动器上的值，并施加适当的电压来改变和存储新值。然而，与非门闪存的基本架构只提供了一种将 0 变为 1 的机制，即通过在块级而不是单个页面级应用的擦除功能。因此，一个页面只能写入一次，如果页面的值需要更改，则必须擦除整个块，然后才能写入页面。

为了简单起见，这里有一个使用单个字节的具体示例:假设这个特定的字节保存十进制值 179，并且我们想要将 39 相加，得到总值 218。对于那些不熟悉在 base10、十六进制(base16)和二进制(base2)之间转换数字的人来说，Windows、Mac OS X 和 Ubuntu Linux 中的内置计算器程序提供了一种程序员模式来执行转换。对于上面的数字，我们有编号系统之间的转换，如[表 4.4](#T0025) 所示。

表 4.4 整数的十进制、十六进制和二进制表示

| 十进制(十进制) | 十六进制(base16) | 二进制(base2) |
| --- | --- | --- |
| One hundred and seventy-nine | 0xB3 | 1011 0011 |
| Two hundred and eighteen | 0xDA | 1101 1010 |

所以值 179 包含三个 0，其中两个需要变成 1 来表示我们的新值 218。但是，如果不擦除整个块，NAND 闪存就无法进行这种更改。因此，如果在没有擦除的情况下尝试这个单字节，结果将是 146，而不是 218。这是如何发生的:

![image](../images/F100044u04-37-9781597496513.jpg)

由于字节不包含所有 1(0xFF)，写入周期中成功的部分只有 1，要么保持 1，要么变为 0。每当写函数遇到 0 并被请求更改为 1 时，它都会失败并简单地保留 0 值。结果字节是 0x92 或 146 base10，显然不是预期值。描述写功能的另一种方式是，它只在请求时将带电荷的 1 值更改为 0，相当于两个值的“逻辑与”。

总之，一个块只能写一次，如果需要重写，必须先擦除整个块。

正如您所知，NAND 闪存强加了各种限制，因此开发人员和文件系统必须了解闪存，才能在限制范围内有效工作。与传统硬盘附带固件来管理设备(包括坏块)不同，安卓设备中使用的 NAND 闪存不附带控制器。存储器的所有管理必须在与 NAND 闪存接口的软件中实现。采用的两项重要技术是纠错码和损耗均衡。两者对取证和数据恢复都有重大影响。

首先，ECC 是一种技术，其中使用算法来检测读或写操作中的数据错误，并动态纠正一些错误。由于 NAND 闪存会随着使用时间的推移而退化，因此系统必须能够检测到页面或数据块何时变坏，并恢复存储在其中的数据。超过一定数量的错误或失败操作(通常是三次失败操作)后，页面或块将被标记为坏，并添加到坏块表中。

用于在安卓系统上有效管理 NAND 闪存的第二个重要算法是损耗均衡代码，该代码将数据写入分散到整个 NAND 闪存中，以避免单个区域的过度利用，从而更快地将这些块耗尽。

许多使用 NAND 闪存的硬件设备，如可移动 USB 拇指驱动器和固态驱动器(SSD)，其控制器逻辑与设备捆绑在一起，提供上述功能，包括坏块管理、损耗均衡和纠错码。然而，安卓设备被设计成直接集成 NAND 闪存组件，因此需要软件管理层来提供这些重要功能。被选来管理 NAND 闪存的层是存储技术设备(MTD)系统。

MTD 的开发是为了满足 NAND 闪存和类似设备的需求，因为它们具有独特的特性。在 MTD 之前，Linux 主要支持字符设备和块设备。这两种设备类型都没有解决新开发的存储设备的独特属性。此外，虽然 NAND 闪存严格来说不是块设备(与传统硬盘驱动器一样)，但向开发人员展示块设备特性有助于开发和支持。通过利用 MTD，安卓现在拥有了与 NAND 闪存有效交互所需的必要闪存过渡层(FTL)。通过采取这种方法，安卓没有阻止制造商使用一小部分 NAND 闪存提供商和相关控制器。相反，他们可以自由使用任何可用的 NAND 闪存，然后“简单地”与支持各种 NAND 闪存的 MTD 集成。

在 Android 中，MTD 不仅提供 NAND 闪存的块接口，还提供 ECC、损耗均衡和其他关键功能。ECC 和其他块元数据存储在称为带外(OOB)或备用区的保留区中。OOB 位于 NAND 闪存上每个区块的正后方。虽然区块、区块和 OOB 布局是可配置的，但迄今为止大多数安卓设备都有一个 128 KB 的区块，由 64 个 2，048 字节(2k)的区块组成，每个区块都有一个 64 字节的 OOB，如图 4.1 所示。

![image](../images/F100044f04-01-9781597496513.jpg)

图 4.1 数据块(128 千字节= 64 × 2k 数据块+ OOB)。

OOB 不仅存储由 MTD 管理的信息，还可以存储对文件系统至关重要的元数据，前提是文件系统支持 NAND 闪存。虽然系统将数据块显示为 128 KB，但如果加上 64 OOB(每个 64 字节)，还会增加 4096 字节(4 KB)，从而使 NAND 闪存上使用的总字节数达到 132 KB。

在安卓设备上，可以通过查看/proc/mtd 文件来确定 MTD 分区。关于我们的参考 HTC 不可思议，我们有以下:

![image](../images/F100044u04-38-9781597496513.jpg)

有七个 MTD 分区，下一节将研究它们的挂载位置，并提供找到的目录和文件的高级概述。在上一个列表中，大小和擦除大小都是十六进制值，提供了重要的 MTD/NAND 闪存属性。erasesize 指定每个块的大小，十进制为 0x20000 或 131，072 字节或 128 KB (128 × 1024)。这与数据块图一致，具体为 64 页，每个 2048 (2 KB)大小。size 列指定该分区的总大小。因此，在这个例子中，我们有 MTD 分区，如[表 4.5](#T0030) 所示。

表 4.5 MTD 分区大小转换

![Image](../images/T100044tabT0030.jpg)

还可以使用 df(磁盘空闲)命令验证表 4.5 中的值，该命令提供了已装载文件系统及其总空间、已用空间和可用空间的列表。以下是/system 的测向数据:

![image](../images/F100044u04-39-9781597496513.jpg)

正如您所看到的，在/proc/mtd 中找到的大小在我们的转换和 df 命令显示中都是一致的。

现在我们已经建立了对 NAND 闪存和 Android MTD 的基本理解，接下来我们将研究 Android 使用的各种文件系统。

## 文件系统

像大多数 Linux 系统一样，安卓系统上有几个正在使用的文件系统，其中许多用于引导和运行系统。虽然我们将讨论几个文件系统，但主要关注存储用户数据的分区，尤其是 EXT、FAT32 和 YAFFS2 文件系统。

要确定 Linux 内核(以及安卓)支持什么文件系统，您可以检查文件/proc/filesytem 的内容。在我们的参考 HTC 不可思议，它包含以下内容:

![image](../images/F100044u04-40-9781597496513.jpg)

在宏达不可思议支持的 18 个文件系统中，只有 5 个由 NAND 闪存或 SD 卡等物理设备支持。其余文件系统具有“nodev”属性，这意味着它们本质上是虚拟文件系统，不会写入任何物理设备。此外，设备上实际使用的 nodev 文件系统只有六个:

1.根

2\. tmpfs

3\. 组

4.继续

5\. sysfs

6.发展点

并且使用了三个设备支持的文件系统:

1\. ext3

2\. yaffs2

3\. 脱脂

以下各节简要概述了大多数文件系统，并深入分析了存储大量用户数据的 YAFFS2。

### 根文件系统、开发文件系统、系统文件系统和组文件系统

Linux 中的许多文件系统用于引导、操作或管理系统，并且通常不包含在取证调查中有用的信息。然而，安全工程师和研究人员可能会仔细检查这些文件系统和内核的内部工作，试图找出安全漏洞和其他弱点。我们将很快重点介绍安卓系统中与基础设施相关的四种文件系统。

首先，rootfs 是内核在启动时挂载根文件系统的地方(目录树的顶部，用正斜杠标出)。为了让内核完成引导过程，它需要访问核心文件和库，因此需要挂载根文件系统。随着内核完成引导过程，后续文件系统将作为目录从根文件系统中挂载出来。例如(本章稍后将详细介绍)，根文件系统将装载在/并包含关键文件。然后将在/system 处安装一个更完整的系统目录。您可以通过在 shell 中运行“ls -l”命令或键入“mount”来查看根文件系统和目录，以查看装载了哪些文件系统以及在根文件系统的哪个目录中。

devpts 文件系统用于在 Android 设备上提供模拟终端会话，类似于使用 telnet 或 ssh 连接到传统的 Unix 服务器。每次虚拟终端连接时，都会在/dev/pts 下创建一个新节点。例如，如果您有一个到安卓设备的 adb shell 连接，/dev/pts 将显示以下内容:

![image](../images/F100044u04-41-9781597496513.jpg)

但是，在下一个示例中，有两个 adb shell 连接和一个来自设备上安装的应用程序的终端应用程序连接:

![image](../images/F100044u04-42-9781597496513.jpg)

可以看到，原来的/dev/pts/0 连接是存在的。但是，现在有两个额外的连接，一个来自终端应用程序，在应用程序的唯一用户 id (app_105)下运行。

Sysfs 是另一个虚拟文件系统，包含设备的配置和控制文件。在宏达不可思议上，存在以下顶级目录:

![image](../images/F100044u04-43-9781597496513.jpg)

出于好奇，您可以对您的取证工作站执行 adb pull on /sys，因为任何用户都可以读取这些文件。执行以下操作:

![image](../images/F100044u04-44-9781597496513.jpg)

如您所见，提取了大量文件，现在您可以使用全套 Linux 工具来检查数据。虽然这些信息的取证价值需要额外的研究，但它显然提供了设备的低级信息，有助于安全研究。例如，如果您想了解有关 NAND 设备的更多信息，可以查看以下目录:

![image](../images/F100044u04-45-9781597496513.jpg)

然后每个文件:

![image](../images/F100044u04-46-9781597496513.jpg)

详细了解 NAND 设备显然是取证和安全分析的重要一步。有近 3000 个文件，有相当多的数据需要检查。这里有一种快速查看文件名、路径和大小的方法，可以让您轻松检查相关文件(尝试运行两个终端会话，并在一个终端中列出文件，然后使用复制/粘贴在另一个终端中“复制”文件内容):

![image](../images/F100044u04-47a-9781597496513.jpg)

![image](../images/F100044u04-47b-9781597496513.jpg)

小费

### 附加 sysfs 分析

除了手动检查 sysfs 文件系统之外，互联网上还有提供额外背景的详细资源。帕特里克·莫切尔的一篇论文提供了一个有用的背景。

最终的虚拟文件系统称为 cgroups，用于跟踪和聚合 Linux 文件系统中的任务。在宏达不可思议上，创建了两个 cgroup 文件系统:一个在/dev/cpuctl，另一个在/acct。虽然额外的分析可能会产生结果，但会计数据通常证明在法医分析中没有用。

### 过程

proc 文件系统在/proc 目录下以结构化的方式提供关于内核、进程和配置参数的详细信息。shell 用户可以检查一些文件。但是，许多文件会阻止访问，除非您拥有 root 权限。和以前一样，探索 proc 文件系统的一种方法是将文件从 Android 设备拉到您的取证工作站上。这将需要一些时间，并且可能会挂起某些文件，导致副本不完整。

![image](../images/F100044u04-48-9781597496513.jpg)

在宏达不可思议上，当试图复制进程 76 时，上述进程挂起，必须用 Ctrl-C 取消:

![image](../images/F100044u04-49-9781597496513.jpg)

在取消之前，我们成功提取了 25 MB 的数据和近 6000 个文件。与 sysfs 检查一样，您可以使用 find 命令手动检查数据，以定位和列出文件:

![image](../images/F100044u04-50-9781597496513.jpg)

或者，您可以直接从 adb shell 中检查/proc 中的一些文件，如下所示:

![image](../images/F100044u04-51-9781597496513.jpg)

可以在 proc 文件系统中找到关于该设备的有价值的信息。审查员可以审核这些文件，应该从/proc 目录而不是子目录中的文件开始。

### tmpfs

tmpfs 是一种文件系统，它将所有文件存储在由 RAM 支持的虚拟内存中，如果存在，还存储设备的交换或缓存文件。此时大多数安卓设备都没有交换空间。但是，一些售后固件支持此功能。tmpfs 的优势在于，通过使用内存，存储速度非常快，而且是非永久性的，因此不会在重新启动时保存。

当然，对于法医检验人员来说，这是一个挑战。如果重要数据位于 tmpfs 装载点，则必须在设备重新启动或断电之前收集这些数据。它还提供了一个独特的机会，因为 tmpfs 通常是外壳用户可读的，取证程序可以在 tmpfs 中复制和执行，而无需修改 NAND 闪存或 SD 卡。这可能允许检查人员从安卓设备获取取证数据，而无需以任何方式修改 NAND 闪存或 SD 卡。

警告

### 调查 tmpfs

如果您的主要兴趣是设备的内存分析，则不建议对 tmpfs 进行更改，除非您首先拥有您感兴趣的内存部分的取证副本。

在宏达不可思议上，标准安装有四个 tmpfs 挂载点:

/dev

□t0//mnt/asec

/app-cache

□t0//mnt/sdcard/。android_secure

/dev 目录包含设备文件，允许内核读写连接的设备，如 NAND 闪存、SD 卡、字符设备等。/mnt/asec 和/mnt/sdcard/。android_secure 目录是 android 的一个相对较新的补充，允许应用程序存储在 SD 卡上，而不是/data/data，这样可以提供更多的存储空间。

有趣的是，/app-cache 也是一项新功能，似乎提供了 tmpfs 空间，应用程序可以使用。在 HTC Entry 上，网络浏览器(com.andrew.browser)在/app-cache 中创建了一个目录，并存储网络浏览的缓存文件。

![image](../images/F100044u04-52-9781597496513.jpg)

从第一个列表中，我们可以看到 app-cache 目录为所有用户设置了读、写和浏览权限。此外，权限“rwxrwxrwt”中的最后一个“t”表示只有根目录或目录的所有者才能删除或重命名该目录。

第二个列表显示了目录内部的 app-cache，它只有 com.android.browser .然而，随着我们对目录的深入挖掘，我们发现我们最感兴趣的目录和文件只允许 app 本身(com.android.browser，app_12 的用户 id)或 root 访问这些文件。

![image](../images/F100044u04-53-9781597496513.jpg)

由于我们在设备上拥有根访问权限，以下是包含的目录:

1.4 兆字节的数据

64 个文件

18 个 ASCII 文件(大部分是 CSS 和 JavaScript)

1 个空文件

9 个 GIF 文件

5 个 HTML 文件

11 个 JPEG 文件

17 PNG 文件

3 个 UTF-8 档案

![image](../images/F100044u04-54-9781597496513.jpg)

如果从你的 Ubuntu 工作站浏览 webviewCache 目录，可以轻松预览图像和其他文件([图 4.2](#F0015) )。

![image](../images/F100044f04-02-9781597496513.jpg)

图 4.2 Ubuntu 工作站的浏览器 webviewCache。

/app-cache tmpfs 目录包含在取证调查中非常重要的信息。这突出表明，越来越需要教育一线响应人员，以确保设备得到正确处理，从而最大限度地提高法医调查的有效性。

### 扩展文件系统

扩展文件系统(EXT)是专门为操作系统开发的 Linux 事实上的文件系统。众所周知，Linux 支持大量的文件系统。但是，默认值是 EXT。自从 EXT 的原始版本在 1992 年开发以来，已经有了三个附加版本:EXT2、EXT3 和 EXT4。

尽管 EXT 已经成为大多数笔记本电脑、台式机和服务器 Linux 发行版不可或缺的一部分，但它在早期的安卓设备中并没有出现。然而在 2010 年，EXT 开始出现在设备中，2010 年 12 月 9 日，谷歌在他们的 Android Developer 博客中宣布，越来越多的 Android 设备将从 YAFFS 转移到 EXT([Android Developer blog，n.d.](#BIB1) )。从 YAFFS 到 EXT 的迁移似乎是由网上讨论的几个因素驱动的，包括

越来越多的安卓设备从原始 NAND 闪存转向常规块设备(eMMC)

EXT4 是一个标准的 Linux 文件系统，支持完整的 Unix 权限和语义

EXT4 稳定，性能高

YAFFS 是单线程的，这将在即将推出的双核系统上遇到瓶颈

第一个使用 EXT4 的安卓设备是谷歌 Nexus S，预计很多运行安卓蜂窝版本的平板设备也会使用这种新的文件系统。由于目前只有一款安卓设备使用 EXT4，随着时间的推移，预计会有许多变化。目前，Nexus 在以下挂载点使用 EXT4:

系统映像(只读，/系统)

本地用户数据(读-写，/数据/数据)

缓存分区(读-写、/缓存和其他可能的分区)

从取证的角度来看，EXT4 仅仅是审查员需要理解和取证工具需要支持的另一个文件系统。当然，大多数取证工具并不完全(甚至名义上)支持 EXT4，所以这就出现了一点问题。文件雕刻技术确实有效，预计随着时间的推移，更多的取证软件将开始支持文件系统。

### FAT32/VFAT

安卓设备通常有一个或多个微软 FAT32 分区，一般在 SD 卡和 eMMC 上。利用这一古老的文件系统的原因不是由于卓越的设计，而是由于与其他操作系统完全兼容。微软的 FAT32 文件系统在大多数操作系统中都得到了广泛支持，包括 Mac OS X、所有 Windows 版本(显然)、Linux 等等。这意味着存储在 FAT32 分区上的安卓数据可以在其他文件系统上轻松读取、修改甚至删除。

在 Linux 中，FAT32 分区的文件系统驱动程序被称为 VFAT，不要与微软早期的虚拟 FAT 文件系统混淆，该文件系统通过添加长文件名支持等功能来桥接 FAT16 和 FAT32 的实现。在 HTC 不可思议上，有三个挂载点使用 FAT32:

□t0//mnt/sdcard

/mnt/secure/asec

□t0//mnt/EMM

大家可能还记得[第 3 章](3.html)中关于 USB 接口的部分，当安卓设备连接到另一台电脑时，可以选择暴露设备的 USB 大容量存储(UMS)接口来实现文件共享。在 HTC 不可思议上，/mnt/sd 卡和/mnt/emmc 分区都可以作为 UMS 设备通过 USB 连接呈现给其他操作系统。

/mnt/secure/asec 分区是 SD 卡上的加密分区，安卓设备可以在这里存储应用。当引入从 SD 卡运行应用程序的能力时，安全工程师担心应用程序数据很容易被损坏或泄露，这是可以理解的，因为文件权限没有在 VFAT/FAT32 分区中维护。因此，应用程序(。apk 文件)在物理设备上加密，在使用时，它被解密并临时存储在/mnt/asec 或设计指定的其他位置。

如前所述，可移动 SD 卡安装在/mnt/sd 卡上，通常包含照片、视频、缩略图、下载文件、文本到语音临时文件、谷歌地图导航数据以及来自许多安卓市场应用程序的数据。较新的/mnt/emmc 是一个 FAT32 分区，不可移动，驻留在设备架构的存储中。在目前为止检查的设备中，eMMC 被格式化为 FAT32，同样是为了互操作性。

### YAFFS2

当第一个安卓设备发布时，许多人惊讶地看到一个相对未知的文件系统在系统中发挥了关键作用。“YAFFS”是“又一个闪存文件系统”的首字母缩略词，是一个专为 NAND 闪存开发的开源文件系统，根据 GNU 公共许可证(GPL)和商业许可协议进行许可，适用于那些不希望遵循严格 GPL 指导原则的人( [YAFFS 许可常见问题解答，n.d.](#BIB9) )。安卓设备使用最新版本的 YAFFS (YAFFS2)，该版本遵循更严格的与非门闪存准则，旨在提高与非门闪存的耐用性，同时针对在低内存移动或嵌入式设备上运行进行优化。

YAFFS2 由总部位于新西兰的 Aleph One 有限公司开发。在客户要求的驱动下，Aleph One 于 2001 年 12 月开始 YAFFS 设计，并于 2002 年 5 月发布了第一个公开可用的源代码。主要开发人员(或者肯定是最引人注目的)是查尔斯·曼宁，他被称为“嵌入式看门人”，已经开发和“扫荡”嵌入式系统 20 年了(YAFFS:与非门专用闪存，北卡罗来纳州)。查理斯在 YAFFS 的邮件列表中相当活跃，他是 YAFFS 和雅夫斯 2 的事实专家。

小费

### 其他 YAFFS2 资源

鼓励对 YAFFS2 内部感兴趣的分析师和工程师阅读来自[http://www.yaffs.net/](http://www.yaffs.net/)的完整文档(和源代码，如果你喜欢的话)并注册邮件列表。

YAFFS2 专为不断增长的 NAND 闪存设备而构建，具有许多重要特性，可满足这种介质的严格需求。YAFFS2 是

日志结构的文件系统(即使在意外断电的情况下也能保护数据)

提供内置的损耗均衡和误差校正

能够处理坏块

速度快，内存占用小

然而，由于在安卓之前它的使用受到限制，目前没有支持文件系统的取证工具(商业或开源)。除了下载 YAFFS2 源代码、抓取分区的取证图像、在您最喜欢的 hex 编辑器中打开它并开始挖掘之外，这使得取证分析师几乎没有选择。虽然一些实用程序应该会随着时间的推移而发展，但安卓向 EXT4 的转移可能会降低商业法医公司开发这种支持的动机。

如 NAND 闪存部分所述，YAFFS2 通过 MTD 子系统以块为单位寻址内存，每个块包含一组页面(在 YAFFS 文档和代码中称为块)。当 YAFFS2 准备向 NAND 闪存写入数据时，它会将数据和元数据结构传递给 MTD。然后，MTD 负责将数据和元数据写入(以及读取)NAND 闪存。

对于大多数安卓设备，MTD 子系统以块的形式寻址与非门闪存，这些块被分成 64 个块，每个块包含 2048 字节(因此块是 128K)加上一个 64 字节的带外/备用区(OOB)，其中存储了各种标签和元数据。当一个块被分配用于写入时，它被分配一个从 1 开始的序列号，并随着每个新块递增。

YAFFS2 中存储的所有数据结构都称为对象，可以是文件、目录、符号链接和硬链接。每个块存储 yaffs_ObjectHeader(对象元数据)或对象的数据。yaffs_ObjectHeader 跟踪各种信息，包括对象类型、父对象、名称的校验和以加快搜索速度、对象名称、权限和所有权、媒体访问控制信息以及对象(如果是文件)的大小。

在 64 字节的 OOB/备用区中，YAFFS2 不仅存储关于块的关键信息，还与 MTD 子系统共享该区域。关键的 YAFFS2 标签如下:

1 字节:块状态(如果块是好的，则为 0xFF，坏块的任何其他值)

4 字节:32 位块标识(0 表示块存储 yaffs_ObjectHeader，else 数据)

4 字节:32 位对象标识(类似于传统的 Unix 信息节点)

2 字节:该数据块中的数据块数(除最终数据块外，所有数据块都将被完全分配)

4 字节:该块的序列号

3 字节:标签 ECC(安卓系统，由 MTD 处理)

12 字节:数据 ECC(安卓系统，由 MTD 处理)

如果一个对象被改变，一个新的 yaffs_ObjectHeader 被写入闪存，因为 NAND 内存在擦除之前只能被写入一次。旧的数据和头仍然存在，但是通过检查序列号的值，在文件结构中被忽略。使用此过程符合“与非”闪存中的块永远不能重写(只写一次，然后在不再需要时擦除)的准则。当然，这对数据恢复过程会有巨大的好处，因为修改或删除的数据仍将存在于 NAND 闪存上，除非该数据块经历了用于擦除数据块并准备接受新数据的垃圾收集过程。

类似地，当一个文件在 YAFFS2 中被删除时，对象头的父目录被移动到一个特殊的隐藏目录，称为未链接。文件将保留在此目录中，直到文件中的所有区块都被擦除。为了实现这一点，文件系统跟踪系统中文件的区块数。当它达到 0 时，文件的剩余部分不再存在。此时，它将不再跟踪未链接目录中的对象。

虽然文件系统结构可以完全从 OOB 区域和对象头信息中重新生成，但这并不高效，尤其是随着 NAND 闪存的大小增长。因此，使用树节点结构(T 节点)跟踪所有分配的块，该结构被加载并维护在随机存取存储器中(根据需要写入与非门闪存)。t 节点是固定的 32 字节，在其最低级别(级别 0)存储用于定位第一个块标识的索引。随着文件大小的增长，会添加额外的级别，包括指向其他 T 节点的八个指针。

为了重新生成，YAFFS2 按照块分配顺序读取每个块，从末尾开始并返回，并将文件系统结构填充为内存中的 T 节点。这需要扫描整个 NAND—这是一项耗时的操作。为了解决这个问题，为 YAFFS2 开发了检查点，当正确卸载时，它更喜欢 RAM 结构而不是 NAND 闪存(使用 10 个块)。

需要一些其他的关键概念来完善你对 YAFFS2 的理解。首先，垃圾收集排队，如果需要的话，在每次发生向系统写入时进行。如果块中的所有块都不再使用，则该块是垃圾收集的候选块。该系统还能够获取“最脏”的块，将分配的块复制到新的块，从而使该块可用于垃圾收集。为了使该块再次可用，通过写入所有 1(0xFF)将其擦除。

在安卓设备上，我们可以通过检查/proc/yaffs 文件找到关于 YAFFS2 文件系统的详细信息:

![image](../images/F100044u04-55a-9781597496513.jpg)

![image](../images/F100044u04-55b-9781597496513.jpg)

我们可以看到许多有用的细节，例如，在/data/data 挂载的“data data”yaffs 2 分区上。通过检查这个分区的/proc/yaffs 列表，我们可以了解以下内容:

1.有 1192 个块(0 到 1191)，我们知道每个块有 64 个块(2048 字节)。因此，128K × 1192 = 152，576K，您可以通过运行 df 命令或像上面一样检查/proc/mtd 来确认。

2.显示页面读取、页面写入和块擦除的次数。这将提供 NAND 闪存使用量的大致概念。

3.垃圾收集过程中的一个策略是找到接近空闲的块，将剩余的数据复制出来，然后标记该块可用于收集。我们可以看到这种情况正在高速发生(323，313)。

4.我们可以看到没有检测到 ECC 错误。

5.yaffs 2 元数据报告了超过 643，000 个未链接的文件。

6\. YAFFS2 不使用软件 ECC，而是依赖于 MTD 或 NAND 闪存。

如果您比较不具有/data/data 方向的高读写使用率的系统分区，您会注意到显著的差异。检查/proc/yaffs 文件可能有助于在解释纠错码、碎片数据等时提供必要的背景信息。

深入了解 YAFFS2 的最佳方式是直接创建、修改和检查文件系统。所有这些都可以在为整本书的其他练习创建的 Ubuntu 工作站上实现。由于我们已经安装了一个 Linux 虚拟机和构建必需包(包括必要的 C 编译器和支持包)，我们现在需要安装 mtd-utils 包:

![image](../images/F100044u04-56-9781597496513.jpg)

然后，我们下载最新的 YAFFS2 源代码:

![image](../images/F100044u04-57-9781597496513.jpg)

然后提取 yaffs2.tar.gz 并编译，这样我们就可以使用内核模块:

![image](../images/F100044u04-58-9781597496513.jpg)

接下来，我们将加载所需的内核模块，以在内存中模拟一个 MTD(除非您碰巧有一些可以直接连接的与非门闪存)，然后安装一个 YAFFS2 分区。

首先，我们将在主目录中创建一个装载文件系统的位置:

![image](../images/F100044u04-59-9781597496513.jpg)

接下来，我们需要加载一些内核模块来支持 MTD:

![image](../images/F100044u04-60-9781597496513.jpg)

接下来，我们使用 nandsim 内核模块创建模拟 NAND 闪存:

![image](../images/F100044u04-61-9781597496513.jpg)

小费

### 关于 Linux MTD 的附加信息

Linux MTD 网页提供了更多关于 nandsim 的详细信息。该网站为 MTD 提供了深入的背景信息和支持，因此请访问它了解全部细节。

此处提供了 Linux MTD 网站上有关 nandsim 的更多详细信息，供直接参考( [NAND 常见问题，未注明](#BIB6)):

“NAND 模拟器(nandsim)是一个非常有用的调试和开发工具，它可以模拟 RAM 或文件中的 NAND 闪存。要选择模拟闪存类型，应指定闪存的标识字节-由“读取标识”命令(0x90)返回的字节-参考闪存手册。以下是输入参数的示例:

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x 33—16MIb，512 字节页面

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x 35—32MiB，512 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x 36—64MiB，512 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x 78—128 MIB，512 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x 71—256 MIb，512 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x a2 third _ id _ byte = 0x 00 third _ id _ byte = 0x 15—64MiB，2048 字节页面；

mod probe NAND sim first _ id _ byte = 0xec second _ id _ byte = 0xa 1 third _ id _ byte = 0x 00 third _ id _ byte = 0x 15—128 MIB，2048 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0xa a third _ id _ byte = 0x 00 third _ id _ byte = 0x 15—256 MIB，2048 字节页面；

mod probe NAND sim first _ id _ byte = 0x 20 second _ id _ byte = 0x AC third _ id _ byte = 0x 00 third _ id _ byte = 0x 15—512 MIB，2048 字节页面；

mod probe NAND sim first _ id _ byte = 0xec second _ id _ byte = 0x D3 third _ id _ byte = 0x 51 third _ id _ byte = 0x 95—1GiB，2048 字节页面；"

现在我们有了模拟的 NAND 闪存，我们可以通过检查/proc/mtd 来验证大小和分区信息，就像我们直接在安卓设备上做的那样:

![image](../images/F100044u04-62-9781597496513.jpg)

系统显示，我们有一个 MTD 分区(mtd0)，十六进制擦除大小为 0x20000 字节(128 KB)，十六进制总大小为 0x4000000 (65，536 KB 或 64 MB)。接下来，我们需要将 YAFFS2 内核模块加载到内存中:

![image](../images/F100044u04-63-9781597496513.jpg)

在我们挂载 YAFFS2 文件系统之前，让我们看一下十六进制编辑器中未初始化的模拟 NAND 闪存。如果您尝试使用像 dd 或 xd 这样的工具来查看 NAND 闪存设备，您将看不到 OOB 区域，因为它们没有接触到大多数工具。这是为了防止混合的 64 位元数据混淆文件中没有 OOB 的程序(想象一下，在每个 2k 块后显示一个有 64 字节二进制 OOB 数据的 PDF)。要读取包括 OOB 在内的完整 NAND 闪存，我们使用程序 nanddump，它是先前安装的 mtd-utils 包的一部分。这将读取数据并以二进制形式返回。有几个选项可以考虑，很容易查看:

![image](../images/F100044u04-64-9781597496513.jpg)

出于我们的目的，我们希望使用 nanddump 来提取带有 OOB 的完整 NAND，并将输出传输到十六进制编辑器(xxd)进行查看:

![image](../images/F100044u04-65-9781597496513.jpg)

请注意，模拟的与非门闪存包含空白或擦除的与非门闪存应该具有的预期 0xFF 值。当我们初始化并随后修改文件系统时，上面的命令将允许您检查原始 NAND 闪存是如何修改的。

最后，我们准备装载一个 YAFFS2 文件系统:

![image](../images/F100044u04-66-9781597496513.jpg)

您可以验证文件系统是否已装载并且可以访问:

![image](../images/F100044u04-67-9781597496513.jpg)

因此，我们可以看到 YAFFS2 文件系统以读/写权限装载在~/mnt/yaffs2。即使我们没有创建任何文件，该目录包含一个丢失+找到的虚拟目录，其中存储了父目录无法确定的文件和目录。如果您再次使用 xxd 十六进制编辑器来检查模拟的 NAND 闪存设备，它仍将包含 0xFF。但是，如果使用以下命令编写单个文件:

![image](../images/F100044u04-68-9781597496513.jpg)

并将内容“安卓取证和移动安全”放在文件中，然后当我们检查原始 NAND 闪存时，我们可以清楚地看到 YAFFS2 结构，包括对象头、对象和文件内容。下面是使用 nanddump 的十六进制内容的一部分，以及通过添加-a 选项而稍加修改的 xd 命令，该选项将跳过 0x00 行:

![image](../images/F100044u04-69-9781597496513.jpg)

从偏移量 0x0000000 开始，我们可以看到空白的 ObjectHeader，在这里我们可以很容易地看到 ASCII (book.txt)格式的文件名。从 0x0000800 到 0x000083F 开始，我们可以看到由 YAFFS2 存储的 OOB 数据，然后作为打包的二进制数据存储在 MTD 中，必须进行决定。文件的实际内容在 0x0000840 写入 NAND 闪存。我们看到从 0x0001040 到 0x000107F 的另一个 OOB，然后对象标头在 0x0001080 再次写入 NAND 闪存，因为原始对象标头代表空白文件。一旦我们添加了内容并保存了文件，数据就会被写入 NAND 闪存，并且一个*新的 ObjectHeader 会被写入*NAND 闪存。新的对象头反映了关于对象的新元数据，包括哪些块保存数据、媒体访问控制(已修改、已访问、已更改)数据等。

需要理解的一个关键点是，YAFFS2 不能简单地用这个信息更新第一个对象头，因为它首先必须擦除整个块。因此，它会编写一个新的对象头，为该头生成一个较高的序列号，使其成为文件的最新对象头。可以想象，旧的 ObjectHeader 和数据会保留在 NAND 闪存上，除非它们经过垃圾收集，从而为使用取证技术恢复文件元数据和内容提供了很好的机会。

#### YAFFS 的例子

在关于 YAFFS2 的最后一节中，给出了一个虚构的场景来说明对象头和对象是如何写入 NAND 闪存的。查尔斯·曼宁在他的《亚夫斯是如何工作的》中提出了这个例子。任何对 YAFFS 内部感兴趣的人都被鼓励打印、阅读或重读本文档。在该示例中，我们使用了一个 NAND 闪存，为简单起见，每个块有四个区块，并且已被擦除(0xFF)。在描述了每个变化之后，表格将显示 NAND 闪存的内容。

首先，我们在 NAND 闪存上创建一个空文件，如[表 4.6](#T0035) 所示。

表 4.6 创建的空白文件

![Image](../images/T100044tabT0035.jpg)

对象头指向一个空文件。接下来，我们向文件中写入三大块数据，如[表 4.7](#T0040) 所示。

表 4.7 写入三个数据块

![Image](../images/T100044tabT0040.jpg)

到目前为止，这似乎很简单。对象现在占据了整个第一个块。

注意

### 虚拟 NAND 闪存

请记住，我们虚构的 NAND 闪存每个块有四个卡盘，而不是我们在商业 NAND 闪存中看到的典型的 64 个块。

接下来，我们将保存文件，该文件将导致一个新的 ObjectHeader 被写入 NAND 闪存，如[表 4.8](#T0045) 所示。

表 4.8 保存文件的新对象标题

![Image](../images/T100044tabT0045.jpg)

这里需要理解的关键点是，YAFFS2 无法返回并用新的大小、数据块和其他内容更新原始的 ObjectHeader。相反，它必须编写一个新的 ObjectHeader，其中包含更新文件所需的元数据。在 YAFFS2 中，新的对象头被赋予一个更大的序列号，因此它成为当前的对象头，YAFFS2 简单地忽略前一个对象头(但是，它仍然保留在磁盘上)。

接下来，文件将以读/写访问打开，第一个数据块将被赋予一个新值。最后，文件被保存并关闭，导致额外的数据被写入 NAND 闪存，如[表 4.9](#T0050) 所示。

表 4.9 保存新数据和对象标题

![Image](../images/T100044tabT0050.jpg)

同样，由于我们不能简单地更改文件中最初的第一个数据块，因此会将新的数据块写入 NAND 闪存，并且之前的数据块会过时。这是通过将另一个新的对象头写入 NAND 闪存来实现的，该对象头指向文件的新的第一个数据块。接下来，我们将文件截断为零长度文件，结果 NAND 闪存更改如[表 4.10](#T0055) 所示。

表 4.10 截断文件并写入新对象标题

![Image](../images/T100044tabT0055.jpg)

由于文件被截断，数据块 0 中的所有数据块都不再使用。这使得块可用于垃圾收集，垃圾收集将在下一个写周期进行。这被称为惰性垃圾收集，因为它使用现有的写周期来执行任何必要的垃圾收集。和以前一样，一个新的对象头被写入与非门闪存，以解决被截断的文件。

最后，我们重命名文件，NAND 闪存结果如[表 4.11](#T0060) 所示。

表 4.11 重命名文件和写入新对象标题

![Image](../images/T100044tabT0060.jpg)

在此周期中，块 0 被垃圾收集，现在可用于写入数据。当文件被重命名时，一个新的对象头被写入 NAND 闪存。由于块 1 中的所有区块现在都已过时，它们可用于垃圾收集。但是，请记住，由于 NAND 闪存的耐用性有限，因此避免了写入/擦除周期。

对取证的影响是，除非垃圾收集，否则对象头和对象数据块的整个历史都将保留在 NAND 闪存上。通过适当的软件，可以扫描 NAND 闪存，并且基本上可以重建文件系统的整个历史。时间线不仅包含每次编辑的日期/时间，还可以恢复文件的实际状态。实际上，YAFFS2 分区的状态并没有这么简单。然而，一般原则仍然适用。

## 装载的文件系统

我们已经详细介绍了安卓内存系统的许多组件。我们不仅研究了内存和 NAND 闪存，还详细研究了许多文件系统。这些背景信息将有助于您对安卓设备的取证和安全分析。为了更好地理解这些学术信息，我们现在将探索在安卓设备上发现的挂载文件系统。

### 装载的文件系统

让我们从宏达不可思议上安装的文件系统开始:

![image](../images/F100044u04-70-9781597496513.jpg)

运行不带参数的装载命令时，它会返回已装载文件系统及其选项的列表。[表 4.12](#T0065) 是使用几个条目的输出描述。但是，请注意，上面的每个条目都以“0 0”结尾，出于空间原因，表中省略了“0 0”。“0 0”条目确定文件系统是否由 dump 命令存档，以及决定文件系统检查器(fsck)在引导时检查设备/分区错误的顺序的传递号。在大多数桌面或服务器 Linux 系统上，根文件系统的通过号为 1，因此它会在其他文件系统之前被检查。

表 4.12 装载命令概述的输出

![Image](../images/T100044tabT0065.jpg)

/mnt/sd 卡有许多选项。选项包括:

1\. rw:已安装，允许读/写

2\. dirsync:对目录的所有更新都是同步完成的

3.no uid:不允许 setuid(这将允许其他用户使用文件所有者的权限执行程序)

4\. nodev:不将任何文件解释为特殊的块设备

5\. noexec:不允许从文件系统执行所有文件

6.relative time:如果文件访问时间早于修改时间，则更新文件访问时间

7\. uid=1000:将所有文件的所有者设置为 1000

8\. gid=1015:将所有文件的组设置为 1015

9\. fmask=0702:设置仅应用于常规文件的 umask(设置权限- rwxr-x，或用户=无，组=读/写/执行，其他=读/执行)

10\. dmask=0702:设置仅应用于目录的 umask(设置权限- rwxr-x，或用户=无，组=读/写/执行，其他=读/执行)

11\. allow_utime=0020:控制 mtime/atime 的权限检查。

12\. codepage=cp437:设置在 FAT 和 VFAT 文件系统上转换为简称字符的代码页。

13\. iocharset=iso8859-1:用于在 8 位字符和 16 位 Unicode 字符之间进行转换的字符集。默认值为 iso8859-1。长文件名以 Unicode 格式存储在磁盘上。

14\. shortname=mixed:定义创建和显示符合 8.3 个字符的文件名的行为。如果文件存在长名称，它将始终是首选显示。Mixed 按原样显示短名称，当短名称不全是大写时存储长名称。

15\. utf8:将 CD 上的 16 位 Unicode 字符转换为 UTF-8。

16\. errors=remount-ro:定义遇到错误时的行为；在这种情况下，以只读方式重新装载文件系统。

所有挂载命令选项都在手册页(手册 8 挂载)中进行了解释。但是，在大多数情况下，快速扫描会显示审查员需要的信息，包括挂载点、类型和文件系统的权限。

df 命令将提供有关已装载文件系统上可用空间的信息:

![image](../images/F100044u04-71-9781597496513.jpg)

如您所见，当 shell 用户试图确定有多少可用磁盘空间时，其中一个挂载点(/mnt/secure/asec)返回了一个被拒绝的权限。通过查看父目录，我们可以看到只有 root 可以访问该目录:

![image](../images/F100044u04-72-9781597496513.jpg)

有趣的是，其中两个文件系统/目录可以通过通用串行总线大容量存储(UMS)选项公开，当这种情况发生时，目录的权限会发生变化。如果未启用 UMS 选项，安卓设备可以完全访问文件系统，如您在/mnt/emmc 和/mnt/sd 卡中所见。

但是，当 UMS 处于活动状态并且两个文件系统可用于连接的工作站时，权限会发生变化:

![image](../images/F100044u04-73-9781597496513.jpg)

如您所见，/mnt/emmc 和/mnt/sdcard 上的所有权限都被删除，因此安卓设备无法直接从手机访问/mnt/emmc 或/mnt/sdcard(即与连接的工作站独占共享)。

## 摘要

安卓设备上的物理内存、文件系统和数据结构是数据存储的基本构件。对这些结构有深刻的理解不仅能让你理解一个安卓设备，还能在面对新的文件系统和数据结构时进行自己的研发。

## 参考

1.*安卓开发者博客:安全保存数据*。(未注明日期)。2011 年 2 月 2 日检索自[http://Android-developers . blogspot . com/2010/12/saving-data-safe . html](http://android-developers.blogspot.com/2010/12/saving-data-safely.html)。

2.*安卓逆向工程*。(未注明日期)。[thomascannon.net](http://thomascannon.net)。检索时间 2011 年 1 月 29 日，[http://thomascannon.net/projects/android-reversing/](http://thomascannon.net/projects/android-reversing/)。

3.*数据存储*。(未注明日期)。安卓开发者。检索于 2011 年 3 月 13 日，[http://developer . Android . com/guide/topics/data/data-storage . html # netw](http://developer.android.com/guide/topics/data/data-storage.html%23netw)。

4.*YAFFS 如何运作:内部*。(未注明日期)。YAFFS。检索时间 2011 年 2 月 4 日，[http://www.yaffs.net/how-yaffs-works-internals](http://www.yaffs.net/how-yaffs-works-internals)。

5.Nand Faq。(未注明日期)。*Linux*内存技术设备(MTD)子系统，2011 年 3 月 13 日检索自[http://www.linux-mtd.infradead.org/faq/nand.html](http://www.linux-mtd.infradead.org/faq/nand.html)。

6.*sysfs 文件系统*。(未注明出处)，2011 年 2 月 1 日检索自[。](http://www.kernel.org/pub/linux/kernel/people/mochel/doc/papers/ols-2005/mochel.pdf)

7.韦，t(n . d .)。*安卓将从姜饼开始使用 ext4。泰德的想法。欢迎来到*[<ce:italic>thunk.org</ce:italic>](http://thunk.org)，检索时间:2011 年 2 月 2 日，来自[http://thunk . org/tytso/blog/2010/12/12/Android-即将使用-ext4-以姜饼开始/](http://thunk.org/tytso/blog/2010/12/12/android-will-be-using-ext4-starting-with-gingerbread/) 。

8.许可证常见问题，纽约联邦航空局。YAFFS，摄于 2011 年 2 月 4 日[http://www.yaffs.net/yaffs-licence-faqs](http://www.yaffs.net/yaffs-licence-faqs)。

9.*YAFFS:NAND 专用闪存文件系统—介绍性文章*。(未注明日期)。检索于 2011 年 2 月 2 日，来自[http://www . yaffs . net/yaffs-NAND-specific-flash-file-system-introductor yarticle](http://www.yaffs.net/yaffs-nand-specific-flash-file-system-introductoryarticle)。