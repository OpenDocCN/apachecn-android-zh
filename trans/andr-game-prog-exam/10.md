# 第十章。用 OpenGL ES 2 移动和绘制

在本章中，我们将实现所有的图形、游戏和动作。在短短的 30 多页中，我们将完成除碰撞检测之外的所有工作。我们能够取得如此大的成就，是因为我们在上一章打下了基础。

首先，我们将在我们的游戏世界周围画一个静态边界，然后是一些闪烁的星星，接着是给我们的飞船增加运动和一些子弹。之后，我们将迅速为玩家添加控件，我们将在屏幕上呼啸而过。

我们也将通过用一些新的声音 FX 实现我们的`SoundManager`类来制造一些噪音。

一旦完成，我们将添加随机形状的小行星，它们在旋转的同时在世界各地移动。

然后，我们可以添加一个 HUD 来突出屏幕的可触摸区域，并提供下一级之前需要摧毁的剩余玩家生命和小行星的计数。

# 绘制静态游戏边框

在这个简单的类中，我们定义了代表四条线的四组点。不出所料，`GameObject`类将使用这些点作为线的端点来绘制边界。

在构造器中，它是类的整体，我们通过调用`setType()`来设置类型，世界位置作为地图的中心，`height`和`width`作为整个地图的高度和宽度。

然后，我们定义一个浮点数组中的四行并调用`setVertices()`来准备一个`FloatBuffer`。

创建一个名为`Border`的新类，并添加以下代码:

```
public class Border extends GameObject{

  public Border(float mapWidth, float mapHeight){

        setType(Type.BORDER);
        //border center is the exact center of map
        setWorldLocation(mapWidth/2,mapHeight/2);

        float w = mapWidth;
        float h = mapHeight;
        setSize(w, h);

       // The vertices of the border represent four lines
       // that create a border of a size passed into the constructor
       float[] borderVertices = new float[]{
           // A line from point 1 to point 2
            - w/2, -h/2, 0,
            w/2, -h/2, 0,
            // Point 2 to point 3
            w/2, -h/2, 0,
            w/2, h/2, 0,
            // Point 3 to point 4
            w/2, h/2, 0,
            -w/2, h/2, 0,
            // Point 4 to point 1
            -w/2, h/2, 0,
            - w/2, -h/2, 0,
    };

        setVertices(borderVertices);

  }

}
```

然后我们可以这样声明一个`Border`对象为`GameManager`的成员:

```
// Our game objects
SpaceShip ship;
Border border;

```

用`AsteroidsRenderer`的`createObjects`方法初始化，如下所示:

```
// Create our game objects

// First the ship in the center of the map
gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);

// The deadly border
gm.border = new Border(gm.mapWidth, gm.mapHeight);

```

现在，我们可以通过在`AsteroidsRendrer`类的`draw`方法中添加一行代码来绘制我们的边框:

```
gm.ship.draw(viewportMatrix);
gm.border.draw(viewportMatrix);

```

你现在可以运行游戏了。如果你想真正看到边界，你可以把我们初始化飞船的位置改变到靠近边界的某个地方。请记住，在`draw`方法中，我们将视口以船为中心。要查看边框，请将`SpaceShip`类中的这一行改为:

```
setWorldLocation(10,10);
```

运行游戏看一看。

![Drawing a static game border](graphics/B043422_10_01.jpg)

改回如下:

```
setWorldLocation(worldLocationX,worldLocationY);
```

现在，我们将用星星填满边界内的区域。

# 闪烁的星星

我们将变得比静态的边界更加机动。这里我们给一个简单的`Star`类增加一个`update`方法，可以用来随机切换星的开和关。

我们将类型设置为`normal`，并在边界范围内为恒星创建一个随机位置，并像往常一样调用`setWorldLocation()`。

恒星将被绘制为点，因此我们的顶点数组将只包含模型空间 0，0，0 处的一个顶点。然后，我们照常调用`setVertices()`。

新建一个类，称之为`Star`，输入讨论过的代码:

```
public class Star extends GameObject{

    // Declare a random object here because
    // we will use it in the update() method
    // and we don't want GC to have to keep clearing it up
    Random r;

    public Star(int mapWidth, int mapHeight){
    setType(Type.STAR);
    r = new Random();
    setWorldLocation(r.nextInt(mapWidth),r.nextInt(mapHeight));

    // Define the star
    // as a single point
    // in exactly the coordinates as its world location
    float[] starVertices = new float[]{

                0,
                0,
                0

    };

    setVertices(starVertices);

    }
```

这是我们`Star`班的`update`法。正如我们所看到的，在每一帧中，恒星转换状态的几率为 1000 分之一。如果需要更多的闪烁，请使用较低的种子，如果需要较少的闪烁，请使用较高的种子。

```
public void update(){

  // Randomly twinkle the stars
     int n = r.nextInt(1000);
     if(n == 0){
       // Switch on or off
       if(isActive()){
         setActive(false);
        }else{
          setActive(true);
        }
   }

}
```

然后我们声明一个`Star`数组，作为`GameManager`的成员，以及一个额外的`int`变量来控制我们想要画多少颗星，如下所示:

```
// Our game objects
SpaceShip ship;
Border border;
Star[] stars;
int numStars = 200;

```

用`AsteroidsRenderer`的`createObjects`方法初始化`Star`对象的数组，如下所示:

```
// The deadly border
gm.border = new Border(gm.mapWidth, gm.mapHeight);

// Some stars
gm.stars = new Star[gm.numStars];
for (int i = 0; i < gm.numStars; i++) {

 // Pass in the map size so the stars no where to spawn
 gm.stars[i] = new Star(gm.mapWidth, gm.mapHeight);
}

```

现在，我们可以通过将这些代码行添加到`AsteroidsRenderer`类的`draw`方法中来绘制我们的星星。注意，我们先画星星，因为它们在背景中。

```
// Start drawing!

// Some stars
for (int i = 0; i < gm.numStars; i++) {

 // Draw the star if it is active
 if(gm.stars[i].isActive()) {
 gm.stars[i].draw(viewportMatrix);
 }
}

gm.ship.draw(viewportMatrix);
gm.border.draw(viewportMatrix);
```

当然，为了让他们眨眼，我们把他们的`update`方法从`AsteroidsRenderer`类的`update`方法中这样称呼:

```
private void update(long fps) {

 // Update (twinkle) the stars
 for (int i = 0; i < gm.numStars; i++) {
 gm.stars[i].update();
 }

}
```

您现在可以运行游戏:

![Twinkling stars](graphics/B043422_10_02.jpg)

# 使宇宙飞船复活

首先，我们需要给我们的`GameObject`类增加一点更多的功能。我们这样做是因为子弹和小行星与宇宙飞船有惊人的相似之处。

我们需要一堆吸气剂和设置剂来获取和设置旋转速率、行进角度和朝向角度。将以下方法添加到`GameObject`类中:

```
public void setRotationRate(float rotationRate) {
  this.rotationRate = rotationRate;
}

public float getTravellingAngle() {
  return travellingAngle;
}

public void setTravellingAngle(float travellingAngle) {
  this.travellingAngle = travellingAngle;
}

public float getFacingAngle() {
  return facingAngle;
}

public void setFacingAngle(float facingAngle) {
  this.facingAngle = facingAngle;
}
```

现在，我们添加一个`move`方法，它基于每秒的当前帧调整对象的 *x* 和 *y* 坐标以及`facingAngle`。添加`move`方法:

```
void move(float fps){
  if(xVelocity != 0) {
       worldLocation.x += xVelocity / fps;
    }

     if(yVelocity != 0) {
       worldLocation.y += yVelocity / fps;
    }

     // Rotate
     if(rotationRate != 0) {
       facingAngle = facingAngle + rotationRate / fps;
    }

}
```

为了完成我们对`GameObject`类的添加，添加这些速度、速度和最大速度的获取器和设置器:

```
public float getxVelocity() {
  return xVelocity;
}

public void setxVelocity(float xVelocity) {
  this.xVelocity = xVelocity;
}

public float getyVelocity() {
  return yVelocity;
}

public void setyVelocity(float yVelocity) {
  this.yVelocity = yVelocity;
}

public float getSpeed() {
  return speed;
}

public void setSpeed(float speed) {
  this.speed = speed;
}

public float getMaxSpeed() {
  return maxSpeed;
}

public void setMaxSpeed(float maxSpeed) {
  this.maxSpeed = maxSpeed;
}
```

我们可以给这门课增加一些 T2 的内容。将这三个成员添加到`SpaceShip`类中，以控制玩家的船是转向还是前进:

```
boolean isThrusting;
private boolean isPressingRight = false;
private boolean isPressingLeft = false;
```

现在，在`SpaceShip`构造器内部，让我们设置船的最大速度。我强调了现有代码中的新代码行:

```
setSize(width, length);

setMaxSpeed(150);

// It will be useful to have a copy of the
```

接下来在`SpaceShip`类中，我们增加了一个`update`方法，首先根据`isThrusting`的真假来增减速度。

```
public void update(long fps){

float speed = getSpeed();
if(isThrusting) {
  if (speed < getMaxSpeed()){
       setSpeed(speed + 5);
     }

     }else{
       if(speed > 0) {
         setSpeed(speed - 3);
        }else {
         setSpeed(0);
        }
}
```

然后，我们根据角度、船面对的方向和速度设置*x*和*y*T5】速度。

### 注

我们用速度乘以船面对的角度的余弦来设定 *x* 轴上的速度。这是可行的，因为余弦函数是一个完美的变体，当船分别正对着左边或右边时，它将返回-1 或 1 的值；当船完全指向上或下时，变量返回精确的值 0。它还返回介于两者之间的精确值。角度的正弦在 *y* 轴上的工作方式完全相同。看起来有点复杂的代码是因为我们需要将我们的角度转换为弧度，并且我们必须向我们的`facingAngle`添加 90 度，因为 0 度指向三点。这个事实不利于按照我们的方式在 *x* 、 *y* 飞机上使用，所以我们对其进行了 90 度的修改，飞船按照预期移动。有关如何工作的更多信息，请查看本教程:

[http://gamecode school . com/essentials/computing-2d 游戏中的航向-使用三角函数-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)

```
setxVelocity((float) 
  (speed* Math.cos(Math.toRadians(getFacingAngle() + 90))));

setyVelocity((float) 
  (speed* Math.sin(Math.toRadians(getFacingAngle() + 90))));

```

现在，我们根据玩家是左转还是右转来设置旋转速率。最后，我们调用`move()`将所有更新生效。

```
if(isPressingLeft){
  setRotationRate(360);
}

else if(isPressingRight){
  setRotationRate(-360);
     }else{
       setRotationRate(0);
    }

     move(fps);
}
```

现在，我们需要添加一个`pullTrigger`方法，这个现在，我们只需要返回`true`。我们还为我们的未来`InputController`提供了三种方法来调用和触发`update`方法进行各种更改。

```
public boolean pullTrigger() {
  //Try and fire a shot
  // We could control rate of fire from here
  // But lets just return true for unrestricted rapid fire
  // You could remove this method and any code which calls it

   return true;
}

public void setPressingRight(boolean pressingRight) {
  isPressingRight = pressingRight;
}

public void setPressingLeft(boolean pressingLeft) {
  isPressingLeft = pressingLeft;
}

public void toggleThrust() {
  isThrusting = ! isThrusting;
}
```

我们已经在每一帧中绘制了船，但是我们需要在`AsteroidsRenderer`类的`update`方法中添加一行代码。添加这行代码来调用`SpaceShip`类的`update`方法:

```
// Update (twinkle) the stars
for (int i = 0; i < gm.numStars; i++) {
  gm.stars[i].update();
}

// Run the ship,s update() method
gm.ship.update(fps);

```

显然，在添加玩家控制之前，我们实际上不能移动。让我们快速给游戏添加一些子弹。然后，我们将添加声音和控制，这样我们就可以看到和听到我们添加的酷的新功能。

# 速射子弹

从 70 年代的 Pong 开始，我就对游戏上瘾了，还记得我的一个朋友在他家实际上有一台太空入侵者机器大约一个星期时的快乐。虽然真正让小行星比太空入侵者强得多的是你能多快地射击。在这个传统中，我们会制造出令人满意的快速子弹流。

创建一个名为`Bullet`的新类，它有一个顶点，将用一个点来绘制。请注意，我们还声明并初始化了一个`inFlight`布尔值。

```
public class Bullet extends GameObject {

  private boolean inFlight = false;

  public Bullet(float shipX, float shipY) {
       super();

       setType(Type.BULLET);

       setWorldLocation(shipX, shipY);

       // Define the bullet
       // as a single point
       // in exactly the coordinates as its world location
       float[] bulletVertices = new float[]{

                0,
                0,
                0

       };

    setVertices(bulletVertices);

}
```

接下来，我们有`shoot`方法，将子弹的`facingAngle`设置为飞船的。这将导致子弹向按下开火按钮时船所面对的方向移动。我们还将`inFlight`设置为真，看看这在`update`方法中是如何使用的。最后，我们将速度设置为`300`。

我们还增加了`resetBullet`方法，将子弹设置在船内，取消其速度和速度。这给了我们一个关于如何实现子弹的线索。子弹在发射前会隐藏在船内。

```
public void shoot(float shipFacingAngle){

     setFacingAngle(shipFacingAngle);
     inFlight = true;
     setSpeed (300);
}

public void resetBullet(PointF shipLocation){

     // Stop moving if bullet out of bounds
     inFlight = false;
     setxVelocity(0);
     setyVelocity(0);
     setSpeed(0);
     setWorldLocation(shipLocation.x, shipLocation.y);

}

public boolean isInFlight(){
  return  inFlight;
}
```

现在，我们根据子弹的`facingAngle`和速度移动子弹，前提是`inFlight`为真。否则，我们把子弹留在船里。然后，我们称之为`move()`。

```
public void update(long fps, PointF shipLocation){
        // Set the velocity if bullet in flight
        if(inFlight){
            setxVelocity((float)(getSpeed()* 
               Math.cos(Math.toRadians(getFacingAngle() + 90))));
            setyVelocity((float)(getSpeed()* 
               Math.sin(Math.toRadians(getFacingAngle() + 90))));
        }else{
            // Have it sit inside the ship
            setWorldLocation(shipLocation.x, shipLocation.y);
        }

        move(fps);
    }
}
```

现在，我们有一个`Bullet`类，我们可以声明一个数组，来保存我们的`GameManager`类中的一堆这种类型的对象。

```
int numStars = 200;
Bullet [] bullets;
int numBullets = 20;

```

在`createObjects()`中初始化它们，就在我们从`AsteroidsRenderer`的最后一节开始的星星之后。注意我们如何将他们在游戏世界中的位置初始化为飞船的中心。

```
// Some bullets
gm.bullets = new Bullet[gm.numBullets];
for (int i = 0; i < gm.numBullets; i++) {
  gm.bullets[i] = new Bullet(
     gm.ship.getWorldLocation().x,
     gm.ship.getWorldLocation().y);
}
```

在`update`方法中更新它们，就在我们闪烁的星星之后。

```
// Update all the bullets
for (int i = 0; i < gm.numBullets; i++) {

    // If not in flight they will need the ships location
    gm.bullets[i].update(fps, gm.ship.getWorldLocation());

}
```

在`draw`方法中，在星星之后再画一次。

```
for (int i = 0; i < gm.numBullets; i++) {
  gm.bullets[i].draw(viewportMatrix);
}
```

子弹已经准备好发射了！

我们将增加一个`SoundManager`和`InputController`级，然后我们可以看到我们的飞船和它的快速开火炮在行动。

# 重用现有类

让我们快速地将我们的`SoundManager`和`InputController`类添加到这个项目中，因为它们也只需要一点点调整来适应我们的需求。

在`AsteroidsView`和`AsteroidsRenderer`类中为`SoundManager`和`InputController`对象添加成员。

```
private InputController ic;
private SoundManager sm;
```

初始化`AsteroidsView`类的`onCreate`方法中的新对象，并像这样调用`loadSound`方法:

```
public AsteroidsView(Context context, int screenX, int screenY) {
  super(context);

 sm = new SoundManager();
 sm.loadSound(context);
 ic = new InputController(screenX, screenY);
     gm = new GameManager(screenX, screenY);
```

同样在`AsteroidsView`中，在对`AsteroidsRenderer`构造函数的调用中添加额外的两个参数，以传递对`SoundManager`和`InputController`对象的引用。

```
setEGLContextClientVersion(2);
setRenderer(new AsteroidsRenderer(gm,sm,ic));

```

现在在`AsteroidsRenderer`构造函数中添加两个额外的参数，并初始化两个新成员，如下所示:

```
public AsteroidsRenderer(GameManager gameManager,
 SoundManager soundManager, InputController inputController) {

        gm = gameManager;
 sm = soundManager;
 ic = inputController;

       handyPointF = new PointF();
       handyPointF2 = new PointF();

}
```

在我们添加这两个类之前，您的 IDE 中会有错误。我们现在就去做。

## 添加声音管理器类

`SoundManager`类的工作方式与之前的项目完全相同，所以这里没有什么新的解释。

将下载包`Chapter10/assets`文件夹中的所有声音文件添加到项目的资产文件夹中。与最后两个项目一样，您可能需要在项目的`.../app/src/main`文件夹中创建资产文件夹。

### 类型

像往常一样，您可以使用提供的音效或创建自己的音效。

现在，给项目添加一个名为`SoundManager`的新类。请注意，该类的功能与上一个项目相同，但代码不同，只是因为声音文件的名称及其相关变量。将此代码添加到`SoundManager`类:

```
public class SoundManager {
    private SoundPool soundPool;
    private int shoot = -1;
    private int thrust = -1;
    private int explode = -1;
    private int shipexplode = -1;
    private int ricochet = -1;
    private int blip = -1;
    private int nextlevel = -1;
    private int gameover = -1;

    public void loadSound(Context context){
        soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);
        try{
            //Create objects of the 2 required classes
            AssetManager assetManager = context.getAssets();
            AssetFileDescriptor descriptor;

            //create our fx
            descriptor = assetManager.openFd("shoot.ogg");
            shoot = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("thrust.ogg");
            thrust = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("explode.ogg");
            explode = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("shipexplode.ogg");
            shipexplode = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("ricochet.ogg");
            ricochet = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("blip.ogg");
            blip = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("nextlevel.ogg");
            nextlevel = soundPool.load(descriptor, 0);

            descriptor = assetManager.openFd("gameover.ogg");
            gameover = soundPool.load(descriptor, 0);

        }catch(IOException e){
            //Print an error message to the console
            Log.e("error", "failed to load sound files");
        }
    }

    public void playSound(String sound){
        switch (sound){
            case "shoot":
                soundPool.play(shoot, 1, 1, 0, 0, 1);
                break;

            case "thrust":
                soundPool.play(thrust, 1, 1, 0, 0, 1);
                break;

            case "explode":
                soundPool.play(explode, 1, 1, 0, 0, 1);
                break;

            case "shipexplode":
                soundPool.play(shipexplode, 1, 1, 0, 0, 1);
                break;

            case "ricochet":
                soundPool.play(ricochet, 1, 1, 0, 0, 1);
                break;

            case "blip":
                soundPool.play(blip, 1, 1, 0, 0, 1);
                break;

            case "nextlevel":
                soundPool.play(nextlevel, 1, 1, 0, 0, 1);
                break;

            case "gameover":
                soundPool.play(gameover, 1, 1, 0, 0, 1);
                break;

        }

    }
}
```

我们现在准备好了从我们有参考的任何地方调用`playSound()`我们的新类。

## 添加输入控制器类

这与上一个项目中的工作方式相同，只是我们称为合适的`PlayerShip`方法，而不是鲍勃的方法。此外，我们不会在暂停时移动视口，因此没有必要在游戏暂停时以不同的方式处理屏幕触摸；让这个`InputController`简单一点，短一点。

将`onTouchEvent`方法添加到`AsteroidsView`类，将处理触摸的责任传递给`InputController`:

```
@Override
    public boolean onTouchEvent(MotionEvent motionEvent) {
        ic.handleInput(motionEvent, gm, sm);
        return true;
    }
```

添加一个名为`InputController`的新类，并添加以下代码，该代码很简单，除了我们处理玩家开枪的方式。

我们声明一个成员`int currentBullet`，它记录下一个我们将要发射的子弹。然后，我们可以在按下发射按钮时计算子弹数，并在阵列中的最后一颗子弹发射后返回到第一颗子弹。

创建一个名为`InputController`的新类，并输入以下代码:

```
public class InputController {

    private int currentBullet;

    Rect left;
    Rect right;
    Rect thrust;
    Rect shoot;
    Rect pause;

    InputController(int screenWidth, int screenHeight) {

        //Configure the player buttons
        int buttonWidth = screenWidth / 8;
        int buttonHeight = screenHeight / 7;
        int buttonPadding = screenWidth / 80;

        left = new Rect(buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth,
            screenHeight - buttonPadding);

        right = new Rect(buttonWidth + buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            buttonWidth + buttonPadding + buttonWidth,
            screenHeight - buttonPadding);

        thrust = new Rect(screenWidth - buttonWidth - 
            buttonPadding,
            screenHeight - buttonHeight - buttonPadding - 
            buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding - buttonHeight - 
            buttonPadding);

        shoot = new Rect(screenWidth - buttonWidth - 
            buttonPadding,
            screenHeight - buttonHeight - buttonPadding,
            screenWidth - buttonPadding,
            screenHeight - buttonPadding);

        pause = new Rect(screenWidth - buttonPadding - 
            buttonWidth,
            buttonPadding,
            screenWidth - buttonPadding,
            buttonPadding + buttonHeight);
```

让我们将所有按钮捆绑在一个列表中，并通过公共方法使它们可用。

```
    }    
    public ArrayList getButtons(){

        //create an array of buttons for the draw method
        ArrayList<Rect> currentButtonList = new ArrayList<>();
        currentButtonList.add(left);
        currentButtonList.add(right);
        currentButtonList.add(thrust);
        currentButtonList.add(shoot);
        currentButtonList.add(pause);
        return  currentButtonList;
    }
```

接下来，我们像以前一样处理输入，除了我们调用我们的`Ship`类的方法。

```
public void handleInput(MotionEvent motionEvent,GameManager l,                                      
  SoundManager sound){

        int pointerCount = motionEvent.getPointerCount();

        for (int i = 0; i < pointerCount; i++) {
        int x = (int) motionEvent.getX(i);
        int y = (int) motionEvent.getY(i);

          switch (motionEvent.getAction() & 
             MotionEvent.ACTION_MASK) {

            case MotionEvent.ACTION_DOWN:
                    if (right.contains(x, y)) {
                    l.ship.setPressingRight(true);
                    l.ship.setPressingLeft(false);
                 } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(true);
                    l.ship.setPressingRight(false);
                    } else if (thrust.contains(x, y)) {
                    l.ship.toggleThrust();
                    } else if (shoot.contains(x, y)) {
                        if (l.ship.pullTrigger()) {
                        l.bullets[currentBullet].shoot
                                (l.ship.getFacingAngle());

                            currentBullet++;
                       // If we are on the last bullet restart
                       // from the first one again
                       if(currentBullet == l.numBullets){
                            currentBullet = 0;
                        }

                           sound.playSound("shoot");
                    }

                    } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                    }
                    break;

            case MotionEvent.ACTION_UP:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(false);
                }

                break;

            case MotionEvent.ACTION_POINTER_DOWN:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(true);
                    l.ship.setPressingLeft(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(true);
                 l.ship.setPressingRight(false);
                } else if (thrust.contains(x, y)) {
                    l.ship.toggleThrust();
                } else if (shoot.contains(x, y)) {
                    if (l.ship.pullTrigger()) {
                    l.bullets[currentBullet].shoot
                            (l.ship.getFacingAngle());

                        currentBullet++;
                    // If we are on the last bullet restart
                    // from the first one again
                    if(currentBullet == l.numBullets){
                        currentBullet = 0;
                    }
                    sound.playSound("shoot");
                    }
                } else if (pause.contains(x, y)) {
                    l.switchPlayingStatus();
                }
                break;

            case MotionEvent.ACTION_POINTER_UP:
            if (right.contains(x, y)) {
                    l.ship.setPressingRight(false);
                } else if (left.contains(x, y)) {
                    l.ship.setPressingLeft(false);
                }

                break;
            }
         }

    }
}
```

现在，我们可以绕着飞行，释放几个空间回合！当然，您将不得不估计屏幕位置，直到我们在本章稍后绘制平视显示器。不要忘记，玩家需要先点击暂停按钮(右上角)。

### 注

注意，目前我们不使用`resetBullet`方法，一旦你射出了你的二十发子弹，你就不能再开枪了。我们可以快速检查子弹是否在边界外的某个位置，然后呼叫`resetBullet`，但我们将在下一章中结合所有碰撞检测对此进行全面处理。

当然，我们不能有一个没有任何小行星的小行星游戏。

# 绘制和移动小行星

最后，我们将添加我们凉爽、旋转的小行星。首先，我们来看看构造函数，它与其他游戏对象构造函数非常相似，只是我们随机设置了世界位置。然而，要格外小心，不要在地图的中心，飞船开始游戏的地方产卵。

创建一个名为`Asteroid`的新类，并添加这个构造函数。请注意，我们没有定义任何顶点。我们将其委托给我们即将看到的`generatePoints`方法。

```
public class Asteroid extends GameObject{

    PointF[] points;

    public Asteroid(int levelNumber, int mapWidth, int mapHeight){
        super();

        // set a random rotation rate in degrees per second
        Random r = new Random();
        setRotationRate(r.nextInt(50 * levelNumber) + 10);

        // travel at any random angle
        setTravellingAngle(r.nextInt(360));

        // Spawn asteroids between 50 and 550 on x and y
        // And avoid the extreme edges of map
        int x = r.nextInt(mapWidth - 100)+50;
        int y = r.nextInt(mapHeight - 100)+50;

        // Avoid the center where the player spawns
        if(x > 250 && x < 350){ x = x + 100;}
        if(y > 250 && y < 350){ y = y + 100;}

        // Set the location
        setWorldLocation(x,y);

        // Make them a random speed with the maximum
        // being appropriate to the level number
        setSpeed(r.nextInt(25 * levelNumber)+1);

        setMaxSpeed(140);

        // Cap the speed
        if (getSpeed() > getMaxSpeed()){
            setSpeed(getMaxSpeed());
        }

        // Make sure we know this object is a ship
        setType(Type.ASTEROID);

        // Define a random asteroid shape
        // Then call the parent setVertices()
        generatePoints();

    }
```

我们的更新方法只是根据速度和行进角度计算速度，就像我们对`SpaceShip`类所做的那样。然后它以通常的方式调用`move()`。

```
public void update(float fps){

  setxVelocity ((float) (getSpeed() * Math.cos(Math.toRadians  (getTravellingAngle() + 90))));

  setyVelocity ((float) (getSpeed() * Math.sin(Math.toRadians(getTravellingAngle() + 90))));

     move(fps);

}
```

这里我们看到`generatePoints`方法，它将创建一个随机形状的小行星。简单解释一下，每个小行星将有六个顶点。每个顶点都有一个随机生成的位置，但在相当严格的限制内，所以我们不会得到任何重叠的线。

```
// Create a random asteroid shape
public void generatePoints(){
  points = new PointF[7];

   Random r = new Random();
   int i;

     // First a point roughly centre below 0
     points[0] = new PointF();
     i = (r.nextInt(10))+1;
     if(i % 2 == 0){i = -i;}
     points[0].x = i;
     i = -(r.nextInt(20)+5);
     points[0].y = i;

     // Now a point still below centre but to the right and up a bit
     points[1] = new PointF();
     i = r.nextInt(14)+11;
     points[1].x = i;
     i = -(r.nextInt(12)+1);
     points[1].y =  i;

     // Above 0 to the right
     points[2] = new PointF();
     i = r.nextInt(14)+11;
     points[1].x = i;
     i = r.nextInt(12)+1;
     points[2].y = i;

     // A point roughly centre above 0
     points[3] = new PointF();
     i = (r.nextInt(10))+1;
     if(i % 2 == 0){i = -i;}
     points[3].x = i;
     i = r.nextInt(20)+5;
     points[3].y =  i;

     // left above 0
     points[4] = new PointF();
     i = -(r.nextInt(14)+11);
     points[4].x = i;
     i = r.nextInt(12)+1;
     points[4].y = i ;

     // left below 0
     points[5] = new PointF();
     i = -(r.nextInt(14)+11);
     points[5].x =  i;
     i = -(r.nextInt(12)+1);

     points[5].y = i;
```

现在，我们有了六个点，用来构建代表顶点的浮动数组。最后，我们调用`setVertices()`来创建我们的`ByteBuffer`。请注意，小行星将被绘制为一系列线条，这就是为什么阵列中的最后一个顶点与第一个顶点相同。

```
  // Now use these points to draw our asteroid
  float[] asteroidVertices = new float[]{
     // First point to second point
     points[0].x, points[0].y, 0,
     points[1].x, points[1].y, 0,

     // 2nd to 3rd
     points[1].x, points[1].y, 0,
     points[2].x, points[2].y, 0,

     // 3 to 4
     points[2].x, points[2].y, 0,
     points[3].x, points[3].y, 0,

     // 4 to 5
     points[3].x, points[3].y, 0,
     points[4].x, points[4].y, 0,

     // 5 to 6
     points[4].x, points[4].y, 0,
     points[5].x, points[5].y, 0,

     // 6 back to 1
     points[5].x, points[5].y, 0,
     points[0].x, points[0].y, 0,
};

setVertices(asteroidVertices);

}// End method

}// End class
```

正如你可能已经预料到的那样，我们在`GameManager`上增加了一个阵列来容纳我们所有的小行星。同时，我们将声明一些变量，这些变量将保持玩家当前所处的级别，以及小行星的起始(基本)数量。然后很快，当我们初始化我们所有的小行星时，我们将看到我们将如何确定需要被摧毁以清除一个等级的小行星的数量。

```
Asteroid [] asteroids;
int numAsteroids;
int numAsteroidsRemaining;
int baseNumAsteroids = 10;
int levelNumber = 1;
```

在`GameManager`构造函数中初始化数组:

```
// For all our asteroids
asteroids = new Asteroid[500];
```

在`createObjects`方法中使用我们之前声明的变量初始化物体本身，以基于当前水平确定小行星的数量。

```
// Determine the number of asteroids
gm.numAsteroids = gm.baseNumAsteroids * gm.levelNumber;
// Set how many asteroids need to be destroyed by player
gm.numAsteroidsRemaining = gm.numAsteroids;
// Spawn the asteroids

for (int i = 0; i < gm.numAsteroids * gm.levelNumber; i++) {
     // Create a new asteroid
     // Pass in level number so they can be made
     // appropriately dangerous.
     gm.asteroids[i] = new Asteroid
      (gm.levelNumber, gm.mapWidth, gm.mapHeight);

}
```

在`update`方法中更新它们。

```
// Update all the asteroids
for (int i = 0; i < gm.numAsteroids; i++) {
  if (gm.asteroids[i].isActive()) {
    gm.asteroids[i].update(fps);
  }
}
```

最后，我们可以用`draw`方法画出我们所有的小行星。

```
// The bullets
for (int i = 0; i < gm.numBullets; i++) {
  gm.bullets[i].draw(viewportMatrix);
}

for (int i = 0; i < gm.numAsteroids; i++) {
 if (gm.asteroids[i].isActive()) {
 gm.asteroids[i].draw(viewportMatrix);
 }

}

```

现在，运行游戏，看看那些光滑的，60+ FPS，旋转的小行星。

![Drawing and moving the asteroids](graphics/B043422_10_03.jpg)

现在，我们需要通过增加按钮图形，以及一些其他叠加信息，用一个 HUD，让控制飞船变得容易。

# 分数和抬头显示器

抬头显示器对象永远不会旋转。此外，它们是在`InputController`类中基于屏幕坐标定义的，而不是游戏世界甚至 Open GL 坐标。所以我们的`GameObject`班不是一个合适的家长班。

为了简单起见，三个 HUD 类都将有自己的`draw`方法。我们将看到如何使用新的视口矩阵以一致的大小和屏幕位置绘制它们。

一旦我们创建了所有三个抬头显示器类，我们将添加所有的对象声明、初始化和绘图代码。

## 添加控制按钮

我们将为第一个 HUD 对象制作一个类，是一个简单的按钮。

### 注

我会显式显示所有导入，因为它们不会自动导入。请注意，接下来的两个类也需要这些。代码像往常一样都在下载包里，如果你想复制粘贴的话。

创建一个新的类并将其称为`GameButton`，然后添加以下导入语句。请务必根据您使用的章节的代码或您给项目起的名字来说明正确的包名称。

```
import android.graphics.PointF;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import static android.opengl.GLES20.GL_FLOAT;
import static android.opengl.GLES20.GL_LINES;
import static android.opengl.GLES20.glDrawArrays;
import static android.opengl.GLES20.glEnableVertexAttribArray;
import static android.opengl.GLES20.glGetAttribLocation;
import static android.opengl.GLES20.glGetUniformLocation;
import static android.opengl.GLES20.glUniform4f;
import static android.opengl.GLES20.glUniformMatrix4fv;
import static android.opengl.GLES20.glUseProgram;
import static android.opengl.Matrix.orthoM;
import static android.opengl.GLES20.glVertexAttribPointer;
import static com.gamecodeschool.c10asteroids.GLManager.A_POSITION;
import static com.gamecodeschool.c10asteroids.GLManager.COMPONENTS_PER_VERTEX;
import static com.gamecodeschool.c10asteroids.GLManager.FLOAT_SIZE;
import static com.gamecodeschool.c10asteroids.GLManager.STRIDE;
import static com.gamecodeschool.c10asteroids.GLManager.U_COLOR;
import static com.gamecodeschool.c10asteroids.GLManager.U_MATRIX;
```

首先，我们宣布一些成员；`viewportMatrix`我们将从`InputController`类的基于屏幕的坐标中为视口变换放入我们的新矩阵——一个 int `glprogram`值、`int numVertices`值和一个`FloatBuffer`类。

```
public class GameButton {

    // For button coordinate
    // into a GL space coordinate (-1,-1 to 1,1)
    // for drawing on the screen
    private final float[] viewportMatrix = new float[16];

    // A handle to the GL glProgram -
    // the compiled and linked shaders
    private static int glProgram;

    // How many vertices does it take to make
    // our button
    private int numVertices;

    // This will hold our vertex data that is
    // passed into openGL glProgram
    private FloatBuffer vertices;
```

我们在构造器中做的第一件事是通过调用`orthoM()`来制作我们的视口矩阵，屏幕高度和宽度为`0,0`。这使得 OpenGL 地图的坐标范围与 OpenGL 坐标范围顶部的设备分辨率相同。

然后我们得到传入按钮的坐标，并缩小它，使其更小。然后，我们初始化一个顶点数组为四条线来表示一个按钮。显然，我们需要创建一个新的按钮对象来表示我们的`InputController`类中的每个按钮。

```
public GameButton(int top, int left, 
    int bottom, int right, GameManager gm){

    //The HUD needs its own viewport
    // notice we set the screen height in pixels as the
    // starting y coordinates because
    // OpenGL is upside down world :-)
    orthoM(viewportMatrix, 0, 0, 
        gm.screenWidth, gm.screenHeight, 0, 0, 1f);

        // Shrink the button visuals to make
        // them less obtrusive while leaving
        // the screen area they represent the same.
        int width = (right - left) / 2;
        int height = (top - bottom) / 2;
        left = left + width / 2;
        right = right - width / 2;
        top = top - height / 2;
        bottom = bottom + height / 2;

        PointF p1 = new PointF();
        p1.x = left;
        p1.y = top;

        PointF p2 = new PointF();
        p2.x = right;
        p2.y = top;

        PointF p3 = new PointF();
        p3.x = right;
        p3.y = bottom;

        PointF p4 = new PointF();
        p4.x = left;
        p4.y = bottom;

        // Add the four points to an array of vertices
        // This time, because we don't need to animate the border
        // we can just declare the world space coordinates, the
        // same as above.
        float[] modelVertices = new float[]{
                // A line from point 1 to point 2
                p1.x, p1.y, 0,
                p2.x, p2.y, 0,
                // Point 2 to point 3
                p2.x, p2.y, 0,
                p3.x, p3.y, 0,
                // Point 3 to point 4
                p3.x, p3.y, 0,
                p4.x, p4.y, 0,
                // Point 4 to point 1
                p4.x, p4.y, 0,
                p1.x, p1.y, 0
        };
```

现在，我们从`GameObject`复制一点的代码来准备`ByteBuffer`，但是仍然使用我们的静态`GLManager.getGLProgram()`来处理一个 GL 程序。

```
       // Store how many vertices and 
       // elements there is for future use
       final int ELEMENTS_PER_VERTEX = 3;// x,y,z
       int numElements = modelVertices.length;
       numVertices = numElements/ELEMENTS_PER_VERTEX;

       // Initialize the vertices ByteBuffer object based on the
       // number of vertices in the button and the number of
       // bytes there are in the float type
       vertices = ByteBuffer.allocateDirect(
                numElements
                * FLOAT_SIZE)
                .order(ByteOrder.nativeOrder()).asFloatBuffer();

       // Add the button into the ByteBuffer object
       vertices.put(modelVertices);

       glProgram = GLManager.getGLProgram();

}
```

最后，我们实现`draw`方法，这是来自`GameObject`的`draw`方法的简化版本。请注意，我们不需要处理模型、平移和旋转矩阵，并且我们向片段着色器传递不同的颜色。

```
public void draw(){

    // And tell OpenGl to use the glProgram
    glUseProgram(glProgram);

    // Now we have a glProgram we need the locations
    // of our three GLSL variables
    int uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);

    int aPositionLocation = 
        glGetAttribLocation(glProgram, A_POSITION);

    int uColorLocation = glGetUniformLocation(glProgram, U_COLOR);

    vertices.position(0);

    glVertexAttribPointer(
        aPositionLocation,
        COMPONENTS_PER_VERTEX,
        GL_FLOAT,
        false,
        STRIDE,
        vertices);

    glEnableVertexAttribArray(aPositionLocation);

    // give the new matrix to OpenGL
    glUniformMatrix4fv(uMatrixLocation, 1, false, viewportMatrix, 0);

    // Assign a different color to the fragment shader
    glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);

    // Draw the lines
    // start at the first element of the
    // vertices array and read in all vertices
    glDrawArrays(GL_LINES, 0, numVertices);

}
}// End class
```

## 计数图标

此类与`GameButton`相同，除了一个理货图标会是一条直线竖线；因此，我们只需要两个顶点。

但是，请注意，我们在构造函数中有一个名为`nthIcon`的参数。调用代码的责任是让`TallyIcon`知道已经创建的`TallyIcon`对象的总数，再加一。然后，当前`TallyIcon`对象可以使用填充变量来适当地定位自己。

创建一个名为`TallyIcon`的新类，并输入以下代码。如前所述，根据需要包括静态导入。下面是所有声明和构造函数的代码:

```
public class TallyIcon {

    // For button coordinate
    // into a GL space coordinate (-1,-1 to 1,1)
    // for drawing on the screen
    private final float[] viewportMatrix = new float[16];

    // A handle to the GL glProgram -
    // the compiled and linked shaders
    private static int glProgram;

    // How many vertices does it take to make
    // our button
    private int numVertices;

    // This will hold our vertex data that is
    // passed into openGL glProgram
    //private final FloatBuffer vertices;
    private FloatBuffer vertices;

    public TallyIcon(GameManager gm, int nthIcon){

        // The HUD needs its own viewport
        // notice we set the screen height in pixels as the
        // starting y coordinates because
        // OpenGL is upside down world :-)
        orthoM(viewportMatrix, 0, 0,
          gm.screenWidth, gm.screenHeight, 0, 0f, 1f);

        float padding = gm.screenWidth / 160;
        float iconHeight = gm.screenHeight / 15;
        float iconWidth = 1; // square icons
        float startX = 10 + (padding + iconWidth)* nthIcon;
        float startY = iconHeight * 2 + padding;

        PointF p1 = new PointF();
        p1.x = startX;
        p1.y = startY;

        PointF p2 = new PointF();
        p2.x = startX;
        p2.y = startY - iconHeight;

        // Add the four points to an array of vertices
        // This time, because we don't need to animate the border
        // we can just declare the world space coordinates, the
        // same as above.
        float[] modelVertices = new float[]{
                // A line from point 1 to point 2
                p1.x, p1.y, 0,
                p2.x, p2.y, 0,

        };

        // Store how many vertices and 
        //elements there is for future use
        final int ELEMENTS_PER_VERTEX = 3;// x,y,z
        int numElements = modelVertices.length;
        numVertices = numElements/ELEMENTS_PER_VERTEX;

        // Initialize the vertices ByteBuffer object based on the
        // number of vertices in the button and the number of
        // bytes there are in the float type
        vertices = ByteBuffer.allocateDirect(
                numElements
                * FLOAT_SIZE)
                .order(ByteOrder.nativeOrder()).asFloatBuffer();

        // Add the button into the ByteBuffer object
        vertices.put(modelVertices);

        glProgram = GLManager.getGLProgram();
    }
```

这是抽奖方法，也就是，可能现在看起来已经很熟悉了。

```
    public void draw(){

        // And tell OpenGl to use the glProgram
        glUseProgram(glProgram);

        // Now we have a glProgram we need the locations
        // of our three GLSL variables
        int uMatrixLocation = 
        glGetUniformLocation(glProgram, U_MATRIX);

        int aPositionLocation = 
        glGetAttribLocation(glProgram, A_POSITION);

        int uColorLocation = 
        glGetUniformLocation(glProgram, U_COLOR);

        vertices.position(0);

        glVertexAttribPointer(
                aPositionLocation,
                COMPONENTS_PER_VERTEX,
                GL_FLOAT,
                false,
                STRIDE,
                vertices);

        glEnableVertexAttribArray(aPositionLocation);

        // Just give the passed in matrix to OpenGL
        glUniformMatrix4fv(uMatrixLocation, 1, 
          false, viewportMatrix, 0);

        // Assign a color to the fragment shader
        glUniform4f(uColorLocation, 1.0f, 1.0f, 0.0f, 1.0f);

        // Draw the lines
        // start at the first element of the vertices array and read in all vertices
        glDrawArrays(GL_LINES, 0, numVertices);
    }
```

现在是最后的抬头显示器元素。

## 生活图标

我们的最后一个图标将是一种迷你飞船，用来指示玩家还有多少生命。

我们将构建一个三角形的线条来创建一个漂亮的空心效果。请注意，`LifeIcon`构造函数还使用一个`nthIcon`元素来控制填充和屏幕位置。

创建一个名为`LifeIcon`的新类，输入以下代码，记住所有不会自动导入的导入。下面是声明和构造函数:

```
public class LifeIcon {

     // Remember the static import for GLManager

     // For button coordinate
     // into a GL space coordinate (-1,-1 to 1,1)
     // for drawing on the screen
     private final float[] viewportMatrix = new float[16];

     // A handle to the GL glProgram -
     // the compiled and linked shaders
     private static int glProgram;

     // Each of the above constants also has a matching int
     // which will represent its location in the open GL glProgram
     // In GameButton they are declared as local variables

     // How many vertices does it take to make
     // our button
     private int numVertices;

     // This will hold our vertex data that is
     // passed into openGL glProgram
     //private final FloatBuffer vertices;
     private FloatBuffer vertices;

     public LifeIcon(GameManager gm, int nthIcon){

     // The HUD needs its own viewport
     // notice we set the screen height in pixels as the
     // starting y coordinates because
     // OpenGL is upside down world :-)
     orthoM(viewportMatrix, 0, 0,
       gm.screenWidth, gm.screenHeight, 0, 0f, 1f);

     float padding = gm.screenWidth / 160;
     float iconHeight = gm.screenHeight / 15;
     float iconWidth = gm.screenWidth / 30;
     float startX = 10 + (padding + iconWidth)* nthIcon;
     float startY = iconHeight;

     PointF p1 = new PointF();
     p1.x = startX;
     p1.y = startY;

     PointF p2 = new PointF();
     p2.x = startX + iconWidth;
     p2.y = startY;

     PointF p3 = new PointF();
     p3.x = startX + iconWidth/2;
     p3.y = startY - iconHeight;

     // Add the four points to an array of vertices
     // This time, because we don't need to animate the border
     // we can just declare the world space coordinates, the
     // same as above.
     float[] modelVertices = new float[]{
               // A line from point 1 to point 2
               p1.x, p1.y, 0,
               p2.x, p2.y, 0,
               // Point 2 to point 3
               p2.x, p2.y, 0,
               p3.x, p3.y, 0,
               // Point 3 to point 1
               p3.x, p3.y, 0,
               p1.x, p1.y, 0,

  };

     // Store how many vertices and elements there is for future 
     // use
     final int ELEMENTS_PER_VERTEX = 3;// x,y,z
     int numElements = modelVertices.length;
     numVertices = numElements/ELEMENTS_PER_VERTEX;

     // Initialize the vertices ByteBuffer object based on the
     // number of vertices in the button and the number of
     // bytes there are in the float type
     vertices = ByteBuffer.allocateDirect(
              numElements
              * FLOAT_SIZE)
              .order(ByteOrder.nativeOrder()).asFloatBuffer();

     // Add the button into the ByteBuffer object
     vertices.put(modelVertices);

       glProgram = GLManager.getGLProgram();
     }
```

以下是`LifeIcon`类的`draw`方法:

```
    public void draw(){

            // And tell OpenGl to use the glProgram
            glUseProgram(glProgram);

            // Now we have a glProgram we need the locations
            // of our three GLSL variables
            int uMatrixLocation = glGetUniformLocation 
              (glProgram, U_MATRIX);
            int aPositionLocation = glGetAttribLocation 
              (glProgram, A_POSITION);
            int uColorLocation = glGetUniformLocation 
               (glProgram, U_COLOR);

            vertices.position(0);

            glVertexAttribPointer(
                    aPositionLocation,
                    COMPONENTS_PER_VERTEX,
                    GL_FLOAT,
                    false,
                    STRIDE,
                    vertices);

            glEnableVertexAttribArray(aPositionLocation);

            // Just give the passed in matrix to OpenGL
            glUniformMatrix4fv(uMatrixLocation, 1, 
              false, viewportMatrix, 0);
            // Assign a color to the fragment shader
            glUniform4f(uColorLocation, 1.0f, 
              1.0f, 0.0f, 1.0f);
            // Draw the lines
            // start at the first element of 
            // the vertices array and read in all vertices
            glDrawArrays(GL_LINES, 0, numVertices);
        }

}
```

我们有三个 HUD 类，我们可以把它们画到屏幕上。

### 声明、初始化和绘制抬头显示器对象

我们将像所有`GameObject`类一样声明、初始化和绘制我们的 HUD 对象。然而，请注意不出所料，我们没有将视口矩阵传递给`draw` 方法，因为平视显示器类提供了它们自己的。

将这些成员添加到`GameManager`:

```
TallyIcon[] tallyIcons;
int numLives = 3;
LifeIcon[] lifeIcons;
```

正如我们对`asteroids`数组所做的那样，在`GameManager`构造函数中初始化`tallyIcons`和`lifeIcons`:

```
lifeIcons = new LifeIcon[50];
tallyIcons = new TallyIcon[500];
```

向`AsteroidsRenderer`类添加新的成员数组:

```
// This will hold our game buttons
private final GameButton[] gameButtons = new GameButton[5];
```

添加这个代码来创建我们所有新的抬头显示器类的对象。在右花括号前加入`createObjects`方法:

```
// Now for the HUD objects
// First the life icons
for(int i = 0; i < gm.numLives; i++) {
    // Notice we send in which icon this represents
    // from left to right so padding and positioning is correct.
    gm.lifeIcons[i] = new LifeIcon(gm, i);
}

// Now the tally icons (1 at the start)
for(int i = 0; i < gm.numAsteroidsRemaining; i++) {
    // Notice we send in which icon this represents
    // from left to right so padding and positioning is correct.
    gm.tallyIcons[i] = new TallyIcon(gm, i);
}

// Now the buttons
ArrayList<Rect> buttonsToDraw = ic.getButtons();
int i = 0;
for (Rect rect : buttonsToDraw) {
    gameButtons[i] = new GameButton(rect.top, rect.left, 
        rect.bottom, rect.right, gm);

    i++;

}
```

现在我们可以根据剩下的生命数量和下一关之前剩下的小行星数量来绘制我们的 HUD。将此代码添加到`draw`方法的末尾:

```
// the buttons
for (int i = 0; i < gameButtons.length; i++) {
  gameButtons[i].draw();
}

// Draw the life icons
for(int i = 0; i < gm.numLives; i++) {
     // Notice we send in which icon this represents
     // from left to right so padding and positioning is correct.
     gm.lifeIcons[i].draw();
}

// Draw the level icons
for(int i = 0; i < gm.numAsteroidsRemaining; i++) {
  // Notice we send in which icon this represents
  // from left to right so padding and positioning is correct.
  gm.tallyIcons[i].draw();
}
```

你现在可以在周围飞行，欣赏你的新平视显示器。

![Declaring, initializing, and drawing the HUD objects](graphics/B043422_10_04.jpg)

显然，如果我们要利用我们的生命和小行星计数指示器，那么我们首先需要能够拍摄小行星，并在飞船被击中时检测到它们。

# 总结

我们在这一章中取得了很多成就，事实上，快速添加更多的游戏对象很简单。也许，一个偶然的不明飞行物就像在原始的街机经典。

在下一章中，我们将使用我们在以前的项目中学到的知识来设置碰撞检测并结束游戏。然而，一款拥有精确、干净、流畅的运动线条的游戏值得比我们目前使用的更精确的碰撞检测。

因此，我们将专注于实现精确、高效的碰撞检测，这将使我们的小行星模拟器完整。