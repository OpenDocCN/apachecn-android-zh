# 三、Java 和 C/C++ 与 JNI 的接口

> *安卓离不开 Java。它的内核和核心库都是原生的，但是安卓应用框架几乎完全是用 Java 编写的，或者至少被包裹在一层薄薄的 Java 中。不要指望用 C/C++ 直接构建你的安卓 GUI！大多数应用编程接口只能从 Java 获得。充其量，我们可以把它藏在封面下...因此，如果不能将 Java 和 C/C++ 联系在一起，安卓上的本机 C/C++ 代码将是无稽之谈。*
> 
> *该角色致力于 Java 原生接口 API。JNI 是一个标准化的规范，允许 Java 调用本机代码和本机代码回调 Java。它是 Java 和原生端之间的双向桥梁；将 C/C++ 的力量注入到您的 Java 应用中的唯一方法。*
> 
> *多亏了 JNI，人们可以像任何 Java 方法一样从 Java 调用 C/C++ 函数，将 Java 原语或对象作为参数传递，并作为本机调用的结果接收它们。反过来，本机代码可以访问、检查、修改和调用 Java 对象，或者使用类似反射的 API 引发异常。JNI 是一个微妙的框架，需要小心，因为任何误用都会导致戏剧性的结局……*

在本章中，我们将实现一个基本的键/值存储来处理各种数据类型。一个简单的 Java 图形用户界面将允许定义一个*条目*，该条目由一个键(一个字符串)、一个类型(一个整数、一个字符串等)和一个与所选类型相关的值组成。条目在一个简单的固定大小的条目数组中被检索、插入或更新(不支持移除)，该数组将驻留在本机端。

为了实施该项目，我们将:

*   初始化本地 JNI 库
*   在本机代码中转换 Java 字符串
*   将 Java 原语传递给本机代码
*   在本机代码中处理 Java 对象引用
*   在本机代码中管理 Java 数组
*   在本机代码中引发和检查 Java 异常。

到本章结束时，您应该能够对任何 Java 类型执行本机调用并使用异常。

JNI 是一个非常技术性的框架，需要谨慎，因为任何滥用都可能导致戏剧性的结局。这一章并不打算详尽无遗地讲述它，而是着重于弥合 Java 和 C++ 之间差距的基本知识。

# 初始化本地 JNI 库

在访问它们的本地方法之前，必须通过对`System.loadLibrary()`的 Java 调用来加载本地库。JNI 提供了一个钩子，`JNI_OnLoad()`，来插入你自己的初始化代码。让我们覆盖它来初始化我们的本地存储。

### 注

由此产生的项目以`Store_Part4`的名称提供本书。

# 行动时间–定义简单的图形用户界面

让我们为我们的`Store`创建一个 Java 图形用户界面，并将其绑定到我们将创建的本地存储结构:

1.  Rewrite the `res/fragment_layout.xml` layout to define the graphical interface as follows. It defines:
    *   一个**键** `TextView`标签和`EditText`输入键
    *   一个**值** `TextView`标签和`EditText`输入匹配键的值
    *   一个**类型** `TextView`标签和`Spinner`来定义值的类型
    *   一个**获取值**和一个**设置值** `Button`在商店

        ```cpp
        <LinearLayout xmlns:a="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          a:layout_width="match_parent" a:layout_height="match_parent"
          a:orientation="vertical"
        tools:context="com.packtpub.store.StoreActivity$PlaceholderFragment">
          <TextView
            a:layout_width="match_parent" a:layout_height="wrap_content"
            a:text="Save or retrieve a value from the store:" />
          <TableLayout
            a:layout_width="match_parent" a:layout_height="wrap_content"
            a:stretchColumns="1" >
            <TableRow>
              <TextView a:id="@+id/uiKeyLabel" a:text="Key : " />
              <EditText a:id="@+id/uiKeyEdit" ><requestFocus /></EditText>
            </TableRow>
            <TableRow>
              <TextView a:id="@+id/uiValueLabel" a:text="Value : " />
              <EditText a:id="@+id/uiValueEdit" />
            </TableRow>
            <TableRow>
              <TextView a:id="@+id/uiTypeLabel" a:layout_height="match_parent"
                        a:gravity="center_vertical" a:text="Type : " />
              <Spinner a:id="@+id/uiTypeSpinner" />
            </TableRow>
          </TableLayout>
          <LinearLayout
            a:layout_width="wrap_content" a:layout_height="wrap_content"
            a:layout_gravity="right" >
            <Button a:id="@+id/uiGetValueButton" a:layout_width="wrap_content"
                    a:layout_height="wrap_content" a:text="Get Value" />
            <Button a:id="@+id/uiSetValueButton" a:layout_width="wrap_content"
                    a:layout_height="wrap_content" a:text="Set Value" />
          </LinearLayout>
        </LinearLayout>
        ```

        中检索和更改值

    最终结果应该如下:

    ![Time for action – defining a simple GUI](img/9645_03_02.jpg)

2.  在`StoreType.java`中用空枚举创建一个新类:

    ```cpp
    package com.packtpub.store;

    public enum StoreType {
    }
    ```

3.  图形用户界面和原生商店需要绑定在一起。这是`StoreActivity`班承担的角色。为此，当在`onCreateView()`中创建`PlaceholderFragment`时，初始化布局文件中先前定义的所有图形用户界面组件:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            private Store mStore = new Store();
     private EditText mUIKeyEdit, mUIValueEdit;
     private Spinner mUITypeSpinner;
            private Button mUIGetButton, mUISetButton;
            private Pattern mKeyPattern;

            ...

            @Override
            public View onCreateView(LayoutInflater inflater,
                                     ViewGroup container,
                                     Bundle savedInstanceState)
            {
                View rootView = inflater.inflate(R.layout.fragment_store,
                                                 container, false);
                updateTitle();

     // Initializes text components.
     mKeyPattern = Pattern.compile("\\p{Alnum}+");
     mUIKeyEdit = (EditText) rootView.findViewById(
     R.id.uiKeyEdit);
     mUIValueEdit = (EditText) rootView.findViewById(
     R.id.uiValueEdit);

    ```

4.  `Spinner` 内容被绑定到`StoreType`枚举。使用`ArrayAdapter`将`Spinner`和`enum`值绑定在一起。

    ```cpp
                ...
     ArrayAdapter<StoreType> adapter =
     new ArrayAdapter<StoreType>(getActivity(),
     android.R.layout.simple_spinner_item,
     StoreType.values());
     adapter.setDropDownViewResource(
     android.R.layout.simple_spinner_dropdown_item);
     mUITypeSpinner = (Spinner) rootView.findViewById(
     R.id.uiTypeSpinner);
     mUITypeSpinner.setAdapter(adapter);
                    ...
    ```

5.  **取值**和**设置值**按钮触发私有方法`onGetValue()`和`onSetValue()`，分别从商店拉数据和推数据。使用`OnClickListener`将按钮和方法绑定在一起:

    ```cpp
                ...
     mUIGetButton = (Button) rootView.findViewById(
     R.id.uiGetValueButton);
     mUIGetButton.setOnClickListener(new OnClickListener() {
     public void onClick(View pView) {
     onGetValue();
     }
     });
     mUISetButton = (Button) rootView.findViewById(
     R.id.uiSetValueButton);
     mUISetButton.setOnClickListener(new OnClickListener() {
     public void onClick(View pView) {
     onSetValue();
     }
     });
                return rootView;
            }
            ...
    ```

6.  在`PlaceholderFragment`中，定义`onGetValue()`方法，该方法将根据图形用户界面中选择的`StoreType`从商店中检索条目。将开关留空，因为它目前不会处理任何类型的条目:

    ```cpp
            ...
            private void onGetValue() {
                // Retrieves key and type entered by the user.
                String key = mUIKeyEdit.getText().toString();
                StoreType type = (StoreType) mUITypeSpinner
                                                       .getSelectedItem();
                // Checks key is correct.
                if (!mKeyPattern.matcher(key).matches()) {
                    displayMessage("Incorrect key.");
                    return;
                }

                // Retrieves value from the store and displays it.
                // Each data type has its own access method.
                switch (type) {
                    // Will retrieve entries soon...
                }
            }
            ...
    ```

7.  然后，仍然在`PlaceholderFragment`中，在`StoreActivity`中定义`onSetValue()`方法，以插入或更新商店中的条目。如果数值格式不正确，将显示一条消息:

    ```cpp
            ...
            private void onSetValue() {
                // Retrieves key and type entered by the user.
                String key = mUIKeyEdit.getText().toString();
                String value = mUIValueEdit.getText().toString();
                StoreType type = (StoreType) mUITypeSpinner
                                                       .getSelectedItem();
                // Checks key is correct.
                if (!mKeyPattern.matcher(key).matches()) {
                    displayMessage("Incorrect key.");
                    return;
                }

                // Parses user entered value and saves it in the store.
                // Each data type has its own access method.
                try {
                    switch (type) {
                        // Will put entries soon...
                    }
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
    ```

8.  最后`PlaceholderFragment`中的一个小帮手方法`displayMessage()`会在出现问题时帮助提醒用户。它显示一条简单的安卓吐司信息:

    ```cpp
            ...
            private void displayMessage(String pMessage) {
                Toast.makeText(getActivity(), pMessage, Toast.LENGTH_LONG)
                     .show();
            }
        }
    }
    ```

## *刚刚发生了什么？*

我们用 Java 创建了一个基本的图形用户界面，其中包含了安卓框架中的一些可视组件。如你所见，这里没有什么特别的 NDK。这个故事的寓意是，本机代码可以与任何现有的 Java 代码集成。

显然，我们仍有一些工作要做，以使我们的本机代码为 Java 应用执行一些有用的事情。现在让我们切换到原生端。

# 行动时间–初始化本机存储

我们需要创建并初始化我们将在本章下一节使用的所有结构:

1.  创建`jni/Store.h`文件，定义存储数据结构:
    *   `StoreType`枚举将反映相应的 Java 枚举。暂时空着。
    *   `StoreValue`联合将包含任何可能的存储值。现在也让它空着。
    *   The `StoreEntry` structure contains one piece of data in the store. It is composed of a key (a raw C string made from `char*`), a type (`StoreType`), and a value (`StoreValue`).

        ### 注

        请注意，我们将在[第 9 章](09.html "Chapter 9. Porting Existing Libraries to Android")、*中看到如何设置和使用 C++ STL 字符串，将现有库移植到 Android* 。

    *   `Store` is the main structure that defines a fixed size array of entries and a length (that is, the number of allocated entries):

        ```cpp
        #ifndef _STORE_H_
        #define _STORE_H_

        #include <cstdint>

        #define STORE_MAX_CAPACITY 16

        typedef enum {
        } StoreType;

        typedef union {
        } StoreValue;

        typedef struct {
            char* mKey;
            StoreType mType;
            StoreValue mValue;
        } StoreEntry;

        typedef struct {
            StoreEntry mEntries[STORE_MAX_CAPACITY];
            int32_t mLength;
        } Store;
        #endif
        ```

        ### 类型

        包括卫士(即`#ifndef`、`#define`、`#endif`)，保证一个头文件在编译过程中只被包含一次，并且可以被非标准的(但被广泛支持的)预处理器指令`#pragma once`替换。

2.  在`jni/com_packtpub_Store.cpp`中，执行`JNI_OnLoad()`初始化挂钩。在内部，将`Store`数据结构存储的唯一实例初始化为静态变量:

    ```cpp
    #include "com_packtpub_store_Store.h"
    #include "Store.h"

    static Store gStore;

    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
     // Store initialization.
     gStore.mLength = 0;
     return JNI_VERSION_1_6;
    }
    ...
    ```

3.  相应地更新本机`store getCount()`方法，以反映存储分配的条目计数:

    ```cpp
    ...
    JNIEXPORT jint JNICALL Java_com_packtpub_store_Store_getCount
      (JNIEnv* pEnv, jobject pObject) {
     return gStore.mLength;
    }
    ```

## *刚刚发生了什么？*

我们用一个简单的图形用户界面和一个本地内存数据数组构建了商店项目的基础。包含本机库的加载调用:

*   `System.load()`，取参数中的库全路径。
*   `System.loadLibrary()`，只需要库名，不需要路径、前缀(即`lib`)或扩展名。

本机代码初始化发生在`JNI_OnLoad()`钩子中，在本机代码的生存期内只调用一次。这是初始化和缓存全局变量的理想场所。JNI 元素(类、方法、字段等)也经常缓存在`JNI_OnLoad()`中，以提高性能。我们将在这一章和下一章中看到更多关于这方面的内容。

请注意，在 JNI 规范中定义的悬而未决的调用`JNI_OnUnload()`在安卓系统中几乎没有用，因为没有办法保证在进程终止之前卸载一个库。

`JNI_OnLoad()`签名的系统定义如下:

```cpp
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);
```

使`JNI_OnLoad()`如此有用的是它的`JavaVM`参数。从中可以检索到 **JNIEnv 界面指针**，如下所示:

```cpp
JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
 JNIEnv *env;
 if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
 abort();
    }
    ...
    return JNI_VERSION_1_6;
}
```

### 类型

JNI 图书馆的`JNI_OnLoad()`定义是可选的。但是，如果省略，您可能会注意到在< mylib >中发现警告**无 JNI_OnLoad。因此当您启动应用时，**会显示在**日志文件**中。这绝对没有后果，可以放心地忽略。

`JNIEnv`是所有 JNI 调用的主要入口点，这解释了为什么它被传递给所有本地方法。它提供了一组从本机代码访问 Java 原语和数组的方法。它被一个类似反射的应用编程接口所补充，以便从本地代码中完全访问 Java 对象。我们将在本章和下一章中更详细地发现它的特性。

### 类型

`JNIEnv`接口指针是特定于线程的。你不能在线程之间共享它！仅在从中检索它的线程上使用它。只有 JavaVM 元素是线程安全的，可以在线程之间共享。

# 在本机代码中转换 Java 字符串

我们将处理的第一种条目是字符串。在 Java 中被表示为(几乎)经典对象的字符串可以在原生端进行操作，并被转换为原生字符串，也就是原始字符数组，这要归功于 JNI。字符串是一流的公民，尽管它们的异构表示具有固有的复杂性。

在这一部分中，我们将把 Java 字符串发送到原生端，并将它们翻译成它们的原生对应物。我们还将把它们转换回一个 Java 字符串。

### 注

由此产生的项目以`Store_Part5`的名称提供本书。

# 行动时间——在本地存储中处理字符串

让我们在商店中处理字符串值:

1.  打开`StoreType.java`并在枚举中指定我们商店处理的新字符串类型:

    ```cpp
    public enum StoreType {
     String
    }
    Open Store.java and define the new functionalities our native key/value store provides (for now, only strings):
    public class Store {
        ...
        public native int getCount();

     public native String getString(String pKey);
     public native void setString(String pKey, String pString);
    }
    ```

2.  在`StoreActivity.java`中，使用`onGetValue()`方法从原生`Store`中检索字符串条目。根据图形用户界面中当前选择的类型`StoreType`进行(即使目前只有一种可能的类型):

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            ...
            private void onGetValue() {
                ...
                switch (type) {
     case String:
     mUIValueEdit.setText(mStore.getString(key));
     break;
                }
            }
            ...
    ```

3.  使用`onSetValue()`方法在存储中插入或更新字符串条目:

    ```cpp
            ...
            private void onSetValue() {
                ...
                try {
                    switch (type) {
     case String:
     mStore.setString(key, value);
     break;
                    }
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
        }
    }
    ```

4.  在`jni/Store.h`中，包括一个新的`header jni.h`来访问 JNI 应用编程接口。

    ```cpp
    #ifndef _STORE_H_
    #define _STORE_H_

    #include <cstdint>
    #include "jni.h"
    ...
    ```

5.  接下来，将字符串集成到原生`StoreType` 枚举和`StoreValue`联合:

    ```cpp
    ...
    typedef enum {
     StoreType_String
    } StoreType;

    typedef union {
     char*     mString;
    } StoreValue;
    ...
    ```

    中
6.  通过声明检查、创建、查找和销毁条目的实用方法来终止。`JNIEnv`和`jstring`是在`jni.h`标题中定义的 JNI 类型:

    ```cpp
    ...
    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType);

    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey);

    StoreEntry* findEntry(JNIEnv* pEnv, Store* pStore, jstring pKey);

    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry);
    #endif
    ```

7.  创建一个新文件`jni/Store.cpp`来实现所有这些实用方法。首先，`isEntryValid()`简单地检查一个条目是否被分配并且具有预期的类型:

    ```cpp
    #include "Store.h"
    #include <cstdlib>
    #include <cstring>

    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType) {
        return ((pEntry != NULL) && (pEntry->mType == pType));
    }
    ...
    ```

8.  `findEntry()`方法将作为参数传递的密钥与存储中的每个密钥进行比较，直到找到匹配项。它不是使用经典的本地字符串(即`char*`)，而是接收一个`jstring`参数，这是 Java `String`在本地的直接表示。
9.  To recover a native string from a Java `String`, use `GetStringUTFChars()` from the JNI API to get a temporary character buffer containing the converted Java string. Its content can then be manipulated using standard C routines. `GetStringUTFChars()` must be systematically coupled with a call to `ReleaseStringUTFChars()` to release the temporary buffer allocated in `GetStringUTFChars()`:

    ### 类型

    Java 字符串作为 UTF-16 字符串存储在内存中。当它们的内容以本机代码提取时，返回的缓冲区以修改后的 UTF-8 编码。修改后的 UTF-8 与标准的 C String 函数兼容，该函数通常在由每个字符 8 位组成的字符串缓冲区中工作。

    ```cpp
    ...
    StoreEntry* findEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {
        StoreEntry* entry = pStore->mEntries;
        StoreEntry* entryEnd = entry + pStore->mLength;

        // Compare requested key with every entry key currently stored
        // until we find a matching one.
        const char* tmpKey = pEnv->GetStringUTFChars(pKey, NULL);
        while ((entry < entryEnd) && (strcmp(entry->mKey, tmpKey) != 0)) {
            ++ entry;
        }
        pEnv->ReleaseStringUTFChars(pKey, tmpKey);

        return (entry == entryEnd) ? NULL : entry;
    }
    ...
    ```

    ### 类型

    JNI 不原谅任何错误。例如，如果您在`GetStringUTFChars()`中传递`NULL`作为第一个参数，虚拟机将立即中止。另外，安卓 JNI 并没有完全尊重 JNI 规范。尽管《JNI 规范》指出，如果无法分配内存，`GetStringUTFChars()`可能会返回`NULL`，但在这种情况下，安卓虚拟机将简单地中止。

10.  Implement `allocateEntry()`, which either creates a new entry (that is, increments the store length and returns the last element) or returns an existing one if the key already exists (after releasing its previous value).

    如果条目是一个新的条目，将其密钥转换为可以保存在内存中的原生字符串。实际上，原始 JNI 对象在本机方法调用期间一直存在，并且不得保留在其范围之外:

    ```cpp
    ...
    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {
        // If entry already exists in the store, releases its content
        // and keep its key.
        StoreEntry* entry = findEntry(pEnv, pStore, pKey);
        if (entry != NULL) {
            releaseEntryValue(pEnv, entry);
        }
        // If entry does not exist, create a new entry
        // right after the entries already stored.
        else {
            entry = pStore->mEntries + pStore->mLength;

            // Copies the new key into its final C string buffer.
            const char* tmpKey = pEnv->GetStringUTFChars(pKey, NULL);
            entry->mKey = new char[strlen(tmpKey) + 1];
            strcpy(entry->mKey, tmpKey);
            pEnv->ReleaseStringUTFChars(pKey, tmpKey);

            ++ pStore->mLength;
        }
        return entry;
    }
    ...
    ```

11.  编写最后一个方法`releaseEntryValue()`，如果需要的话，释放分配给某个值的内存:

    ```cpp
    ...
    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {
        switch (pEntry->mType) {
        case StoreType_String:
            delete pEntry->mValue.mString;
            break;
        }
    }
    ```

12.  用`javah`刷新 JNI 头文件`jni/com_packtpub_Store.h`，如前一章所示。你应该会在里面看到两个新方法`Java_com_packtpub_store_Store_getString()`和`Java_com_packtpub_store_Store_setString()`。
13.  在`jni/com_packtpub_Store.cpp`中，插入`cstdlib`头文件:

    ```cpp
    #include "com_packtpub_store_Store.h"
    #include <cstdlib>
    #include "Store.h"
    ...
    ```

14.  借助之前生成的 JNI 头，实现原生方法`getString()`。此方法查找传递给存储区的密钥，并返回其相应的字符串值。如果出现任何问题，将返回默认的`NULL`值。
15.  Java 字符串不是真正的原语。类型`jstring`和 `char*`不能互换使用，我们已经看到了。要从本地字符串创建一个 Java `String`对象，请使用 JNI 应用编程接口中的`NewStringUTF()`:

    ```cpp
    ...
    JNIEXPORT jstring JNICALL Java_com_packtpub_store_Store_getString
      (JNIEnv* pEnv, jobject pThis, jstring pKey) {
        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
        if (isEntryValid(pEnv, entry, StoreType_String)) {
            // Converts a C string into a Java String.
            return pEnv->NewStringUTF(entry->mValue.mString);
        } else {
            return NULL;
        }
    }
    ...
    ```

16.  然后，实现`setString()`方法，分配一个条目(即，在存储中创建一个新条目，或者如果它有相同的键，则重用一个现有条目)，并将转换后的 Java 字符串值存储在其中。
17.  使用 JNI 应用编程接口的`GetStringUTFLength()`和`GetStringUTFRegion()`方法，字符串值从一个 Java 字符串直接转换到我们自己的字符串缓冲区。这是对早先使用的`GetStringUTFChars()`的替代。最后，我们一定不要忘记附加 `null`字符，这是原始 C 字符串的标准:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setString
      (JNIEnv* pEnv, jobject pThis, jstring pKey, jstring pString) {
        // Turns the Java string into a temporary C string.
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            entry->mType = StoreType_String;
            // Copy the temporary C string into its dynamically allocated
            // final location. Then releases the temporary string.
            jsize stringLength = pEnv->GetStringUTFLength(pString);
            entry->mValue.mString = new char[stringLength + 1];
            // Directly copies the Java String into our new C buffer.
            pEnv->GetStringUTFRegion(pString, 0, stringLength,
                                     entry->mValue.mString);
            // Append the null character for string termination.
            entry->mValue.mString[stringLength] = '\0';    }
    }
    ```

18.  最后更新`Android.mk`文件编译`Store.cpp` :

    ```cpp
    LOCAL_PATH := $(call my-dir)

    include $(CLEAR_VARS)

    LOCAL_MODULE    := com_packtpub_store_Store
    LOCAL_SRC_FILES := com_packtpub_store_Store.cpp Store.cpp

    include $(BUILD_SHARED_LIBRARY)
    ```

## *刚刚发生了什么？*

运行应用。尝试用不同的键和值保存一些条目。然后试着把它们从本地商店拿回来。我们设法将字符串从 Java 传递和检索到 C/C++。这些值作为本机字符串保存在本机内存中。然后，条目可以根据它们的关键字作为 Java 字符串从存储中检索出来。

Java 和 C 字符串是完全不同的野兽。Java 字符串需要具体转换为本机字符串，以便使用标准的 C 字符串例程处理其内容。事实上，`jstring`不是经典的`char*`数组的表示，而是对一个 Java `String`对象的引用，只能从 Java 代码中访问。

在这一部分中，我们发现了两种将 Java 字符串转换为本机字符串的方法:

*   通过预先分配一个内存缓冲区来复制转换后的 Java 字符串。
*   通过在 JNI 管理的内存缓冲区中检索转换后的 Java 字符串。

选择哪种解决方案取决于客户端代码如何处理内存。

## 原生字符编码

JNI 提供了两种处理字符串的方法:

*   名字中有 UTF 的那种，可以处理修改后的 UTF-8 字符串
*   名字中没有 UTF 的那些可以使用 UTF-16 编码

修改后的 UTF-8 和 UTF-16 字符串是两种不同的字符编码:

*   **改良 UTF-8** 是 UTF-8 特有的与爪哇略有不同的风味。这种编码可以代表标准 ASCII 字符(每个字符在一个字节上)，也可以长到 4 个字节来代表扩展字符(阿拉伯语、西里尔语、希腊语、希伯来语等)。标准 UTF-8 和改进型 UTF-8 的区别在于`null`字符的不同表示，后者编码中根本不存在。以这种方式，可以用标准的 C 例程处理这样的字符串，其中`null`字符被用作结束标记。
*   **UTF-16** 是用于 Java 字符串的真正的编码。每个字符用两个字节表示，因此是 Java `char`大小。因此，在本机代码中使用 UTF-16 比修改后的 UTF-8 更有效，因为它们不需要转换。缺点是经典的 C 字符串例程不会与它们一起工作，因为它们没有`null`终止。

字符编码是一个复杂的主题，您可以在[http://www . Oracle . com/tech network/articles/javase/supplicate-142654 . html](http://www.oracle.com/technetwork/articles/javase/supplementary-142654.html)和[的](http://developer.android.com/training/articles/perf-jni.html#UTF_8_and_UTF_16_strings) Android 文档中找到更多信息。

## JNI 字符串 API

JNI 提供了几种在本地处理 Java 字符串的方法:

*   `GetStringUTFLength()`以*字节*计算修改后的 UTF-8 字符串长度(实际上 UTF-8 字符串具有不同的字符大小)，而`GetStringLength()`计算 UTF-16 字符串*的字符数*(不是字节，因为 UTF-16 字符具有固定的大小):

    ```cpp
    jsize GetStringUTFLength(jstring string)
    jsize GetStringLength(jstring string)
    ```

*   `GetStringUTFChars()` and `GetStringChars()` allocate a new memory buffer managed by JNI to store the result of Java to native (respectively Modified UTF-8 and UTF-16) string conversion. Use it when you want to convert an entire string without bothering with memory allocation. The last parameter `isCopy`, when not `null`, indicates whether the string has been internally copied by JNI or whether the returned buffer points to the real Java string memory. In Android, the returned `isCopy` value is generally `JNI_TRUE` for `GetStringUTFChars()` and `JNI_FALSE` for `GetStringChars()` (indeed the latter does not require encoding conversion):

    ```cpp
    const char* GetStringUTFChars(jstring string, jboolean* isCopy)
    const jchar* GetStringChars(jstring string, jboolean* isCopy)
    ```

    ### 类型

    虽然 JNI 规范指出`GetStringUTFChars()`可以返回空值(这意味着操作失败，因为例如内存无法分配)，但实际上，这种检查是无用的，因为在这种情况下，Dalvik 或 ART 虚拟机通常会中止。所以干脆避免陷入那种境地吧！如果您的代码旨在移植到其他 Java 虚拟机，您仍然应该保留空检查。

*   `ReleaseStringUTFChars()`和`ReleaseStringChars()`在客户端处理完毕后，释放`GetStringUTFChars()`和`GetStringChars()`分配的内存缓冲区。这些方法必须总是成对调用:

    ```cpp
    void ReleaseStringUTFChars(jstring string, const char* utf)
    void ReleaseStringChars(jstring string, const jchar* chars)
    ```

*   `GetStringUTFRegion()`和`GetStringRegion()`检索 Java 字符串的全部或仅一个区域。它在客户端代码提供和管理的字符串缓冲区上工作。当您想要管理内存分配(例如，重用现有的内存缓冲区)或需要访问字符串的小部分时，请使用它:

    ```cpp
    void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf)
    void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf)
    ```

*   `GetStringCritical()`和`ReleaseStringCritical()`与`GetStringChars()`和`ReleaseStringChars()`类似，但仅适用于 UTF-16 字符串。根据 JNI 规范，`GetStringCritical()`更有可能返回直接指针而不进行任何复制。作为交换，调用者不能执行阻塞或 JNI 调用，也不能长时间保存字符串(就像线程的关键部分)。实际上，无论你是否使用关键功能，安卓的行为似乎都是相似的(但这可能会改变):

    ```cpp
    const jchar* GetStringCritical(jstring string, jboolean* isCopy)
    void ReleaseStringCritical(jstring string, const jchar* carray)
    ```

这是通过 JNI 处理 Java 字符串所需要了解的基本知识。

# 将 Java 原语传递给本机代码

我们可以用 JNI 处理的最简单的元素类型是 Java 原语类型。实际上，Java 和原生端对这种数据使用几乎相同的表示，不需要任何特定的内存管理。

在这一部分中，我们将看到如何将整数传递到本机端，并将它们发送回 Java 端。

### 注

由此产生的项目以`Store_Part6`的名称提供本书。

# 行动时间——在本地存储中处理原语

1.  在`StoreType.java`中，将新的托管整数类型添加到枚举中:

    ```cpp
    public enum StoreType {
        Integer,
        String
    }
    ```

2.  打开`Store.java`并定义我们本地商店提供的新整数功能:

    ```cpp
    public class Store {
        ...
        public native int getCount();

     public native int getInteger(String pKey);
     public native void setInteger(String pKey, int pInt);

        public native String getString(String pKey);
        public native void setString(String pKey, String pString);
    }
    ```

3.  在`StoreActivity`类中，更新`onGetValue()`方法，当在图形用户界面中选择整数条目时，从商店中检索它们:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            ...
            private void onGetValue() {
                ...
                switch (type) {
     case Integer:
     mUIValueEdit.setText(Integer.toString(mStore
     .getInteger(key)));
     break;
                case String:
                    mUIValueEdit.setText(mStore.getString(key));
                    break;
                }
            }
            ...
    ```

4.  另外，在`onSetValue()`方法中插入或更新存储中的整数条目。条目数据需要解析才能传递到原生端:

    ```cpp
            ...
            private void onSetValue() {
                ...
                try {
                    switch (type) {
     case Integer:
     mStore.setInteger(key, Integer.parseInt(value));
     break;
                    case String:
                        mStore.setString(key, value);
                        break;
                    }
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
        }
    }
    ```

5.  在`jni/Store.h`中，在原生`StoreType`枚举和`StoreValue`联合中追加整数类型:

    ```cpp
    ...
    typedef enum {
     StoreType_Integer,
        StoreType_String
    } StoreType;
    typedef union {
     int32_t   mInteger;
        char*     mString;
    } StoreValue;
    ...
    ```

6.  用`javah`刷新 JNI 头文件`jni/com_packtpub_Store.h`。两种新方法`Java_com_packtpub_store_Store_getInteger()`和`Java_com_packtpub_store_Store_getInteger()`应该会出现。
7.  在`jni/com_packtpub_Store.cpp`中，借助生成的 JNI 表头实现`getInteger()`。除了从`int32_t`到`jint`的隐式转换之外，该方法只返回一个条目的整数值，而不进行任何特定的转换。如果出现任何问题，在检索过程中，将返回一个默认值:

    ```cpp
    ...
    JNIEXPORT jint JNICALL Java_com_packtpub_store_Store_getInteger
      (JNIEnv* pEnv, jobject pThis, jstring pKey) {
        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
        if (isEntryValid(pEnv, entry, StoreType_Integer)) {
            return entry->mValue.mInteger;
        } else {
            return 0;
        }
    }
    ...
    ```

8.  第二种方法`setInteger()`在分配的条目中存储给定的整数值。注意这里如何将传递的 JNI 整数反向转换为 C/C++ 整数:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setInteger
      (JNIEnv* pEnv, jobject pThis, jstring pKey, jint pInteger) {
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            entry->mType = StoreType_Integer;
            entry->mValue.mInteger = pInteger;
        }
    }
    ```

## *刚刚发生了什么？*

运行应用。尝试保存一些具有不同键、类型和值的条目。然后试着把它们从本地商店拿回来。这次我们设法将整数原语从 Java 传递和检索到 C/C++。

整数基元在本机调用期间穿几件衣服；首先是 Java 代码中的`int`，然后是从/到 Java 代码传输期间的`jint`，最后是本机代码中的`int`或`int32_t`。显然，如果我们愿意，我们可以在原生代码中保留 JNI 表示 `jint`，因为所有这些类型都是等价的。换句话说，`jint`只是一个别名。

### 类型

`int32_t`类型是 C99 标准库推出的`typedef`，目的是为了更好的移植性。与标准的`int`类型的区别在于，它的字节大小对于所有编译器和平台都是固定的。更多的数字类型在`stdint.h`(在 C 中)或`cstdint`(在 C++ 中)中定义。

在 JNI，所有原始类型都有自己的别名:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

Java 类型

 | 

JNI 类型

 | 

c 型

 | 

标准 C 型

 |
| --- | --- | --- | --- |
| `boolean` | `Jboolean` | `unsigned char` | `uint8_t` |
| `byte` | `Jbyte` | `signed char` | `int8_t` |
| `char` | `Jchar` | `unsigned short` | `uint16_t` |
| `double` | `Jdouble` | `double` | `N/A` |
| `float` | `jfloat` | `float` | `N/A` |
| `int` | `jint` | `Int` | `int32_t` |
| `long` | `jlong` | `long long` | `int64_t` |
| `short` | `jshort` | `Short` | `int16_t` |

你可以像我们在这部分使用整数一样使用它们。关于 JNI 原始类型的更多信息，请访问

## 有一个围棋英雄——传递和返回其他原始类型

当前商店只处理整数和字符串。基于这个模型，尝试实现其他原语类型的存储方法:`boolean`、`byte`、`char`、`double`、`float`、`long`和`short`。

### 注

由此产生的项目以名称`Store_Part6_Full`提供本书。

# 从本机代码中引用 Java 对象

我们从上一节知道，一个字符串在 JNI 表示为`jstring`，实际上是一个 Java 对象，这意味着可以通过 JNI 交换任何一个 Java 对象！但是由于原生代码无法理解或者直接访问 Java，所以所有 Java 对象都有相同的表示方式`jobject`。

在这一部分中，我们将重点关注如何在本机端保存对象，以及如何将其发送回 Java。例如，我们将使用一个自定义对象`Color`，尽管任何其他类型的对象也可以使用。

### 注

由此产生的项目以`Store_Part7`的名称提供本书。

# 行动时间-保存对本机存储中对象的引用

1.  创建一个新的 Java 类`com.packtpub.store.Color`封装一个颜色的整数表示。感谢`android.graphics.Color`类:

    ```cpp
    package com.packtpub.store;
    import android.text.TextUtils;
    public class Color {
        private int mColor;
        public Color(String pColor) {
            if (TextUtils.isEmpty(pColor)) {
                throw new IllegalArgumentException();
            }
            mColor = android.graphics.Color.parseColor(pColor);
        }
        @Override
        public String toString() {
            return String.format("#%06X", mColor);
        }
    }
    ```

    ，从包含 HTML 代码的 `String`解析出这个整数(例如:`#FF0000`
2.  在`StoreType.java`中，将新的颜色数据类型追加到枚举中:

    ```cpp
    public enum StoreType {
        Integer,
        String,
     Color
    }
    ```

3.  在`Store`类中，追加两个新的本地方法来检索和保存一个`Color`对象:

    ```cpp
    public class Store {
        ...
     public native Color getColor(String pKey);
     public native void setColor(String pKey, Color pColor);
    }
    ```

4.  打开 `StoreActivity.java`并将方法`onGetValue()`和`onSetValue()`更新为解析并显示 `Color`实例:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            ...
            private void onGetValue() {
                ...
                switch (type) {
                ...
     case Color:
     mUIValueEdit.setText(mStore.getColor(key)
                                    .toString());
     break;
                }
            }
            private void onSetValue() {
                ...
                try {
                    switch (type) {
                    ...
     case Color:
     mStore.setColor(key, new Color(value));
     break;
                    }
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
        }
    }
    ```

5.  在`jni/Store.h`中，将新的颜色类型追加到`StoreType`枚举中，并向`StoreValue`联盟添加一个新成员。但是应该用什么类型呢，`Color`是从 Java 中只知道的对象吗？在 JNI，所有的 java 对象都有相同的类型；`jobject`，一个(间接的)宾语参考:

    ```cpp
    ...
    typedef enum {
        ...
        StoreType_String,
     StoreType_Color
    } StoreType;
    typedef union {
        ...
        char*     mString;
     jobject   mColor;
    } StoreValue;
    ...
    ```

6.  用`javah`重新生成 JNI 头文件`jni/com_packtpub_Store.h`。你应该会在里面看到两个新方法`Java_com_packtpub_store_Store_getColor()`和`Java_com_packtpub_store_Store_setColor()`。
7.  Open `jni/com_packtpub_Store.cpp` and implement the two freshly generated methods `getColor()` and `setColor()`. The first one simply returns the Java Color object kept in the store entry as shown in the following code:

    ```cpp
    ...
    JNIEXPORT jobject JNICALL Java_com_packtpub_store_Store_getColor
      (JNIEnv* pEnv, jobject pThis, jstring pKey) {
        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
        if (isEntryValid(pEnv, entry, StoreType_Color)) {
            return entry->mValue.mColor;
        } else {
            return NULL;
        }
    }
    ...
    ```

    真正的微妙之处在第二种方法`setColor()`中介绍。事实上，乍一看，简单地在商店条目中保存`jobject`值似乎就足够了。然而，这个假设是错误的。在参数中传递或在 JNI 方法中创建的对象是本地引用。本地引用不能保留在本机方法范围之外的本机代码中(例如字符串)。

8.  要允许在本机方法返回后在本机代码中保留一个 Java 对象引用，它们必须变成全局引用，以便通知达尔维克虚拟机它们不能被垃圾收集。为此，JNI API 提供了`NewGlobalRef()`方法:

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColor
      (JNIEnv* pEnv, jobject pThis, jstring pKey, jobject pColor) {
        // Save the Color reference in the store.
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            entry->mType = StoreType_Color;
            // The Java Color is going to be stored on the native side.
            // Need to keep a global reference to avoid a potential
            // garbage collection after method returns.
            entry->mValue.mColor = pEnv->NewGlobalRef(pColor);
        }
    }
    ```

9.  在`Store.cpp`中，修改`releaseEntryValue()`以删除全局引用，当条目被新条目替换时。这是通过`DeleteGlobalRef()`方法完成的，这是`NewGlobalRef()` :

    ```cpp
    ...
    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {
        switch (pEntry->mType) {
        case StoreType_String:
            delete pEntry->mValue.mString;
            break;
     case StoreType_Color:
     // Unreferences the object for garbage collection.
     pEnv->DeleteGlobalRef(pEntry->mValue.mColor);
     break;
        }
    }
    ```

    的对应物

## *刚刚发生了什么？*

运行应用。输入并保存一个颜色值，如 **#FF0000** 或**红色**，这是安卓颜色解析器允许的预定义值。从商店拿回入口。我们设法在本机端引用了一个 Java 对象！Java 对象不是也不能转换成 C++ 对象。两者本质上是不同的。因此，为了将 Java 对象保持在本地，我们必须使用 JNI API 来保持对它们的引用。

所有来自 Java 的对象都用`jobject`表示，甚至是`jstring`(实际上是内部的`typedef` 对`jobject`)。A `jobject`只是一个没有任何智能垃圾收集机制的哑“指针”(毕竟，我们想摆脱 Java，至少是部分摆脱)。它没有直接引用 Java 对象内存，而是间接引用。事实上，Java 对象在内存中没有固定的位置，与 C++ 对象相反。他们可能会在有生之年被感动。无论如何，在内存中乱搞一个 Java 对象表示都不是一个好主意。

## 本地参考文献

本机调用的作用域仅限于一个方法，这意味着一旦一个本机方法结束，虚拟机就会再次接管。JNI 规范利用这个事实来保持对象引用在方法边界的局部。这意味着`jobject`只能在它被赋予的方法中安全使用。一旦本机方法返回，Dalvik VM 就无法知道本机代码是否仍然保存对象引用，并且可以决定随时收集它们。

这类引用称为**局部**引用。当本机方法返回以允许稍后在 Java 代码中进行适当的垃圾收集时，它们会被自动释放(引用，而不是对象，尽管垃圾收集器可能也会释放)。例如，下面这段代码应该被严格禁止。将这样的引用保留在 JNI 方法之外最终会导致未定义的行为(内存损坏、崩溃等):

```cpp
static jobject gMyReference;
JNIEXPORT void JNICALL Java_MyClass_myMethod(JNIEnv* pEnv,
                                     jobject pThis, jobject pRef) {
    gMyReference = pRef;
    ...
}

// Later on...
env->CallVoidMethod(gMyReference, ...);
```

### 类型

对象作为本地引用传递给本机方法。JNI 函数返回的每个`jobject`(除了`NewGlobalRef()`)都是本地引用。请记住，默认情况下，所有内容都是本地引用。

JNI 提供了几种管理本地参考的方法:

1.  `NewLocalRef()`显式地创建一个(例如，从全局引用)，尽管实际上很少需要这样做:

    ```cpp
    jobject NewLocalRef(jobject ref)
    ```

2.  `DeleteLocalRef()`删除不再需要的:

    ```cpp
    void DeleteLocalRef(jobject localRef)
    ```

### 类型

局部引用不能在方法范围之外使用，也不能在线程之间共享，即使在单个本机调用期间也是如此！

您不需要显式删除本地引用。然而，根据 JNI 规范，一个 JVM 只需要同时存储 16 个本地引用，并且可能拒绝创建更多引用(这是特定于实现的)。因此，最好尽快释放未使用的本地引用，尤其是在使用数组时。

希望 JNI 提供更多的方法来帮助处理本地引用。

1.  `EnsureLocalCapacity()`通知虚拟机它需要更多的本地引用。此方法返回`-1`并在无法保证请求容量时抛出一个 Java`OutOfMemoryError`:

    ```cpp
    jint EnsureLocalCapacity(jint capacity)
    ```

2.  `PushLocalFrame()` and `PopLocalFrame()` offer a second way to allocate more Local references. It can be understood as a way to batch Local slot allocation and Local references deletion. This method also returns `-1` and throws a Java `OutOfMemoryError` when it cannot guarantee the requested capacity:

    ```cpp
    jint PushLocalFrame(jint capacity)
    jobject PopLocalFrame(jobject result)
    ```

    ### 类型

    在安卓 4.0 Ice 奶油三明治之前，本地引用实际上是直接指针，这意味着它们可以保持在自然范围之外，并且仍然可以工作。现在已经不是这样了，必须避免这样的错误代码。

## 全球参考文献

为了能够在方法范围之外使用对象引用或长时间保持它，引用必须是**全局的**。全局引用还允许线程之间共享对象，而本地引用则不是这样。

JNI 为此提供了两种方法:

1.  `NewGlobalRef()`创建全局引用，防止指向对象的垃圾收集，并允许线程间共享。同一对象的两个引用可能不同:

    ```cpp
    jobject NewGlobalRef(jobject obj)
    ```

2.  `DeleteGlobalRef()`删除不再需要的全局引用。没有它，达尔维克虚拟机会认为对象仍然被引用并且永远不会收集它们:

    ```cpp
    void DeleteGlobalRef(jobject globalRef)
    ```

3.  `IsSameObject()`比较两个对象引用，而不是使用`==`，这不是比较引用的正确方式:

    ```cpp
    jboolean IsSameObject(jobject ref1, jobject ref2)
    ```

### 类型

永远不要忘记将`New<Reference Type>Ref()`和`Delete<Reference Type>Ref()`配对。否则会导致内存泄漏。

## 弱引用

弱引用是 JNI 最后一种可用的引用。它们类似于全局引用，因为它们可以在 JNI 调用之间保存，并在线程之间共享。但是，与全局引用不同，它们不阻止垃圾收集。因此，这种引用必须小心使用，因为它随时都可能失效，除非您在每次需要使用之前从它们创建一个全局或本地引用(并在之后立即释放它！).

### 类型

如果使用得当，弱引用有助于防止内存泄漏。如果你已经做过一些安卓开发，你可能已经知道一个最常见的漏洞:从后台线程(通常是`AsyncTask`)保留对活动的“硬”引用，以便在处理结束后通知活动。事实上，在发送通知之前，活动可能会被破坏(例如，因为用户旋转了屏幕)。当使用弱引用时，活动仍然可以被垃圾收集并释放内存。

`NewWeakGlobalRef()`和`DeleteWeakGlobalRef()`是创建和删除弱引用的唯一必要方法:

```cpp
jweak NewWeakGlobalRef(JNIEnv *env, jobject obj);
void DeleteWeakGlobalRef(JNIEnv *env, jweak obj);
```

这些方法返回一个`jweak`引用，如果需要可以将其转换为输入对象(例如，如果创建了对`jclass`的引用，那么返回的`jweak`可以转换为`jclass`或`jobject`)。

但是，您不应该直接使用它，而是将其传递给`NewGlobalRef()`或`NewLocalRef()`，并像往常一样使用它们的结果。为确保弱引用发布的本地或全局引用有效，只需检查由`NewGlobalRef()`或`NewLocalRef()`返回的引用是否为`NULL`。完成对象后，可以删除全局或本地引用。每次再次使用该弱对象时，请重新启动该过程。例如:

```cpp
jobject myObject = ...;
// Keep a reference to that object until it is garbage collected.
jweak weakRef = pEnv->NewWeakGlobalRef(myObject);
...

// Later on, get a real reference, hoping it is still available.
jobject localRef = pEnv->NewLocalRef(weakRef);
if (!localRef) {
// Do some stuff...
pEnv->DeleteLocalRef(localRef);
} else {
   // Object has been garbage collected, reference is unusable...
}

...
// Later on, when weak reference is no more needed.
pEnv->DeleteWeakGlobalRef(weakRef);
```

要检查弱引用本身是否指向对象，请使用`IsSameObject()`比较`jweak`和`NULL`(不要使用`==`):

```cpp
jboolean IsSameObject(jobject ref1, jobject ref2)
```

在创建全局或局部引用之前，不要试图检查弱引用状态，因为指向的对象可能同时被收集。

### 类型

在安卓 2.2 Froyo 之前，弱引用根本不存在。在安卓 4.0 冰淇淋三明治之前，除了`NewGlobalRef()`或`NewLocalRef()`之外，它们不能在 JNI 通话中使用。尽管这不再是一项义务，但在其他 JNI 通话中直接使用弱引用应该被认为是一种糟糕的做法。

有关该主题的更多信息，请查看位于[的 JNI 规范。](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html)

# 管理 Java 数组

还有最后一类数据我们还没有谈到:**数组**。数组在 Java 和 JNI 都有特定的位置。它们有自己合适的类型和 API，尽管 Java 数组也是它们的根对象。

在这一部分，我们将通过让用户在一个条目中同时输入一组值来改进我们的商店。这个集合将作为一个 Java 数组传递给本地存储，而本地存储又将作为一个经典的 C 数组存储。

### 注

由此产生的项目以`Store_Part8`的名称提供本书。

# 行动时间——在本地存储中处理 Java 数组

为了帮助我们处理数组上的操作，让我们下载一个助手库，**谷歌番石榴**(在撰写本书时发布 18.0)可在[http://code.google.com/p/guava-libraries/](http://code.google.com/p/guava-libraries/)获得。番石榴提供了许多有用的方法来处理原语和数组，并执行“伪函数”编程。

复制中的`guava jar`项目`libs`目录。打开**属性**项目，转到 **Java 构建路径** | **库**。点击**添加广口瓶，参考番石榴广口瓶...**按钮并验证。

1.  编辑`StoreType.java`枚举并添加三个新值:`IntegerArray`、`StringArray`和`ColorArray` :

    ```cpp
    public enum StoreType {
        ...
        Color,
        IntegerArray,
        StringArray,
        ColorArray
    }
    ```

2.  打开`Store.java`和添加新的方法来检索和保存`int`、`String`和`Color`数组:

    ```cpp
    public class Store {
        ...
     public native int[] getIntegerArray(String pKey);
     public native void setIntegerArray(String pKey, int[] pIntArray);
     public native String[] getStringArray(String pKey);
     public native void setStringArray(String pKey,
     String[] pStringArray);
     public native Color[] getColorArray(String pKey);
     public native void setColorArray(String pKey,Color[] pColorArray);
    }
    ```

3.  Edit `StoreActivity.java` to connect native methods to the GUI.

    修改`onGetValue()`方法，使其根据数组的类型从存储中检索数组，用分号分隔连接数组的值(得益于番石榴连接符)，最后显示它们:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            ...
            private void onGetValue() {
                ...
                switch (type) {
                ...
     case IntegerArray:
     mUIValueEdit.setText(Ints.join(";", mStore
     .getIntegerArray(key)));
     break;
     case StringArray:
     mUIValueEdit.setText(Joiner.on(";").join(
     mStore.getStringArray(key)));
     break;
     case ColorArray:
     mUIValueEdit.setText(Joiner.on(";").join(mStore
     .getColorArray(key)));
     break;            case IntegerArray:
                }
            }
            ...
    ```

4.  改进`onSetValue()`将值列表转换为数组，然后将其传输到`Store`(得益于番石榴变换功能):

    ```cpp
            ...
            private void onSetValue() {
                ...
                try {
                    switch (type) {
                    ...
                    case IntegerArray:
     mStore.setIntegerArray(key, Ints.toArray(
     stringToList(new Function<String, Integer>() {
     public Integer apply(String pSubValue) {
     return Integer.parseInt(pSubValue);
     }
     }, value)));
     break;
     case StringArray:
     String[] stringArray = value.split(";");
     mStore.setStringArray(key, stringArray);
     break;
     case ColorArray:
     List<Color> idList = stringToList(
     new Function<String, Color>() {
     public Color apply(String pSubValue) {
     return new Color(pSubValue);
     }
     }, value);
     mStore.setColorArray(key, idList.toArray(
     new Color[idList.size()]));
     break;
                    }
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
    ```

5.  写一个助手方法`stringToList()`帮你把一个字符串转换成目标类型的列表:

    ```cpp
            ...
            private <TType> List<TType> stringToList(
                            Function<String, TType> pConversion,
                            String pValue) {
                String[] splitArray = pValue.split(";");
                List<String> splitList = Arrays.asList(splitArray);
                return Lists.transform(splitList, pConversion);
            }
        }
    }
    ```

6.  在`jni/Store.h`中，将新的数组类型添加到`StoreType`枚举中。另外，在`StoreValue` 联盟中申报新领域`mIntegerArray`、`mStringArray`和`mColorArray` 。存储数组表示为原始 C 数组(即指针):

    ```cpp
    ...
    typedef enum {
        ...
        StoreType_Color,
     StoreType_IntegerArray,
     StoreType_StringArray,
     StoreType_ColorArray
    } StoreType;

    typedef union {
        ...
        jobject   mColor;
     int32_t*  mIntegerArray;
     char**    mStringArray;
     jobject*  mColorArray;
    } StoreValue;
    ...
    ```

7.  我们还需要记住这些数组的长度。在`StoreEntry` :

    ```cpp
    ...
    typedef struct {
        char* mKey;
        StoreType mType;
        StoreValue mValue;
     int32_t mLength;
    } StoreEntry;
    ...
    ```

    的新字段`mLength`中输入该信息
8.  在`jni/Store.cpp`中，为新数组类型在`releaseEntryValue()`中插入案例。事实上，当相应的条目被释放时，分配的数组必须被释放。由于颜色是 Java 对象，删除保存在每个数组项中的全局引用，否则永远不会发生垃圾收集(导致内存泄漏):

    ```cpp
    void releaseEntryValue(JNIEnv* pEnv, StoreEntry* pEntry) {
        switch (pEntry->mType) {
        ...
     case StoreType_IntegerArray:
     delete[] pEntry->mValue.mIntegerArray;
     break;
     case StoreType_StringArray:
     // Destroys every C string pointed by the String array
     // before releasing it.
     for (int32_t i = 0; i < pEntry->mLength; ++ i) {
     delete pEntry->mValue.mStringArray[i];
     }
     delete[] pEntry->mValue.mStringArray;
     break;
     case StoreType_ColorArray:
     // Unreferences every Id before releasing the Id array.
     for (int32_t i = 0; i < pEntry->mLength; ++ i) {
     pEnv->DeleteGlobalRef(pEntry->mValue.mColorArray[i]);
     }
     delete[] pEntry->mValue.mColorArray;
     break;
        }
    }
    ...
    ```

9.  用`Javah`重新生成 JNI 表头`jni/com_packtpub_Store.h`。在`jni/com_packtpub_Store.cpp`中，实施所有这些新方法。为此，首先添加`csdtint` include。

    ```cpp
    #include "com_packtpub_store_Store.h"
    #include <cstdint>
    #include <cstdlib>
    #include "Store.h"
    ...
    ```

10.  Then, cache the `String` and `Color` JNI Classes to be able to create, in the following steps, object arrays of these types. Classes are accessible by reflection from `JNIEnv` itself, and are retrievable from the `JavaVM` given to `JNI_OnLoad()`.

    我们需要检查找到的类是否为空，以防无法加载。如果发生这种情况，虚拟机会引发异常，这样我们就可以立即返回:

    ```cpp
    ...
    static jclass StringClass;
    static jclass ColorClass;

    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {
     JNIEnv *env;
     if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {
     abort();
     }
     // If returned class is null, an exception is raised by the VM.
     jclass StringClassTmp = env->FindClass("java/lang/String");
     if (StringClassTmp == NULL) abort();
     StringClass = (jclass) env->NewGlobalRef(StringClassTmp);
     env->DeleteLocalRef(StringClassTmp);
     jclass ColorClassTmp = env->FindClass("com/packtpub/store/Color");
     if (ColorClassTmp == NULL) abort();
     ColorClass = (jclass) env->NewGlobalRef(ColorClassTmp);
     env->DeleteLocalRef(ColorClassTmp);
        // Store initialization.
        gStore.mLength = 0;
        return JNI_VERSION_1_6;
    }
    ...
    ```

11.  Write a `getIntegerArray()` implementation. A JNI array of integers is represented with the `jintArray` type. If an `int` is equivalent to `jint`, an `int*` array is absolutely not equivalent to `jintArray`. The first is a pointer to a memory buffer, whereas the second is a reference to an object.

    因此，要在这里返回`jintArray`，用`NewIntArray()` JNI API 方法实例化一个新的 Java 整数数组。然后，使用`SetIntArrayRegion()`将原生`int`缓冲内容复制到`jintArray`中:

    ```cpp
    ...
    JNIEXPORT jintArray JNICALL
    Java_com_packtpub_store_Store_getIntegerArray
      (JNIEnv* pEnv, jobject pThis, jstring pKey) {
        StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
        if (isEntryValid(pEnv, entry, StoreType_IntegerArray)) {
            jintArray javaArray = pEnv->NewIntArray(entry->mLength);
            pEnv->SetIntArrayRegion(javaArray, 0, entry->mLength,
                                    entry->mValue.mIntegerArray);
            return javaArray;
        } else {
            return NULL;
        }
    }
    ...
    ```

12.  要在本机代码中保存一个 Java 数组，存在反向操作`GetIntArrayRegion()`。分配合适的内存缓冲区的唯一方法是用`GetArrayLength()` :

    ```cpp
    ...
    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setIntegerArray
      (JNIEnv* pEnv, jobject pThis, jstring pKey,
       jintArray pIntegerArray) {
        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
        if (entry != NULL) {
            jsize length = pEnv->GetArrayLength(pIntegerArray);
            int32_t* array = new int32_t[length];
            pEnv->GetIntArrayRegion(pIntegerArray, 0, length, array);

            entry->mType = StoreType_IntegerArray;
            entry->mLength = length;
            entry->mValue.mIntegerArray = array;
        }
    }
    ...
    ```

    测量数组大小

Java 对象数组与 Java 原语数组不同。它们用类类型(这里是缓存的`String jclass`)进行实例化，因为 Java 数组是单类型的。对象数组本身用`jobjectArray`类型表示，可以用`NewObjectArray()` JNI API 方法创建。

与基元数组不同，不可能同时处理所有元素。而是用`SetObjectArrayElement()`逐个设置对象。这里，原生数组充满了存储在原生端的`String`对象，它保存了对这些对象的全局引用。因此，除了对新分配的字符串的引用之外，这里不需要删除或创建任何引用。

```cpp
...
JNIEXPORT jobjectArray JNICALL
Java_com_packtpub_store_Store_getStringArray
  (JNIEnv* pEnv, jobject pThis, jstring pKey) {
    StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
    if (isEntryValid(pEnv, entry, StoreType_StringArray)) {
        // An array of String in Java is in fact an array of object.
        jobjectArray javaArray = pEnv->NewObjectArray(entry->mLength,
                StringClass, NULL);
        // Creates a new Java String object for each C string stored.
        // Reference to the String can be removed right after it is
        // added to the Java array, as the latter holds a reference
        // to the String object.
        for (int32_t i = 0; i < entry->mLength; ++ i) {
            jstring string = pEnv->NewStringUTF(
                    entry->mValue.mStringArray[i]);
            // Puts the new string in the array
            pEnv->SetObjectArrayElement(javaArray, i, string);
            // Do it here to avoid holding many useless local refs.
            pEnv->DeleteLocalRef(string);
        }
        return javaArray;
    } else {
        return NULL;
    }
}
...
```

在`setStringArray()`中，用`GetObjectArrayElement()`逐个检索数组元素。返回的引用是本地的，应该是全局的，以便在本地安全地存储它们。

```cpp
...
JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setStringArray
  (JNIEnv* pEnv, jobject pThis, jstring pKey,
   jobjectArray pStringArray) {
    // Creates a new entry with the new String array.
    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
    if (entry != NULL) {
        // Allocates an array of C string.
        jsize length = pEnv->GetArrayLength(pStringArray);
        char** array = new char*[length];
        // Fills the C array with a copy of each input Java string.
        for (int32_t i = 0; i < length; ++ i) {
            // Gets the current Java String from the input Java array.
            // Object arrays can be accessed element by element only.
            jstring string = (jstring)
                         pEnv->GetObjectArrayElement(pStringArray, i);
            jsize stringLength = pEnv->GetStringUTFLength(string);
            array[i] = new char[stringLength + 1];
            // Directly copies the Java String into our new C buffer.
            pEnv->GetStringUTFRegion(string,0,stringLength, array[i]);
            // Append the null character for string termination.
            array[i][stringLength] = '\0';
            // No need to keep a reference to the Java string anymore.
            pEnv->DeleteLocalRef(string);
        }
        entry->mType = StoreType_StringArray;
        entry->mLength = length;
        entry->mValue.mStringArray = array;
    }
}
```

对颜色执行同样的操作，从`getColorArray()`开始。由于字符串和颜色在 Java 端都是对象，返回的数组可以用`NewObjectArray()`同样的方式创建。

使用 JNI 方法`SetObjectArrayElement()`将保存的每个`Color`参考放置在数组中。由于颜色作为全局 Java 引用存储在本机端，因此不需要创建本地引用或删除:

```cpp
...
JNIEXPORT jobjectArray JNICALL
Java_com_packtpub_store_Store_getColorArray
  (JNIEnv* pEnv, jobject pThis, jstring pKey) {
    StoreEntry* entry = findEntry(pEnv, &gStore, pKey);
    if (isEntryValid(pEnv, entry, StoreType_ColorArray)) {
        // Creates a new array with objects of type Id.
        jobjectArray javaArray = pEnv->NewObjectArray(entry->mLength,
                ColorClass, NULL);
        // Fills the array with the Color objects stored on the native
        // side, which keeps a global reference to them. So no need
        // to delete or create any reference here.
        for (int32_t i = 0; i < entry->mLength; ++ i) {
            pEnv->SetObjectArrayElement(javaArray, i,
                                        entry->mValue.mColorArray[i]);
        }
        return javaArray;
    } else {
        return NULL;
    }
}
...
```

在`setColorArray()`中，颜色元素也是用`GetObjectArrayElement()`一个一个检索。同样，这里返回的引用是本地的，应该是全局的，以便在本地安全地存储它们:

```cpp
...
JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColorArray
  (JNIEnv* pEnv, jobject pThis, jstring pKey,
   jobjectArray pColorArray) {
    // Saves the Color array in the store.
    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
    if (entry != NULL) {
        // Allocates a C array of Color objects.
        jsize length = pEnv->GetArrayLength(pColorArray);
        jobject* array = new jobject[length];
        // Fills the C array with a copy of each input Java Color.
        for (int32_t i = 0; i < length; ++ i) {
            // Gets the current Color object from the input Java array.
            // Object arrays can be accessed element by element only.
            jobject localColor = pEnv->GetObjectArrayElement(
                    pColorArray, i);
            // The Java Color is going to be stored on the native side
            // Need to keep a global reference to avoid a potential
            // garbage collection after method returns.
            array[i] = pEnv->NewGlobalRef(localColor);
            // We have a global reference to the Color, so we can now
            // get rid of the local one.
            pEnv->DeleteLocalRef(localColor);
        }
        entry->mType = StoreType_ColorArray;
        entry->mLength = length;
        entry->mValue.mColorArray = array;
    }
}
```

## *刚刚发生了什么？*

我们将 Java 数组从 Java 端传输到本机端，反之亦然。Java 数组是只能通过专用的 JNI 应用编程接口操作的 Java 对象。它们不能被转换成本机 C/C++ 数组，并且不能以同样的方式使用。

我们还看到了如何利用`JNI_OnLoad()`回调来缓存 JNI 类描述符。类描述符，类型`jclass`(也是幕后的`jobject`，相当于 Java 中的`Class<?>`。它们允许定义我们想要的数组类型，有点像 Java 中的反射 API。我们将在下一章回到这个话题。

## 原始数组

可用的基元数组类型有`jbooleanArray`、`jbyteArray`、`jcharArray`、`jdoubleArray`、`jfloatArray`、`jlongArray`和`jshortArray`。这些类型表示对真实 Java 数组的引用。

这些阵列可以通过 JNI 提供的几种方法进行操作:

1.  `New<Primitive>Array()`创建新的 Java 数组:

    ```cpp
    jintArray NewIntArray(jsize length)
    ```

2.  `GetArrayLength()`检索数组的长度:

    ```cpp
    jsize GetArrayLength(jarray array)
    ```

3.  `Get<Primitive>ArrayElements()`将整个数组检索到 JNI 分配的内存缓冲区中。最后一个参数`isCopy`，当不为空时，表示一个数组是被 JNI 内部复制了还是返回了缓冲点到真正的 Java 字符串内存:

    ```cpp
    jint* GetIntArrayElements(jintArray array, jboolean* isCopy)
    ```

4.  `Release<Primitive>ArrayElements()`释放`Get<Primitive>ArrayElements()`分配的内存缓冲区。两者总是成对使用。最后一个参数模式与`isCopy`参数相关，表示如下:
    *   如果为 0，那么 JNI 应该将修改后的数组复制回初始 Java 数组，并告诉 JNI 释放其临时内存缓冲区。这是最常见的旗帜。
    *   如果`JNI_COMMIT`，那么 JNI 应该将修改后的数组复制回初始数组，但不释放内存。这样，客户端代码可以将结果传输回 Java，同时仍然在内存缓冲区上继续工作。
    *   如果`JNI_ABORT`，那么 JNI 必须放弃在内存缓冲区中所做的任何更改，并且保持 Java 数组不变。如果临时本机内存缓冲区不是副本，这将无法正常工作。

        ```cpp
        void ReleaseIntArrayElements(jintArray array, jint* elems, jint mode)
        ```

5.  `Get<Primitive>ArrayRegion()`将数组的全部或部分检索到客户端代码分配的内存缓冲区中。例如整数:

    ```cpp
    void GetIntArrayRegion(jintArray array, jsize start, jsize len,
                           jint* buf)
    ```

6.  `Set<Primitive>ArrayRegion()`从客户端代码管理的本机缓冲区初始化 Java 数组的全部或部分。例如整数:

    ```cpp
    void SetIntArrayRegion(jintArray array, jsize start, jsize len,
                           const jint* buf)
    ```

7.  `Get<Primitive>ArrayCritical()`和`Release<Primitive>ArrayCritical()`类似于`Get<Primitive>ArrayElements()`和`Release<Primitive>ArrayElements()`，但仅可用于提供对目标阵列的直接访问(而不是拷贝)。作为交换，调用者不得执行阻塞或 JNI 调用，也不应长时间持有数组(如带有线程的临界区)。并不是所有的原语都有相同的两种方法:

    ```cpp
    void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy)
    void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode)
    ```

## 有一个围棋英雄——处理其他数组类型

有了新获取的知识，可以实现其他数组类型的存储方式:`jbooleanArray`、`jbyteArray`、`jcharArray`、`jdoubleArray`、`jfloatArray`、`jlongArray`和`jshortArray`。

例如，您可以使用`GetBooleanArrayElements()`和`ReleaseBooleanArrayElements()`而不是`GetBooleanArrayRegion()`为`jbooleanArray`类型编写`setBooleanArray()`方法。结果应该如下所示，两种方法成对调用，中间有`memcpy()`:

```cpp
...
JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setBooleanArray
  (JNIEnv* pEnv, jobject pThis, jstring pKey,
   jbooleanArray pBooleanArray) {
    // Finds/creates an entry in the store and fills its content.
    StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);
    if (entry != NULL) {
        entry->mType = StoreType_BooleanArray;
        jsize length = pEnv->GetArrayLength(pBooleanArray);
        uint8_t* array = new uint8_t[length];
        // Retrieves array content.
 jboolean* arrayTmp = pEnv->GetBooleanArrayElements(
 pBooleanArray, NULL);
        memcpy(array, arrayTmp, length * sizeof(uint8_t));
        pEnv->ReleaseBooleanArrayElements(pBooleanArray, arrayTmp, 0);
        entry->mType = StoreType_BooleanArray;
        entry->mValue.mBooleanArray = array;
        entry->mLength = length;
    }
}
...
```

### 注

由此产生的项目以`Store_Part8_Full`的名称提供本书。

## 对象数组

对象数组在 JNI 被命名为，表示对一个 Java 对象数组的引用。对象数组是特定的，因为与基元数组不同，每个数组元素都是对对象的引用。因此，每次在数组中插入对象时，都会自动注册一个新的全局引用。这样，当本机调用结束时，引用不会被垃圾收集。请注意，对象数组不能像原语一样转换为“本机”数组。

可以使用 JNI 提供的几种方法来操作对象数组:

1.  `NewObjectArray()`创建新的对象数组实例:

    ```cpp
    jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement);
    ```

2.  `GetArrayLength()`检索数组的长度(方法与原语相同):

    ```cpp
    jsize GetArrayLength(jarray array)
    ```

3.  `GetObjectArrayElement()`从一个 Java 数组中检索一个单个对象引用。返回的引用是本地:

    ```cpp
    jobject GetObjectArrayElement(jobjectArray array, jsize index)
    ```

4.  `SetObjectArrayElement()`将一个单个对象引用放入一个 Java 数组。隐式创建全局引用:

    ```cpp
    void SetObjectArrayElement(jobjectArray array, jsize index, jobject value)
    ```

有关 jni 函数的更详尽的列表，请参见[。](http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/functions.html)

# 引发和检查 Java 异常

商店项目中的错误处理不是很令人满意。如果找不到请求的键，或者如果检索到的值类型与请求的类型不匹配，则返回默认值。甚至不要尝试使用颜色条目。我们绝对需要一种方法来表明发生了错误！还有什么比异常更好的方式来指示错误呢？

JNI 提供了必要的 API 来在 JVM 级别引发异常。这些异常是您可以在 Java 中捕捉到的。它们没有任何共同之处，语法和流程都没有，除了在其他程序中常见的 C++ 异常(我们将在[第 9 章](09.html "Chapter 9. Porting Existing Libraries to Android")、*将现有库移植到 Android* 中看到更多关于它们的内容)。

在这一部分中，我们将看到如何将 JNI 异常从本地提升到 Java 端。

### 注

由此产生的项目以`Store_Part9`的名称提供本书。

# 行动时间-在本地存储中引发&捕获异常

1.  Create the Java exception `com.packtpub.exception.InvalidTypeException` of type `Exception` as follows:

    ```cpp
    package com.packtpub.exception;

    public class InvalidTypeException extends Exception {
        public InvalidTypeException(String pDetailMessage) {
            super(pDetailMessage);
        }
    }
    ```

    对另外两个例外重复操作:`Exception`类型的`NotExistingKeyException`和`RuntimeException`类型的`StoreFullException`。

2.  Open `Store.java` and declare thrown exceptions on `getInteger()` in class `Store` (`StoreFullException` is `RuntimeException` and does not need declaration):

    ```cpp
    public class Store {
        ...
        public native int getInteger(String pKey)
     throws NotExistingKeyException, InvalidTypeException;
        public native void setInteger(String pKey, int pInt);
        ...
    ```

    对所有其他 getter 原型(字符串、颜色等)重复该操作。

3.  这些例外需要被抓住。赶`onGetValue()``NotExistingKeyException``InvalidTypeException`:

    ```cpp
    public class StoreActivity extends Activity {
        ...
        public static class PlaceholderFragment extends Fragment {
            ...
            private void onGetValue() {
                ...
                try {
                    switch (type) {
                    ...
                }
     // Process any exception raised while retrieving data.
     catch (NotExistingKeyException eNotExistingKeyException) {
     displayMessage(eNotExistingKeyException.getMessage());
     } catch (InvalidTypeException eInvalidTypeException) {
     displayMessage(eInvalidTypeException.getMessage());
                }
            }
    ```

4.  抓住`onSetValue()`中的 `StoreFullException`，以防由于的存储容量耗尽而无法插入条目:

    ```cpp
            private void onSetValue() {
                ...
                try {
                    ...
                } catch (NumberFormatException eNumberFormatException) {
                    displayMessage("Incorrect value.");
     } catch (StoreFullException eStoreFullException) {
     displayMessage(eStoreFullException.getMessage());
                } catch (Exception eException) {
                    displayMessage("Incorrect value.");
                }
                updateTitle();
            }
            ...
        }
    }
    ```

5.  打开在前面的部分中创建的`jni/Store.h`并定义三个新的辅助方法来抛出异常:

    ```cpp
    ...
    void throwInvalidTypeException(JNIEnv* pEnv);

    void throwNotExistingKeyException(JNIEnv* pEnv);

    void throwStoreFullException(JNIEnv* pEnv);
    #endif
    ```

6.  编辑`jni/Store.cpp`文件，当从商店获得不合适的条目时，抛出`NotExistingKeyException`和`InvalidTypeException`。举起它们的一个好地方是在用`isEntryValid()` :

    ```cpp
    ...
    bool isEntryValid(JNIEnv* pEnv, StoreEntry* pEntry, StoreType pType) {
        if (pEntry == NULL) {
            throwNotExistingKeyException(pEnv);
        } else if (pEntry->mType != pType) {
            throwInvalidTypeException(pEnv);
        }
        return !pEnv->ExceptionCheck();
    }
    ...
    ```

    检查条目时
7.  `StoreFullException`在插入新条目时明显升高。将同一文件中的 `allocateEntry()`修改为检查条目插入:

    ```cpp
    ...
    StoreEntry* allocateEntry(JNIEnv* pEnv, Store* pStore, jstring pKey) {
        // If entry already exists in the store, releases its content
        // and keep its key.
        StoreEntry* entry = findEntry(pEnv, pStore, pKey);
        if (entry != NULL) {
            releaseEntryValue(pEnv, entry);
        }
        // If entry does not exist, create a new entry
        // right after the entries already stored.
        else {
            // Checks store can accept a new entry.
     if (pStore->mLength >= STORE_MAX_CAPACITY) {
     throwStoreFullException(pEnv);
     return NULL;
            }
            entry = pStore->mEntries + pStore->mLength;
            // Copies the new key into its final C string buffer.
            ...
        }
        return entry;
    }
    ...
    ```

执行`throwNotExistingException()`。要抛出一个 Java 异常，第一个任务是找到对应的类(就像 Java 反射 API 一样)。因为我们可以假设这些异常不会频繁出现，所以我们可以阻止缓存类引用。然后，用`ThrowNew()`抬高异常。一旦我们不再需要异常类引用，我们就可以用`DeleteLocalRef`():

```cpp
...
void throwNotExistingKeyException(JNIEnv* pEnv) {
    jclass clazz = pEnv->FindClass(
                    "com/packtpub/exception/NotExistingKeyException");
    if (clazz != NULL) {
        pEnv->ThrowNew(clazz, "Key does not exist.");
    }
    pEnv->DeleteLocalRef(clazz);
}
```

对另外两个例外重复操作。代码是相同的(甚至抛出一个运行时异常)，只有类名发生了变化。

## *刚刚发生了什么？*

启动应用，并尝试使用不存在的密钥获取条目。用一个条目重复该操作，该条目存在于商店中，但与图形用户界面中选择的类型不同。在这两种情况下，都会出现一条错误消息。尝试在存储中保存 16 个以上的引用，您将再次收到错误。在每种情况下，都会在本机端引发一个异常，并在 Java 端被捕获。

在本机代码中引发异常并不是一项复杂的任务，但也不是微不足道的。使用类型为`jclass`的类描述符实例化异常。JNI 需要这个类描述符来实例化适当类型的异常。JNI 异常不会在 JNI 方法原型上声明，因为它们与 C++ 异常(无论如何都不能用 C 声明的异常)无关。这解释了为什么我们没有重新生成 JNI 报头来适应`Store.java file`中的变化。

## 在异常状态下执行代码

一旦出现异常，就要小心你的 JNI 电话。实际上，任何后续调用都会失败，直到发生以下任一事件:

1.  返回方法并传播异常。
2.  异常被清除。清除异常意味着异常被处理，因此不会传播到 Java。例如:

    ```cpp
    // Raise an exception
    jclass clazz = pEnv->FindClass("java/lang/RuntimeException");
    if (clazz != NULL) {
      pEnv->ThrowNew(clazz, "Oups an exception.");
    }
    pEnv->DeleteLocalRef(clazz);

    ...

    // Detect and catch the exception by clearing it.
    jthrowable exception = pEnv->ExceptionOccurred();
    if (exception) {
      // Do something...
      pEnv->ExceptionDescribe();
      pEnv->ExceptionClear();
      pEnv->DeleteLocalRef(exception);
    }
    ```

只有少数 JNI 方法在引发异常后仍然可以安全调用:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| `DeleteGlobalRef` | `PopLocalFrame` |
| `DeleteLocalRef` | `PushLocalFrame` |
| `DeleteWeakGlobalRef` | `Release<Primitive>ArrayElements` |
| `ExceptionCheck` | `ReleasePrimitiveArrayCritical` |
| `ExceptionClear` | `ReleaseStringChars` |
| `ExceptionDescribe` | `ReleaseStringCritical` |
| `ExceptionOccurred` | `ReleaseStringUTFChars` |
| `MonitorExit` |   |

不要试图调用任何其他 JNI 方法。本机代码应该清理其资源，并尽快将控制权交还给 Java(或处理异常本身)。事实上，JNI 异常与 C++ 异常没有任何共同之处。他们的执行流程完全不同。当从本机代码引发 Java 异常时，后者仍然可以继续处理。然而，一旦本地调用返回给 Java 虚拟机，后者就会像往常一样传播异常。换句话说，从本机代码引发的 JNI 异常只影响 Java 代码(JNI 调用前面列出的其他代码)。

## 异常处理 API

JNI 提供了几种方法来管理异常，其中包括:

1.  `ThrowNew()`引发异常本身，分配一个新实例:

    ```cpp
    jint ThrowNew(jclass clazz, const char* message)
    ```

2.  `Throw()`引发已经分配的异常(例如，重新引发):

    ```cpp
    jint Throw(jthrowable obj)
    ```

3.  `ExceptionCheck()`检查异常是否挂起，不管是谁引发的(本机代码还是 Java 回调)。返回一个简单的`jboolean`，这使得它适合简单的检查:

    ```cpp
    jboolean ExceptionCheck()
    ```

4.  `ExceptionOccurred()`检索对引发异常的`jthrowable`引用:

    ```cpp
    jthrowable ExceptionOccurred()
    ```

5.  `ExceptionDescribe()`相当于 Java 中的`printStackTrace()`:

    ```cpp
    void ExceptionDescribe()
    ```

6.  异常可以用`ExceptionClear()` :

    ```cpp
    void ExceptionClear()
    ```

    标记为在本地被捕获

学习如何使用这些方法编写健壮的代码是至关重要的，尤其是从本机代码回调 Java 时。我们将在下一章中学习更多关于这个主题的知识。

# 总结

在这一章中，我们看到了如何让 Java 与 C/C++ 进行通信。安卓现在几乎是双语了！Java 可以用任何类型的数据或对象调用 C/C++ 代码。

我们首先使用`JNI_OnLoad`钩子初始化了一个本地 JNI 库。然后，我们在本机代码中转换了 Java 字符串，并看到了修改后的 UTF-8 和 UTF-16 字符编码之间的区别。我们还将 Java 原语传递给了本机代码。这些原语中的每一个都有它们的 C/C++ 等价类型，它们可以被强制转换到该类型。

我们还使用全局引用处理了本机代码中的 Java 对象引用，并了解了这些引用和本地引用之间的区别。第一个必须小心删除，以确保正确的垃圾收集，而后者有本机方法范围，必须小心管理，因为默认情况下它们的数量是有限的。

我们还讨论了如何在本机代码中管理 Java 数组，以便我们可以作为本机数组访问它们的内容。当在本机代码中操作时，虚拟机可以复制阵列，也可以不复制阵列。必须考虑这种性能损失。

最后，我们在本机代码中引发并检查了 Java 异常。我们看到它们有不同于标准 C++ 异常的流程。当异常发生时，只有少数清洁 JNI 方法可以安全调用。JNI 异常是 JVM 级别的异常，这意味着它们的流程与标准的 C++ 异常完全不同。

然而，未来还有更多。本机代码可以调用或检索任何 Java 对象、方法或字段。让我们在下一章中看看如何从 C/C++ 代码调用 Java。